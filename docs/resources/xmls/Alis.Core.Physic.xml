<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Alis.Core.Physic</name>
    </assembly>
    <members>
        <member name="T:Alis.Core.Physic.Collision.AabbHelper">
            <summary>
                The aabb helper class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.AabbHelper.ComputeEdgeAabb(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Transform@,Alis.Core.Physic.Shared.Aabb@)">
            <summary>
                Computes the edge aabb using the specified start
            </summary>
            <param name="start">The start</param>
            <param name="end">The end</param>
            <param name="transform">The transform</param>
            <param name="aabb">The aabb</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.AabbHelper.ComputeCircleAabb(Alis.Core.Aspect.Math.Vector.Vector2F@,System.Single,Alis.Core.Aspect.Math.Transform@,Alis.Core.Physic.Shared.Aabb@)">
            <summary>
                Computes the circle aabb using the specified pos
            </summary>
            <param name="pos">The pos</param>
            <param name="radius">The radius</param>
            <param name="transform">The transform</param>
            <param name="aabb">The aabb</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.AabbHelper.ComputePolygonAabb(Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Transform@,Alis.Core.Physic.Shared.Aabb@)">
            <summary>
                Computes the polygon aabb using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <param name="transform">The transform</param>
            <param name="aabb">The aabb</param>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1">
            <summary>
                A dynamic tree arranges data in a binary tree to accelerate queries such as volume queries and ray casts.
                Leafs are proxies with an AABB. In the tree we expand the proxy AABB by Settings.b2_fatAABBFactor so that the proxy
                AABB is bigger than the client object. This allows the client object to move by small amounts without triggering a
                tree
                update. Nodes are pooled and relocatable, so we use node indices rather than pointers.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.queryStack">
            <summary>
                The stack
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.raycastStack">
            <summary>
                The stack
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.freeList">
            <summary>
                The free list
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.nodeCapacity">
            <summary>
                The node capacity
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.nodeCount">
            <summary>
                The node count
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.nodes">
            <summary>
                The nodes
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.root">
            <summary>
                The root
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.#ctor">
            <summary>Constructing the tree initializes the node pool.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.Height">
            <summary>Compute the height of the binary tree in O(N) time. Should not be called often.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.AreaRatio">
            <summary>Get the ratio of the sum of the node areas to the root area.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.Balance">
            <summary>
                Get the maximum balance of an node in the tree. The balance is the difference in height of the two children of
                a node.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.NullNode">
            <summary>
                The null node
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.CreateProxy(Alis.Core.Physic.Shared.Aabb@,`0)">
            <summary>
                Create a proxy in the tree as a leaf node. We return the index of the node instead of a pointer so that we can
                grow the node pool.
            </summary>
            <param name="aabb">The AABB.</param>
            <param name="userData">The user data.</param>
            <returns>Index of the created proxy</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.DestroyProxy(System.Int32)">
            <summary>Destroy a proxy. This asserts if the id is invalid.</summary>
            <param name="proxyId">The proxy id.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.MoveProxy(System.Int32,Alis.Core.Physic.Shared.Aabb@,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Move a proxy with a swepted AABB. If the proxy has moved outside of its fattened AABB, then the proxy is
                removed from the tree and re-inserted. Otherwise the function returns immediately.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <param name="aabb">The AABB.</param>
            <param name="displacement">The displacement.</param>
            <returns>true if the proxy was re-inserted.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.WasMoved(System.Int32)">
            <summary>
                Describes whether this instance was moved
            </summary>
            <param name="proxyId">The proxy id</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.ClearMoved(System.Int32)">
            <summary>
                Clears the moved using the specified proxy id
            </summary>
            <param name="proxyId">The proxy id</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.GetUserData(System.Int32)">
            <summary>
                Gets the user data using the specified proxy id
            </summary>
            <param name="proxyId">The proxy id</param>
            <returns>The</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.GetFatAabb(System.Int32,Alis.Core.Physic.Shared.Aabb@)">
            <summary>Get the fat AABB for a proxy.</summary>
            <param name="proxyId">The proxy id.</param>
            <param name="fatAabb">The fat AABB.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.Query(System.Func{System.Int32,System.Boolean},Alis.Core.Physic.Shared.Aabb@)">
            <summary>
                Query an AABB for overlapping proxies. The callback class is called for each proxy that overlaps the supplied
                AABB.
            </summary>
            <param name="callback">The callback.</param>
            <param name="aabb">The AABB.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.RayCast(System.Func{Alis.Core.Physic.Collision.RayCast.RayCastInput,System.Int32,System.Single},Alis.Core.Physic.Collision.RayCast.RayCastInput@)">
            <summary>
                Ray-cast against the proxies in the tree. This relies on the callback to perform a exact ray-cast in the case
                were the proxy contains a Shape. The callback also performs the any collision filtering. This has performance
                roughly
                equal to k * log(n), where k is the number of collisions and n is the number of proxies in the tree.
            </summary>
            <param name="callback">A callback class that is called for each proxy that is hit by the ray.</param>
            <param name="input">The ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.AllocateNode">
            <summary>
                Allocates the node
            </summary>
            <returns>The node id</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.FreeNode(System.Int32)">
            <summary>
                Frees the node using the specified node id
            </summary>
            <param name="nodeId">The node id</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.InsertLeaf(System.Int32)">
            <summary>
                Inserts the leaf using the specified leaf
            </summary>
            <param name="leaf">The leaf</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.RemoveLeaf(System.Int32)">
            <summary>
                Removes the leaf using the specified leaf
            </summary>
            <param name="leaf">The leaf</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.BalanceTo(System.Int32)">
            <summary>Perform a left or right rotation if node A is imbalanced.</summary>
            <param name="iA"></param>
            <returns>the new root index.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.ComputeHeight(System.Int32)">
            <summary>Compute the height of a sub-tree.</summary>
            <param name="nodeId">The node id to use as parent.</param>
            <returns>The height of the tree.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.ComputeHeight">
            <summary>Compute the height of the entire tree.</summary>
            <returns>The height of the tree.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.ValidateStructure(System.Int32)">
            <summary>
                Validates the structure using the specified index
            </summary>
            <param name="index">The index</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.ValidateMetrics(System.Int32)">
            <summary>
                Validates the metrics using the specified index
            </summary>
            <param name="index">The index</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.Validate">
            <summary>Validate this tree. For testing.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.RebuildBottomUp">
            <summary>Build an optimal tree. Very expensive. For testing.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTree`1.ShiftOrigin(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Shift the origin of the nodes</summary>
            <param name="newOrigin">The displacement to use.</param>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase">
            <summary>
                The broad-phase is used for computing pairs and performing volume queries and ray casts. This broad-phase does
                not persist pairs. Instead, this reports potentially new pairs. It is up to the client to consume the new pairs and
                to
                track subsequent overlap.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.queryCallback">
            <summary>
                The query callback
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.tree">
            <summary>
                The fixture proxy
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.moveBuffer">
            <summary>
                The move buffer
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.moveCapacity">
            <summary>
                The move capacity
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.moveCount">
            <summary>
                The move count
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.pairBuffer">
            <summary>
                The pair buffer
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.pairCapacity">
            <summary>
                The pair capacity
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.pairCount">
            <summary>
                The pair count
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.proxyCount">
            <summary>
                The proxy count
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.queryProxyId">
            <summary>
                The query proxy id
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.#ctor">
            <summary>Constructs a new broad phase based on the dynamic tree implementation</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.TreeQuality">
            <summary>Get the tree quality based on the area of the tree.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.TreeHeight">
            <summary>Gets the height of the tree.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.NullProxy">
            <summary>
                The null proxy
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.ProxyCount">
            <summary>Get the number of proxies.</summary>
            <value>The proxy count.</value>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.AddProxy(Alis.Core.Physic.Dynamics.FixtureProxy@)">
            <summary>Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs is called.</summary>
            <param name="proxy">The user data.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.RemoveProxy(System.Int32)">
            <summary>Destroy a proxy. It is up to the client to remove any pairs.</summary>
            <param name="proxyId">The proxy id.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.MoveProxy(System.Int32,Alis.Core.Physic.Shared.Aabb@,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Call MoveProxy as many times as you like, then when you are done call UpdatePairs to finalized the proxy pairs
                (for your time step).
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.TouchProxy(System.Int32)">
            <summary>Call to trigger a re-processing of it's pairs on the next call to UpdatePairs.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.GetFatAabb(System.Int32,Alis.Core.Physic.Shared.Aabb@)">
            <summary>Get the AABB for a proxy.</summary>
            <param name="proxyId">The proxy id.</param>
            <param name="aabb">The AABB.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.GetProxy(System.Int32)">
            <summary>Get user data from a proxy. Returns null if the id is invalid.</summary>
            <param name="proxyId">The proxy id.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.TestOverlap(System.Int32,System.Int32)">
            <summary>Test overlap of fat AABBs.</summary>
            <param name="proxyIdA">The proxy id A.</param>
            <param name="proxyIdB">The proxy id B.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.UpdatePairs(Alis.Core.Physic.Collision.Handlers.BroadphaseHandler)">
            <summary>Update the pairs. This results in pair callbacks. This can only add pairs.</summary>
            <param name="callback">The callback.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.Query(System.Func{System.Int32,System.Boolean},Alis.Core.Physic.Shared.Aabb@)">
            <summary>
                Query an AABB for overlapping proxies. The callback class is called for each proxy that overlaps the supplied
                AABB.
            </summary>
            <param name="callback">The callback.</param>
            <param name="aabb">The AABB.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.RayCast(System.Func{Alis.Core.Physic.Collision.RayCast.RayCastInput,System.Int32,System.Single},Alis.Core.Physic.Collision.RayCast.RayCastInput@)">
            <summary>
                Ray-cast against the proxies in the tree. This relies on the callback to perform a exact ray-cast in the case
                were the proxy contains a shape. The callback also performs the any collision filtering. This has performance
                roughly
                equal to k * log(n), where k is the number of collisions and n is the number of proxies in the tree.
            </summary>
            <param name="callback">A callback class that is called for each proxy that is hit by the ray.</param>
            <param name="input">The ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.ShiftOrigin(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Shift the world origin. Useful for large worlds.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.BufferMove(System.Int32)">
            <summary>
                Buffers the move using the specified proxy id
            </summary>
            <param name="proxyId">The proxy id</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.UnBufferMove(System.Int32)">
            <summary>
                Uns the buffer move using the specified proxy id
            </summary>
            <param name="proxyId">The proxy id</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.DynamicTreeBroadPhase.QueryCallback(System.Int32)">
            <summary>This is called from DynamicTree.Query when we are gathering pairs.</summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Broadphase.IBroadPhase">
            <summary>
                The broad phase interface
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Broadphase.IBroadPhase.ProxyCount">
            <summary>
                Gets the value of the proxy count
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.IBroadPhase.UpdatePairs(Alis.Core.Physic.Collision.Handlers.BroadphaseHandler)">
            <summary>
                Updates the pairs using the specified callback
            </summary>
            <param name="callback">The callback</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.IBroadPhase.TestOverlap(System.Int32,System.Int32)">
            <summary>
                Describes whether this instance test overlap
            </summary>
            <param name="proxyIdA">The proxy id</param>
            <param name="proxyIdB">The proxy id</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.IBroadPhase.AddProxy(Alis.Core.Physic.Dynamics.FixtureProxy@)">
            <summary>
                Adds the proxy using the specified proxy
            </summary>
            <param name="proxy">The proxy</param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.IBroadPhase.RemoveProxy(System.Int32)">
            <summary>
                Removes the proxy using the specified proxy id
            </summary>
            <param name="proxyId">The proxy id</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.IBroadPhase.MoveProxy(System.Int32,Alis.Core.Physic.Shared.Aabb@,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Moves the proxy using the specified proxy id
            </summary>
            <param name="proxyId">The proxy id</param>
            <param name="aabb">The aabb</param>
            <param name="displacement">The displacement</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.IBroadPhase.GetProxy(System.Int32)">
            <summary>
                Gets the proxy using the specified proxy id
            </summary>
            <param name="proxyId">The proxy id</param>
            <returns>The fixture proxy</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.IBroadPhase.TouchProxy(System.Int32)">
            <summary>
                Touches the proxy using the specified proxy id
            </summary>
            <param name="proxyId">The proxy id</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.IBroadPhase.GetFatAabb(System.Int32,Alis.Core.Physic.Shared.Aabb@)">
            <summary>
                Gets the fat aabb using the specified proxy id
            </summary>
            <param name="proxyId">The proxy id</param>
            <param name="aabb">The aabb</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.IBroadPhase.Query(System.Func{System.Int32,System.Boolean},Alis.Core.Physic.Shared.Aabb@)">
            <summary>
                Queries the callback
            </summary>
            <param name="callback">The callback</param>
            <param name="aabb">The aabb</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.IBroadPhase.RayCast(System.Func{Alis.Core.Physic.Collision.RayCast.RayCastInput,System.Int32,System.Single},Alis.Core.Physic.Collision.RayCast.RayCastInput@)">
            <summary>
                Rays the cast using the specified callback
            </summary>
            <param name="callback">The callback</param>
            <param name="input">The input</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.IBroadPhase.ShiftOrigin(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Shifts the origin using the specified new origin
            </summary>
            <param name="newOrigin">The new origin</param>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Broadphase.Pair">
            <summary>
                The pair
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.Pair.ProxyIdA">
            <summary>
                The proxy id
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.Pair.ProxyIdB">
            <summary>
                The proxy id
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Broadphase.TreeNode`1">
            <summary>A node in the dynamic tree. The client does not interact with this directly.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.TreeNode`1.Aabb">
            <summary>Enlarged AABB</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.TreeNode`1.Child1">
            <summary>
                The child
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.TreeNode`1.Child2">
            <summary>
                The child
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.TreeNode`1.Height">
            <summary>
                The height
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.TreeNode`1.Moved">
            <summary>
                The moved
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.TreeNode`1.ParentOrNext">
            <summary>
                The parent or next
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Broadphase.TreeNode`1.UserData">
            <summary>
                The user data
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Broadphase.TreeNode`1.IsLeaf">
            <summary>
                Describes whether this instance is leaf
            </summary>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Collision.ContactSystem.Contact">
            <summary>
                The class manages contact between two shapes. A contact exists for each overlapping AABB in the broad-phase
                (except if filtered). Therefore a contact object may exist that has no contact points.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.Contact.fixtureA">
            <summary>
                The fixture
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.Contact.fixtureB">
            <summary>
                The fixture
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.Contact.friction">
            <summary>
                The friction
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.Contact.indexA">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.Contact.indexB">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.Contact.manifold">
            <summary>
                The manifold
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.Contact.next">
            <summary>
                The next
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.Contact.prev">
            <summary>
                The prev
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.Contact.restitution">
            <summary>
                The restitution
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.Contact.restitutionThreshold">
            <summary>
                The restitution threshold
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.Contact.tangentSpeed">
            <summary>
                The tangent speed
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.Contact.type">
            <summary>
                The type
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.Contact.#ctor(Alis.Core.Physic.Dynamics.Fixture,System.Int32,Alis.Core.Physic.Dynamics.Fixture,System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.ContactSystem.Contact" /> class
            </summary>
            <param name="fA">The </param>
            <param name="indexA">The index</param>
            <param name="fB">The </param>
            <param name="indexB">The index</param>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.Flags">
            <summary>
                The flags
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.NodeA">
            <summary>
                The contact edge
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.NodeB">
            <summary>
                The contact edge
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.Toi">
            <summary>
                The toi
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.ToiCount">
            <summary>
                The toi count
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.Manifold">
            <summary>Get the contact manifold. Do not modify the manifold unless you understand the internals of Box2D.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.Friction">
            <summary>
                Gets or sets the value of the friction
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.Restitution">
            <summary>
                Gets or sets the value of the restitution
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.RestitutionThreshold">
            <summary>
                Gets or sets the value of the restitution threshold
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.TangentSpeed">
            <summary>Get or set the desired tangent speed for a conveyor belt behavior. In meters per second.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.FixtureA">
            <summary>
                Gets the value of the fixture a
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.FixtureB">
            <summary>
                Gets the value of the fixture b
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.ChildIndexA">
            <summary>Get the child primitive index for fixture A.</summary>
            <value>The child index A.</value>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.ChildIndexB">
            <summary>Get the child primitive index for fixture B.</summary>
            <value>The child index B.</value>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.Enabled">
            <summary>
                Enable/disable this contact.The contact is only disabled for the current time step (or sub-step in continuous
                collisions).
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.Next">
            <summary>
                Gets the value of the next
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.Previous">
            <summary>
                Gets the value of the previous
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.IsTouching">
            <summary>
                Gets the value of the is touching
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.IslandFlag">
            <summary>
                Gets the value of the island flag
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.ToiFlag">
            <summary>
                Gets the value of the toi flag
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.Contact.FilterFlag">
            <summary>
                Gets the value of the filter flag
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.Contact.Edge">
            <summary>
                The edge shape
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.Contact.Registers">
            <summary>
                The not supported
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.Contact.ResetRestitution">
            <summary>
                Resets the restitution
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.Contact.ResetRestitutionThreshold">
            <summary>
                Resets the restitution threshold
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.Contact.ResetFriction">
            <summary>
                Resets the friction
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.Contact.GetWorldManifold(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Physic.Shared.Optimization.FixedArray2{Alis.Core.Aspect.Math.Vector.Vector2F}@)">
            <summary>Gets the world manifold.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.Contact.Reset(Alis.Core.Physic.Dynamics.Fixture,System.Int32,Alis.Core.Physic.Dynamics.Fixture,System.Int32)">
            <summary>
                Resets the f a
            </summary>
            <param name="fA">The </param>
            <param name="indexA">The index</param>
            <param name="fB">The </param>
            <param name="indexB">The index</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.Contact.Update(Alis.Core.Physic.Collision.ContactSystem.ContactManager)">
            <summary>
                Update the contact manifold and touching status. Note: do not assume the fixture AABBs are overlapping or are
                valid.
            </summary>
            <param name="contactManager">The contact manager.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.Contact.Evaluate(Alis.Core.Physic.Collision.Narrowphase.Manifold@,Alis.Core.Aspect.Math.Transform@,Alis.Core.Aspect.Math.Transform@)">
            <summary>Evaluate this contact with your own manifold and transforms.</summary>
            <param name="manifold">The manifold.</param>
            <param name="transformA">The first transform.</param>
            <param name="transformB">The second transform.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.Contact.Create(Alis.Core.Physic.Dynamics.Fixture,System.Int32,Alis.Core.Physic.Dynamics.Fixture,System.Int32)">
            <summary>
                Creates the fixture a
            </summary>
            <param name="fixtureA">The fixture</param>
            <param name="indexA">The index</param>
            <param name="fixtureB">The fixture</param>
            <param name="indexB">The index</param>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.Contact.Destroy">
            <summary>
                Destroys this instance
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.ContactSystem.ContactEdge">
            <summary>
                A contact edge is used to connect bodies and contacts together in a contact graph where each body is a node
                and each contact is an edge. A contact edge belongs to a doubly linked list maintained in each attached body. Each
                contact has two contact nodes, one for each attached body.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactEdge.Contact">
            <summary>The contact</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactEdge.Next">
            <summary>The next contact edge in the body's contact list</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactEdge.Other">
            <summary>Provides quick access to the other body attached.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactEdge.Prev">
            <summary>The previous contact edge in the body's contact list</summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.ContactSystem.ContactFeature">
            <summary>The features that intersect to form the contact point This must be 4 bytes or less.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactFeature.IndexA">
            <summary>Feature index on ShapeA</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactFeature.IndexB">
            <summary>Feature index on ShapeB</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactFeature.TypeA">
            <summary>The feature type on ShapeA</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactFeature.TypeB">
            <summary>The feature type on ShapeB</summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.ContactSystem.ContactFeatureType">
            <summary>
                The contact feature type enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactFeatureType.Vertex">
            <summary>
                The vertex contact feature type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactFeatureType.Face">
            <summary>
                The face contact feature type
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.ContactSystem.ContactFlags">
            <summary>
                The contact flags enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactFlags.Unknown">
            <summary>
                The unknown contact flags
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactFlags.IslandFlag">
            <summary>Used when crawling contact graph when forming islands.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactFlags.TouchingFlag">
            <summary>Set when the shapes are touching.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactFlags.EnabledFlag">
            <summary>This contact can be disabled (by user)</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactFlags.FilterFlag">
            <summary>This contact needs filtering because a fixture filter was changed.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactFlags.BulletHitFlag">
            <summary>This bullet contact had a TOI event</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactFlags.ToiFlag">
            <summary>This contact has a valid TOI in m_toi</summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.ContactSystem.ContactId">
            <summary>Contact ids to facilitate warm starting.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactId.ContactFeature">
            <summary>The features that intersect to form the contact point</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactId.Key">
            <summary>Used to quickly compare contact ids.</summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.ContactSystem.ContactManager">
            <summary>
                The contact manager class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactManager.BeginContact">
            <summary>Fires when a contact is created</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactManager.ContactCounter">
            <summary>
                The contact count
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactManager.ContactFilter">
            <summary>The filter used by the contact manager.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactManager.ContactList">
            <summary>
                The contact list
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactManager.EndContact">
            <summary>Fires when a contact is deleted</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactManager.OnBroadphaseCollision">
            <summary>Fires when the broadphase detects that two Fixtures are close to each other.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactManager.PostSolve">
            <summary>Fires after the solver has run</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactManager.PreSolve">
            <summary>Fires before the solver runs</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.ContactManager.#ctor(Alis.Core.Physic.Collision.Broadphase.IBroadPhase)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.ContactSystem.ContactManager" /> class
            </summary>
            <param name="broadPhase">The broad phase</param>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.ContactManager.BroadPhase">
            <summary>
                Gets the value of the broad phase
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.ContactSystem.ContactManager.ContactCount">
            <summary>
                Gets the value of the contact count
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.ContactManager.AddPair(Alis.Core.Physic.Dynamics.FixtureProxy@,Alis.Core.Physic.Dynamics.FixtureProxy@)">
            <summary>
                Adds the pair using the specified proxy a
            </summary>
            <param name="proxyA">The proxy</param>
            <param name="proxyB">The proxy</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.ContactManager.FindNewContacts">
            <summary>
                Finds the new contacts
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.ContactManager.Remove(Alis.Core.Physic.Collision.ContactSystem.Contact)">
            <summary>
                Removes the c
            </summary>
            <param name="c">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.ContactManager.Collide">
            <summary>
                This is the top level collision call for the time step. Here all the narrow phase collision is processed for the
                world contact list.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.ContactSystem.ContactManager.ShouldCollide(Alis.Core.Physic.Dynamics.Fixture,Alis.Core.Physic.Dynamics.Fixture)">
            <summary>
                Describes whether should collide
            </summary>
            <param name="fixtureA">The fixture</param>
            <param name="fixtureB">The fixture</param>
            <returns>The collide</returns>
        </member>
        <member name="T:Alis.Core.Physic.Collision.ContactSystem.ContactType">
            <summary>
                The contact type enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactType.NotSupported">
            <summary>
                The not supported contact type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactType.Polygon">
            <summary>
                The polygon contact type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactType.PolygonAndCircle">
            <summary>
                The polygon and circle contact type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactType.Circle">
            <summary>
                The circle contact type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactType.EdgeAndPolygon">
            <summary>
                The edge and polygon contact type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactType.EdgeAndCircle">
            <summary>
                The edge and circle contact type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactType.ChainAndPolygon">
            <summary>
                The chain and polygon contact type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.ContactSystem.ContactType.ChainAndCircle">
            <summary>
                The chain and circle contact type
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Distance.DistanceGjk">
            <summary>
                The Gilbert–Johnson–Keerthi distance algorithm that provides the distance between shapes. Using Voronoi
                regions (Christer Ericson) and Barycentric coordinates.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.DistanceGjk.GjkCalls">
            <summary>
                The number of calls made to the ComputeDistance() function. Note: This is only activated when
                Settings.EnableDiagnostics = true
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.DistanceGjk.GjkIters">
            <summary>
                The number of iterations that was made on the last call to ComputeDistance(). Note: This is only activated
                when Settings.EnableDiagnostics = true
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.DistanceGjk.GjkMaxIters">
            <summary>
                The maximum number of iterations calls to the CompteDistance() function. Note: This is only activated when
                Settings.EnableDiagnostics = true
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Distance.DistanceGjk.ComputeDistance(Alis.Core.Physic.Collision.Distance.DistanceInput@,Alis.Core.Physic.Collision.Distance.DistanceOutput@,Alis.Core.Physic.Collision.Narrowphase.SimplexCache@)">
            <summary>
                Computes the distance using the specified input
            </summary>
            <param name="input">The input</param>
            <param name="output">The output</param>
            <param name="cache">The cache</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Distance.DistanceGjk.ShapeCast(Alis.Core.Physic.Collision.Distance.ShapeCastInput@,Alis.Core.Physic.Collision.Distance.ShapeCastOutput@)">
            <summary>
                Perform a linear shape cast of shape B moving and shape A fixed. Determines the hit point, normal, and
                translation fraction.
            </summary>
            <returns>true if hit, false if there is no hit or an initial overlap</returns>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Distance.DistanceInput">
            <summary>Input for Distance.ComputeDistance(). You have to option to use the shape radii in the computation.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.DistanceInput.ProxyA">
            <summary>
                The proxy
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.DistanceInput.ProxyB">
            <summary>
                The proxy
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.DistanceInput.TransformA">
            <summary>
                The transform
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.DistanceInput.TransformB">
            <summary>
                The transform
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.DistanceInput.UseRadii">
            <summary>
                The use radii
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Distance.DistanceOutput">
            <summary>Output for Distance.ComputeDistance().</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.DistanceOutput.Distance">
            <summary>
                The distance
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.DistanceOutput.Iterations">
            <summary>Number of GJK iterations used</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.DistanceOutput.PointA">
            <summary>Closest point on shapeA</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.DistanceOutput.PointB">
            <summary>Closest point on shapeB</summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Distance.DistanceProxy">
            <summary>A distance proxy is used by the GJK algorithm. It encapsulates any shape.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.DistanceProxy.Radius">
            <summary>
                The radius
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.DistanceProxy.Vertices">
            <summary>
                The vertices
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Distance.DistanceProxy.#ctor(Alis.Core.Physic.Collision.Shapes.Shape,System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.Distance.DistanceProxy" /> class
            </summary>
            <param name="shape">The shape</param>
            <param name="index">The index</param>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Distance.DistanceProxy.#ctor(Alis.Core.Aspect.Math.Vector.Vector2F[],System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.Distance.DistanceProxy" /> class
            </summary>
            <param name="vertices">The vertices</param>
            <param name="radius">The radius</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Distance.DistanceProxy.GetSupport(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Get the supporting vertex index in the given direction.</summary>
            <param name="direction">The direction.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Distance.DistanceProxy.GetVertex(System.Int32)">
            <summary>
                Gets the vertex using the specified index
            </summary>
            <param name="index">The index</param>
            <returns>The vector</returns>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Distance.ShapeCastInput">
            <summary>Input parameters for b2ShapeCast</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.ShapeCastInput.ProxyA">
            <summary>
                The proxy
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.ShapeCastInput.ProxyB">
            <summary>
                The proxy
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.ShapeCastInput.TransformA">
            <summary>
                The transform
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.ShapeCastInput.TransformB">
            <summary>
                The transform
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.ShapeCastInput.TranslationB">
            <summary>
                The translation
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Distance.ShapeCastOutput">
            <summary>Output results for b2ShapeCast</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.ShapeCastOutput.Point">
            <summary>
                The point
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.ShapeCastOutput.Normal">
            <summary>
                The normal
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.ShapeCastOutput.Lambda">
            <summary>
                The lambda
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Distance.ShapeCastOutput.Iterations">
            <summary>
                The iterations
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Filtering.Category">
            <summary>
                The category enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.None">
            <summary>
                The none category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.All">
            <summary>
                The all category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat1">
            <summary>
                The cat category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat2">
            <summary>
                The cat category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat3">
            <summary>
                The cat category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat4">
            <summary>
                The cat category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat5">
            <summary>
                The cat category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat6">
            <summary>
                The cat category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat7">
            <summary>
                The cat category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat8">
            <summary>
                The cat category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat9">
            <summary>
                The cat category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat10">
            <summary>
                The cat 10 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat11">
            <summary>
                The cat 11 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat12">
            <summary>
                The cat 12 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat13">
            <summary>
                The cat 13 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat14">
            <summary>
                The cat 14 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat15">
            <summary>
                The cat 15 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat16">
            <summary>
                The cat 16 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat17">
            <summary>
                The cat 17 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat18">
            <summary>
                The cat 18 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat19">
            <summary>
                The cat 19 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat20">
            <summary>
                The cat 20 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat21">
            <summary>
                The cat 21 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat22">
            <summary>
                The cat 22 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat23">
            <summary>
                The cat 23 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat24">
            <summary>
                The cat 24 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat25">
            <summary>
                The cat 25 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat26">
            <summary>
                The cat 26 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat27">
            <summary>
                The cat 27 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat28">
            <summary>
                The cat 28 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat29">
            <summary>
                The cat 29 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat30">
            <summary>
                The cat 30 category
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Filtering.Category.Cat31">
            <summary>
                The cat 31 category
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Filtering.Filter">
            <summary>
                The filter class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Filtering.Filter.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.Filtering.Filter" /> class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Filtering.Filter.#ctor(System.Int16,Alis.Core.Physic.Collision.Filtering.Category,Alis.Core.Physic.Collision.Filtering.Category)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.Filtering.Filter" /> class
            </summary>
            <param name="group">The group</param>
            <param name="category">The category</param>
            <param name="mask">The mask</param>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Filtering.Filter.Group">
            <summary>
                Collision groups allow a certain group of objects to never collide(negative) or always collide (positive).
                Zero means no collision group. Non-zero group filtering always wins against the mask bits.
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Filtering.Filter.Category">
            <summary>The collision category bits. Normally you would just set one bit.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Filtering.Filter.CategoryMask">
            <summary>The collision mask bits. This states the categories that this shape would accept for collision.</summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Handlers.AfterCollisionHandler">
            <summary>
                The after collision handler
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Handlers.BeforeCollisionHandler">
            <summary>
                The before collision handler
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Handlers.BeginContactHandler">
            <summary>This delegate is called when a contact is created</summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Handlers.BroadphaseHandler">
            <summary>
                The broadphase handler
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Handlers.CollisionFilterHandler">
            <summary>
                The collision filter handler
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Handlers.EndContactHandler">
            <summary>This delegate is called when a contact is deleted</summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Handlers.OnCollisionHandler">
            <summary>
                The on collision handler
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Handlers.OnSeparationHandler">
            <summary>
                The on separation handler
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.ClipVertex">
            <summary>Used for computing contact manifolds.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ClipVertex.Id">
            <summary>
                The id
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ClipVertex.V">
            <summary>
                The
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.CollideCircle">
            <summary>
                The collide circle class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.CollideCircle.CollideCircles(Alis.Core.Physic.Collision.Narrowphase.Manifold@,Alis.Core.Physic.Collision.Shapes.CircleShape,Alis.Core.Aspect.Math.Transform@,Alis.Core.Physic.Collision.Shapes.CircleShape,Alis.Core.Aspect.Math.Transform@)">
            <summary>Compute the collision manifold between two circles.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.CollideCircle.CollidePolygonAndCircle(Alis.Core.Physic.Collision.Narrowphase.Manifold@,Alis.Core.Physic.Collision.Shapes.PolygonShape,Alis.Core.Aspect.Math.Transform@,Alis.Core.Physic.Collision.Shapes.CircleShape,Alis.Core.Aspect.Math.Transform@)">
            <summary>Compute the collision manifold between a polygon and a circle.</summary>
            <param name="manifold">The manifold.</param>
            <param name="polygonA">The polygon A.</param>
            <param name="xfA">The transform of A.</param>
            <param name="circleB">The circle B.</param>
            <param name="xfB">The transform of B.</param>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.CollideEdge">
            <summary>
                The collide edge class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.CollideEdge.CollideEdgeAndCircle(Alis.Core.Physic.Collision.Narrowphase.Manifold@,Alis.Core.Physic.Collision.Shapes.EdgeShape,Alis.Core.Aspect.Math.Transform@,Alis.Core.Physic.Collision.Shapes.CircleShape,Alis.Core.Aspect.Math.Transform@)">
            <summary>Compute contact points for edge versus circle. This accounts for edge connectivity.</summary>
            <param name="manifold">The manifold.</param>
            <param name="edgeA">The edge A.</param>
            <param name="transformA">The transform A.</param>
            <param name="circleB">The circle B.</param>
            <param name="transformB">The transform B.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.CollideEdge.CollideEdgeAndPolygon(Alis.Core.Physic.Collision.Narrowphase.Manifold@,Alis.Core.Physic.Collision.Shapes.EdgeShape,Alis.Core.Aspect.Math.Transform@,Alis.Core.Physic.Collision.Shapes.PolygonShape,Alis.Core.Aspect.Math.Transform@)">
            <summary>
                Collides the edge and polygon using the specified manifold
            </summary>
            <param name="manifold">The manifold</param>
            <param name="edgeA">The edge</param>
            <param name="xfA">The xf</param>
            <param name="polygonB">The polygon</param>
            <param name="xfB">The xf</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.CollideEdge.ComputeEdgeSeparation(Alis.Core.Physic.Collision.Narrowphase.CollideEdge.TempPolygon@,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Computes the edge separation using the specified polygon b
            </summary>
            <param name="polygonB">The polygon</param>
            <param name="v1">The </param>
            <param name="normal1">The normal</param>
            <returns>The axis</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.CollideEdge.ComputePolygonSeparation(Alis.Core.Physic.Collision.Narrowphase.CollideEdge.TempPolygon@,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Computes the polygon separation using the specified polygon b
            </summary>
            <param name="polygonB">The polygon</param>
            <param name="v1">The </param>
            <param name="v2">The </param>
            <returns>The axis</returns>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.CollideEdge.TempPolygon">
            <summary>
                The temp polygon
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.CollideEdge.TempPolygon.#ctor(System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.Narrowphase.CollideEdge.TempPolygon" /> class
            </summary>
            <param name="count">The count</param>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.CollideEdge.TempPolygon.Vertices">
            <summary>
                The vertices
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.CollideEdge.TempPolygon.Normals">
            <summary>
                The normals
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.CollideEdge.TempPolygon.Count">
            <summary>
                The count
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.CollidePolygon">
            <summary>
                The collide polygon class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.CollidePolygon.CollidePolygons(Alis.Core.Physic.Collision.Narrowphase.Manifold@,Alis.Core.Physic.Collision.Shapes.PolygonShape,Alis.Core.Aspect.Math.Transform@,Alis.Core.Physic.Collision.Shapes.PolygonShape,Alis.Core.Aspect.Math.Transform@)">
            <summary>Compute the collision manifold between two polygons.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.CollidePolygon.FindMaxSeparation(System.Int32@,Alis.Core.Physic.Collision.Shapes.PolygonShape,Alis.Core.Aspect.Math.Transform@,Alis.Core.Physic.Collision.Shapes.PolygonShape,Alis.Core.Aspect.Math.Transform@)">
            <summary>Find the max separation between poly1 and poly2 using edge normals from poly1.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.CollidePolygon.FindIncidentEdge(Alis.Core.Physic.Shared.Optimization.FixedArray2{Alis.Core.Physic.Collision.Narrowphase.ClipVertex}@,Alis.Core.Physic.Collision.Shapes.PolygonShape,Alis.Core.Aspect.Math.Transform@,System.Int32,Alis.Core.Physic.Collision.Shapes.PolygonShape,Alis.Core.Aspect.Math.Transform@)">
            <summary>
                Finds the incident edge using the specified c
            </summary>
            <param name="c">The </param>
            <param name="poly1">The poly</param>
            <param name="xf1">The xf</param>
            <param name="edge1">The edge</param>
            <param name="poly2">The poly</param>
            <param name="xf2">The xf</param>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.Collision">
            <summary>Collision methods</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.Collision.TestOverlap(Alis.Core.Physic.Collision.Shapes.Shape,System.Int32,Alis.Core.Physic.Collision.Shapes.Shape,System.Int32,Alis.Core.Aspect.Math.Transform@,Alis.Core.Aspect.Math.Transform@)">
            <summary>Test overlap between the two shapes.</summary>
            <param name="shapeA">The first shape.</param>
            <param name="indexA">The index for the first shape.</param>
            <param name="shapeB">The second shape.</param>
            <param name="indexB">The index for the second shape.</param>
            <param name="xfA">The transform for the first shape.</param>
            <param name="xfB">The transform for the seconds shape.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.Collision.GetPointStates(Alis.Core.Physic.Shared.Optimization.FixedArray2{Alis.Core.Physic.Collision.Narrowphase.PointState}@,Alis.Core.Physic.Shared.Optimization.FixedArray2{Alis.Core.Physic.Collision.Narrowphase.PointState}@,Alis.Core.Physic.Collision.Narrowphase.Manifold@,Alis.Core.Physic.Collision.Narrowphase.Manifold@)">
            <summary>
                Gets the point states using the specified state 1
            </summary>
            <param name="state1">The state</param>
            <param name="state2">The state</param>
            <param name="manifold1">The manifold</param>
            <param name="manifold2">The manifold</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.Collision.ClipSegmentToLine(Alis.Core.Physic.Shared.Optimization.FixedArray2{Alis.Core.Physic.Collision.Narrowphase.ClipVertex}@,Alis.Core.Physic.Shared.Optimization.FixedArray2{Alis.Core.Physic.Collision.Narrowphase.ClipVertex}@,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,System.Int32)">
            <summary>Clipping for contact manifolds.</summary>
            <param name="vOut">The v out.</param>
            <param name="vIn">The v in.</param>
            <param name="normal">The normal.</param>
            <param name="offset">The offset.</param>
            <param name="vertexIndexA">The vertex index A.</param>
            <returns></returns>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.EpAxis">
            <summary>This structure is used to keep track of the best separating axis.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.EpAxis.Normal">
            <summary>
                The normal
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.EpAxis.Index">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.EpAxis.Separation">
            <summary>
                The separation
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.EpAxis.Type">
            <summary>
                The type
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.EpAxisType">
            <summary>
                The ep axis type enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.EpAxisType.Unknown">
            <summary>
                The unknown ep axis type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.EpAxisType.EdgeA">
            <summary>
                The edge ep axis type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.EpAxisType.EdgeB">
            <summary>
                The edge ep axis type
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.Manifold">
            <summary>
                A manifold for two touching convex Shapes.
                Box2D supports multiple types of contact:
                - Clip point versus plane with radius
                - Point versus point with radius (circles)
                The local point usage depends on the manifold type:
                - ShapeType.Circles: the local center of circleA
                - SeparationFunction.FaceA: the center of faceA
                - SeparationFunction.FaceB: the center of faceB
                Similarly the local normal usage:
                - ShapeType.Circles: not used
                - SeparationFunction.FaceA: the normal on polygonA
                - SeparationFunction.FaceB: the normal on polygonB
                We store contacts in this way so that position correction can
                account for movement, which is critical for continuous physics.
                All contact scenarios must be expressed in one of these types.
                This structure is stored across time steps, so we keep it small.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.Manifold.LocalNormal">
            <summary>Not use for Type.SeparationFunction.Points</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.Manifold.LocalPoint">
            <summary>Usage depends on manifold type</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.Manifold.PointCount">
            <summary>The number of manifold points</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.Manifold.Points">
            <summary>The points of contact</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.Manifold.Type">
            <summary>
                The type
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.ManifoldPoint">
            <summary>
                A manifold point is a contact point belonging to a contact
                manifold. It holds details related to the geometry and dynamics
                of the contact points.
                The local point usage depends on the manifold type:
                -ShapeType.Circles: the local center of circleB
                -SeparationFunction.FaceA: the local center of cirlceB or the clip point of polygonB
                -SeparationFunction.FaceB: the clip point of polygonA
                This structure is stored across time steps, so we keep it small.
                Note: the impulses are used for internal caching and may not
                provide reliable contact forces, especially for high speed collisions.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ManifoldPoint.Id">
            <summary>Uniquely identifies a contact point between two Shapes</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ManifoldPoint.LocalPoint">
            <summary>Usage depends on manifold type</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ManifoldPoint.NormalImpulse">
            <summary>The non-penetration impulse</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ManifoldPoint.TangentImpulse">
            <summary>The friction impulse</summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.ManifoldType">
            <summary>
                The manifold type enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ManifoldType.Circles">
            <summary>
                The circles manifold type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ManifoldType.FaceA">
            <summary>
                The face manifold type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ManifoldType.FaceB">
            <summary>
                The face manifold type
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.PointState">
            <summary>This is used for determining the state of contact points.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.PointState.Null">
            <summary>Point does not exist</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.PointState.Add">
            <summary>Point was added in the update</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.PointState.Persist">
            <summary>Point persisted across the update</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.PointState.Remove">
            <summary>Point was removed in the update</summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.ReferenceFace">
            <summary>Reference face used for clipping</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ReferenceFace.I1">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ReferenceFace.I2">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ReferenceFace.V1">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ReferenceFace.V2">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ReferenceFace.Normal">
            <summary>
                The normal
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ReferenceFace.SideNormal1">
            <summary>
                The side normal
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ReferenceFace.SideOffset1">
            <summary>
                The side offset
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ReferenceFace.SideNormal2">
            <summary>
                The side normal
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.ReferenceFace.SideOffset2">
            <summary>
                The side offset
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.Simplex">
            <summary>
                The simplex
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.Simplex.Count">
            <summary>
                The count
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.Simplex.V">
            <summary>
                The
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.Simplex.ReadCache(Alis.Core.Physic.Collision.Narrowphase.SimplexCache@,Alis.Core.Physic.Collision.Distance.DistanceProxy@,Alis.Core.Aspect.Math.Transform@,Alis.Core.Physic.Collision.Distance.DistanceProxy@,Alis.Core.Aspect.Math.Transform@)">
            <summary>
                Reads the cache using the specified cache
            </summary>
            <param name="cache">The cache</param>
            <param name="proxyA">The proxy</param>
            <param name="transformA">The transform</param>
            <param name="proxyB">The proxy</param>
            <param name="transformB">The transform</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.Simplex.WriteCache(Alis.Core.Physic.Collision.Narrowphase.SimplexCache@)">
            <summary>
                Writes the cache using the specified cache
            </summary>
            <param name="cache">The cache</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.Simplex.GetSearchDirection">
            <summary>
                Gets the search direction
            </summary>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.Simplex.GetClosestPoint">
            <summary>
                Gets the closest point
            </summary>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.Simplex.GetWitnessPoints(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Gets the witness points using the specified p a
            </summary>
            <param name="pA">The </param>
            <param name="pB">The </param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.Simplex.GetMetric">
            <summary>
                Gets the metric
            </summary>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.Simplex.Solve2">
            <summary>
                Solves the 2
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.Simplex.Solve3">
            <summary>
                Solves the 3
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.SimplexCache">
            <summary>Used to warm start ComputeDistance. Set count to zero on first call.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.SimplexCache.Count">
            <summary>Length or area</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.SimplexCache.IndexA">
            <summary>Vertices on shape A</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.SimplexCache.IndexB">
            <summary>Vertices on shape B</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.SimplexCache.Metric">
            <summary>
                The metric
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.SimplexVertex">
            <summary>
                The simplex vertex
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.SimplexVertex.A">
            <summary>Barycentric coordinate for closest point</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.SimplexVertex.IndexA">
            <summary>wA index</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.SimplexVertex.IndexB">
            <summary>wB index</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.SimplexVertex.W">
            <summary>wB - wA</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.SimplexVertex.Wa">
            <summary>Support point in proxyA</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Narrowphase.SimplexVertex.Wb">
            <summary>Support point in proxyB</summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Narrowphase.WorldManifold">
            <summary>
                The world manifold class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Narrowphase.WorldManifold.Initialize(Alis.Core.Physic.Collision.Narrowphase.Manifold@,Alis.Core.Aspect.Math.Transform@,System.Single,Alis.Core.Aspect.Math.Transform@,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Physic.Shared.Optimization.FixedArray2{Alis.Core.Aspect.Math.Vector.Vector2F}@,Alis.Core.Physic.Shared.Optimization.FixedArray2{System.Single}@)">
            <summary>
                Evaluate the manifold with supplied transforms. This assumes modest motion from the original state. This does
                not change the point count, impulses, etc. The radii must come from the Shapes that generated the manifold.
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.RayCast.RayCastInput">
            <summary>Ray-cast input data.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.RayCast.RayCastInput.Fraction">
            <summary>
                The ray extends from p1 to p1 + maxFraction * (p2 - p1). If you supply a max fraction of 1, the ray extends
                from p1 to p2. A max fraction of 0.5 makes the ray go from p1 and half way to p2.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.RayCast.RayCastInput.Point1">
            <summary>The starting point of the ray.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.RayCast.RayCastInput.Point2">
            <summary>The ending point of the ray.</summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.RayCast.RayCastOutput">
            <summary>Ray-cast output data.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.RayCast.RayCastOutput.Fraction">
            <summary>
                The ray hits at p1 + fraction * (p2 - p1), where p1 and p2 come from RayCastInput. Contains the actual
                fraction of the ray where it has the intersection point.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.RayCast.RayCastOutput.Normal">
            <summary>The normal of the face of the shape the ray has hit.</summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.RayCastHelper">
            <summary>
                The ray cast helper class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.RayCastHelper.RayCastEdge(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,System.Boolean,Alis.Core.Physic.Collision.RayCast.RayCastInput@,Alis.Core.Aspect.Math.Transform@,Alis.Core.Physic.Collision.RayCast.RayCastOutput@)">
            <summary>
                Describes whether ray cast edge
            </summary>
            <param name="start">The start</param>
            <param name="end">The end</param>
            <param name="oneSided">The one sided</param>
            <param name="input">The input</param>
            <param name="transform">The transform</param>
            <param name="output">The output</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.RayCastHelper.RayCastCircle(Alis.Core.Aspect.Math.Vector.Vector2F@,System.Single,Alis.Core.Physic.Collision.RayCast.RayCastInput@,Alis.Core.Aspect.Math.Transform@,Alis.Core.Physic.Collision.RayCast.RayCastOutput@)">
            <summary>
                Describes whether ray cast circle
            </summary>
            <param name="pos">The pos</param>
            <param name="radius">The radius</param>
            <param name="input">The input</param>
            <param name="transform">The transform</param>
            <param name="output">The output</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.RayCastHelper.RayCastPolygon(Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Collision.RayCast.RayCastInput@,Alis.Core.Aspect.Math.Transform@,Alis.Core.Physic.Collision.RayCast.RayCastOutput@)">
            <summary>
                Describes whether ray cast polygon
            </summary>
            <param name="vertices">The vertices</param>
            <param name="normals">The normals</param>
            <param name="input">The input</param>
            <param name="transform">The transform</param>
            <param name="output">The output</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Shapes.ChainShape">
            <summary>
                A chain shape is a free form sequence of line segments. The chain has one-sided collision, with the surface
                normal pointing to the right of the edge. This provides a counter-clockwise winding like the polygon shape.
                Connectivity information is used to create smooth collisions. Warning: the chain will not collide properly if there
                are
                self-intersections.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.ChainShape.nextVertex">
            <summary>
                The next vertex
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.ChainShape.prevVertex">
            <summary>
                The next vertex
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.ChainShape.vertices">
            <summary>
                The vertices
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.ChainShape.#ctor(Alis.Core.Physic.Shared.Vertices,System.Boolean)">
            <summary>Create a new ChainShape from the vertices.</summary>
            <param name="vertices">The vertices to use. Must contain 2 or more vertices.</param>
            <param name="createLoop">
                Set to true to create a closed loop. It connects the first vertex to the last, and
                automatically adjusts connectivity to create smooth collisions along the chain.
            </param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.ChainShape.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.Shapes.ChainShape" /> class
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.ChainShape.Vertices">
            <summary>The vertices. These are not owned/freed by the chain Shape.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.ChainShape.ChildCount">
            <summary>Edge count = vertex count - 1</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.ChainShape.PrevVertex">
            <summary>Establish connectivity to a vertex that precedes the first vertex. Don't call this for loops.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.ChainShape.NextVertex">
            <summary>Establish connectivity to a vertex that follows the last vertex. Don't call this for loops.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.ChainShape.GetChildEdge(Alis.Core.Physic.Collision.Shapes.EdgeShape,System.Int32)">
            <summary>
                Gets the child edge using the specified edge
            </summary>
            <param name="edge">The edge</param>
            <param name="index">The index</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.ChainShape.GetChildEdge(System.Int32)">
            <summary>
                Gets the child edge using the specified index
            </summary>
            <param name="index">The index</param>
            <returns>The edge shape</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.ChainShape.TestPoint(Alis.Core.Aspect.Math.Transform@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Describes whether this instance test point
            </summary>
            <param name="transform">The transform</param>
            <param name="point">The point</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.ChainShape.RayCast(Alis.Core.Physic.Collision.RayCast.RayCastInput@,Alis.Core.Aspect.Math.Transform@,System.Int32,Alis.Core.Physic.Collision.RayCast.RayCastOutput@)">
            <summary>
                Describes whether this instance ray cast
            </summary>
            <param name="input">The input</param>
            <param name="transform">The transform</param>
            <param name="childIndex">The child index</param>
            <param name="output">The output</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.ChainShape.ComputeAabb(Alis.Core.Aspect.Math.Transform@,System.Int32,Alis.Core.Physic.Shared.Aabb@)">
            <summary>
                Computes the aabb using the specified transform
            </summary>
            <param name="transform">The transform</param>
            <param name="childIndex">The child index</param>
            <param name="aabb">The aabb</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.ChainShape.ComputeProperties">
            <summary>
                Computes the properties
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.ChainShape.Clone">
            <summary>
                Clones this instance
            </summary>
            <returns>The clone</returns>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Shapes.CircleShape">
            <summary>A circle shape.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.CircleShape.Positionprivate">
            <summary>
                The position
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.CircleShape.#ctor(System.Single,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Create a new circle with the desired radius and density.</summary>
            <param name="radius">The radius of the circle.</param>
            <param name="density">The density of the circle.</param>
            <param name="position">Position of the shape</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.CircleShape.#ctor(System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.Shapes.CircleShape" /> class
            </summary>
            <param name="density">The density</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.CircleShape.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.Shapes.CircleShape" /> class
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.CircleShape.ChildCount">
            <summary>
                Gets the value of the child count
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.CircleShape.Position">
            <summary>Get or set the position of the circle</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.CircleShape.TestPoint(Alis.Core.Aspect.Math.Transform@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Describes whether this instance test point
            </summary>
            <param name="transform">The transform</param>
            <param name="point">The point</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.CircleShape.RayCast(Alis.Core.Physic.Collision.RayCast.RayCastInput@,Alis.Core.Aspect.Math.Transform@,System.Int32,Alis.Core.Physic.Collision.RayCast.RayCastOutput@)">
            <summary>
                Describes whether this instance ray cast
            </summary>
            <param name="input">The input</param>
            <param name="transform">The transform</param>
            <param name="childIndex">The child index</param>
            <param name="output">The output</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.CircleShape.ComputeAabb(Alis.Core.Aspect.Math.Transform@,System.Int32,Alis.Core.Physic.Shared.Aabb@)">
            <summary>
                Computes the aabb using the specified transform
            </summary>
            <param name="transform">The transform</param>
            <param name="childIndex">The child index</param>
            <param name="aabb">The aabb</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.CircleShape.ComputeProperties">
            <summary>
                Computes the properties
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.CircleShape.ComputeMass">
            <summary>
                Computes the mass
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.CircleShape.ComputeInertia">
            <summary>
                Computes the inertia
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.CircleShape.Clone">
            <summary>
                Clones this instance
            </summary>
            <returns>The clone</returns>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Shapes.EdgeShape">
            <summary>
                A line segment (edge) shape. These can be connected in chains or loops to other edge shapes. Edges created
                independently are two-sided and do no provide smooth movement across junctions.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.EdgeShape.oneSided">
            <summary>
                The one sided
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.EdgeShape.vertex0">
            <summary>
                The vertex
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.EdgeShape.vertex1">
            <summary>
                The vertex
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.EdgeShape.vertex2">
            <summary>
                The vertex
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.EdgeShape.vertex3">
            <summary>
                The vertex
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.EdgeShape.#ctor(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Create a new EdgeShape with the specified start and end. This edge supports two-sided collision.</summary>
            <param name="start">The start of the edge.</param>
            <param name="end">The end of the edge.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.EdgeShape.#ctor(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Create a new EdgeShape with ghost vertices for smooth collision. This edge only supports one-sided collision.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.EdgeShape.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.Shapes.EdgeShape" /> class
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.EdgeShape.ChildCount">
            <summary>
                Gets the value of the child count
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.EdgeShape.OneSided">
            <summary>Is true if the edge is connected to an adjacent vertex before vertex 1.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.EdgeShape.Vertex0">
            <summary>Optional adjacent vertices. These are used for smooth collision.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.EdgeShape.Vertex3">
            <summary>Optional adjacent vertices. These are used for smooth collision.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.EdgeShape.Vertex1">
            <summary>These are the edge vertices</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.EdgeShape.Vertex2">
            <summary>These are the edge vertices</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.EdgeShape.SetOneSided(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Sets the one sided using the specified v 0
            </summary>
            <param name="v0">The </param>
            <param name="v1">The </param>
            <param name="v2">The </param>
            <param name="v3">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.EdgeShape.SetTwoSided(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Sets the two sided using the specified start
            </summary>
            <param name="start">The start</param>
            <param name="end">The end</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.EdgeShape.TestPoint(Alis.Core.Aspect.Math.Transform@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Describes whether this instance test point
            </summary>
            <param name="transform">The transform</param>
            <param name="point">The point</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.EdgeShape.RayCast(Alis.Core.Physic.Collision.RayCast.RayCastInput@,Alis.Core.Aspect.Math.Transform@,System.Int32,Alis.Core.Physic.Collision.RayCast.RayCastOutput@)">
            <summary>
                Describes whether this instance ray cast
            </summary>
            <param name="input">The input</param>
            <param name="transform">The transform</param>
            <param name="childIndex">The child index</param>
            <param name="output">The output</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.EdgeShape.ComputeAabb(Alis.Core.Aspect.Math.Transform@,System.Int32,Alis.Core.Physic.Shared.Aabb@)">
            <summary>
                Computes the aabb using the specified transform
            </summary>
            <param name="transform">The transform</param>
            <param name="childIndex">The child index</param>
            <param name="aabb">The aabb</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.EdgeShape.ComputeProperties">
            <summary>
                Computes the properties
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.EdgeShape.Clone">
            <summary>
                Clones this instance
            </summary>
            <returns>The clone</returns>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Shapes.MassData">
            <summary>This holds the mass data computed for a shape.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.MassData.#ctor(System.Single,System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.Shapes.MassData" /> class
            </summary>
            <param name="area">The area</param>
            <param name="inertia">The inertia</param>
            <param name="mass">The mass</param>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.MassData.Area">
            <summary>The area of the shape</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.MassData.Centroid">
            <summary>The position of the shape's centroid relative to the shape's origin.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.MassData.Inertia">
            <summary>The rotational inertia of the shape about the local origin.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.MassData.Mass">
            <summary>The mass of the shape, usually in kilograms.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.MassData.op_Equality(Alis.Core.Physic.Collision.Shapes.MassData,Alis.Core.Physic.Collision.Shapes.MassData)">
            <summary>The equal operator</summary>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.MassData.op_Inequality(Alis.Core.Physic.Collision.Shapes.MassData,Alis.Core.Physic.Collision.Shapes.MassData)">
            <summary>The not equal operator</summary>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.MassData.Equals(Alis.Core.Physic.Collision.Shapes.MassData)">
            <summary>
                Describes whether this instance equals
            </summary>
            <param name="other">The other</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.MassData.Equals(System.Object)">
            <summary>
                Describes whether this instance equals
            </summary>
            <param name="obj">The obj</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.MassData.GetHashCode">
            <summary>
                Gets the hash code
            </summary>
            <returns>The int</returns>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Shapes.PolygonShape">
            <summary>Represents a simple non-self intersecting convex polygon. Create a convex hull from the given array of points.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.PolygonShape.NormalsPrivate">
            <summary>
                The normals
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.PolygonShape.VerticesPrivate">
            <summary>
                The vertices
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.PolygonShape.#ctor(Alis.Core.Physic.Shared.Vertices,System.Single)">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.Shapes.PolygonShape" /> class.</summary>
            <param name="vertices">The vertices.</param>
            <param name="density">The density.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.PolygonShape.#ctor(System.Single)">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.Shapes.PolygonShape" /> class.</summary>
            <param name="density">The density.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.PolygonShape.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.Shapes.PolygonShape" /> class
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.PolygonShape.Vertices">
            <summary>
                Create a convex hull from the given array of local points. The number of vertices must be in the range [3,
                Settings.MaxPolygonVertices]. Warning: the points may be re-ordered, even if they form a convex polygon Warning:
                collinear points are handled but not removed. Collinear points may lead to poor stacking behavior.
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.PolygonShape.Normals">
            <summary>
                Gets the value of the normals
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.PolygonShape.ChildCount">
            <summary>
                Gets the value of the child count
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.PolygonShape.SetVertices(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Sets the vertices using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <exception cref="T:System.InvalidOperationException">Polygon is degenerate</exception>
            <exception cref="T:System.InvalidOperationException">Polygon is degenerate</exception>
            <exception cref="T:System.InvalidOperationException">You can't create a polygon with less than 3 vertices</exception>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.PolygonShape.SetAsBox(System.Single,System.Single)">
            <summary>
                Sets the as box using the specified hx
            </summary>
            <param name="hx">The hx</param>
            <param name="hy">The hy</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.PolygonShape.SetAsBox(System.Single,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single)">
            <summary>
                Sets the as box using the specified hx
            </summary>
            <param name="hx">The hx</param>
            <param name="hy">The hy</param>
            <param name="center">The center</param>
            <param name="angle">The angle</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.PolygonShape.ComputeProperties">
            <summary>
                Computes the properties
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.PolygonShape.TestPoint(Alis.Core.Aspect.Math.Transform@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Describes whether this instance test point
            </summary>
            <param name="transform">The transform</param>
            <param name="point">The point</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.PolygonShape.RayCast(Alis.Core.Physic.Collision.RayCast.RayCastInput@,Alis.Core.Aspect.Math.Transform@,System.Int32,Alis.Core.Physic.Collision.RayCast.RayCastOutput@)">
            <summary>
                Describes whether this instance ray cast
            </summary>
            <param name="input">The input</param>
            <param name="transform">The transform</param>
            <param name="childIndex">The child index</param>
            <param name="output">The output</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.PolygonShape.ComputeAabb(Alis.Core.Aspect.Math.Transform@,System.Int32,Alis.Core.Physic.Shared.Aabb@)">
            <summary>Given a transform, compute the associated axis aligned bounding box for a child shape.</summary>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
            <param name="aabb">The AABB results.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.PolygonShape.Clone">
            <summary>
                Clones this instance
            </summary>
            <returns>The clone</returns>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Shapes.Shape">
            <summary>
                A shape is used for collision detection. You can create a shape however you like. Shapes used for simulation
                in World are created automatically when a Fixture is created. Shapes may encapsulate a one or more child shapes.
                A shape is 2D geometrical object, such as a circle or polygon.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.Shape.DensityPrivate">
            <summary>
                The density
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.Shape.MassDataPrivate">
            <summary>
                The mass data
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.Shape.RadiusPrivate">
            <summary>
                The radius
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.Shape.ShapeTypePrivate">
            <summary>
                The shape type
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.Shape.#ctor(Alis.Core.Physic.Collision.Shapes.ShapeType,System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Collision.Shapes.Shape" /> class
            </summary>
            <param name="type">The type</param>
            <param name="radius">The radius</param>
            <param name="density">The density</param>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.Shape.ShapeType">
            <summary>Get the type of this shape.</summary>
            <value>The type of the shape.</value>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.Shape.ChildCount">
            <summary>Get the number of child primitives.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.Shape.Radius">
            <summary>Radius of the Shape Changing the radius causes a recalculation of shape properties.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Collision.Shapes.Shape.Density">
            <summary>Gets or sets the density. Changing the density causes a recalculation of shape properties.</summary>
            <value>The density.</value>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.Shape.GetMassData(Alis.Core.Physic.Collision.Shapes.MassData@)">
            <summary>
                Contains the properties of the shape such as:
                - Area of the shape
                - Centroid
                - Inertia
                - Mass
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.Shape.Clone">
            <summary>Clone the concrete shape</summary>
            <returns>A clone of the shape</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.Shape.TestPoint(Alis.Core.Aspect.Math.Transform@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Test a point for containment in this shape. Note: This only works for convex shapes.</summary>
            <param name="transform">The shape world transform.</param>
            <param name="point">A point in world coordinates.</param>
            <returns>True if the point is inside the shape</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.Shape.RayCast(Alis.Core.Physic.Collision.RayCast.RayCastInput@,Alis.Core.Aspect.Math.Transform@,System.Int32,Alis.Core.Physic.Collision.RayCast.RayCastOutput@)">
            <summary>Cast a ray against a child shape.</summary>
            <param name="input">The ray-cast input parameters.</param>
            <param name="transform">The transform to be applied to the shape.</param>
            <param name="childIndex">The child shape index.</param>
            <param name="output">The ray-cast results.</param>
            <returns>True if the ray-cast hits the shape</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.Shape.ComputeAabb(Alis.Core.Aspect.Math.Transform@,System.Int32,Alis.Core.Physic.Shared.Aabb@)">
            <summary>Given a transform, compute the associated axis aligned bounding box for a child shape.</summary>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
            <param name="aabb">The AABB results.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.Shapes.Shape.ComputeProperties">
            <summary>
                Compute the mass properties of this shape using its dimensions and density. The inertia tensor is computed
                about the local origin, not the centroid.
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.Shapes.ShapeType">
            <summary>
                The shape type enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.ShapeType.Unknown">
            <summary>
                The unknown shape type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.ShapeType.Circle">
            <summary>
                The circle shape type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.ShapeType.Edge">
            <summary>
                The edge shape type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.ShapeType.Polygon">
            <summary>
                The polygon shape type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.ShapeType.Chain">
            <summary>
                The chain shape type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.Shapes.ShapeType.TypeCount">
            <summary>
                The type count shape type
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.TestPointHelper">
            <summary>
                The test point helper class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.TestPointHelper.TestPointCircle(Alis.Core.Aspect.Math.Vector.Vector2F@,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Transform@)">
            <summary>
                Describes whether test point circle
            </summary>
            <param name="pos">The pos</param>
            <param name="radius">The radius</param>
            <param name="point">The point</param>
            <param name="transform">The transform</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.TestPointHelper.TestPointPolygon(Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Transform@)">
            <summary>
                Describes whether test point polygon
            </summary>
            <param name="vertices">The vertices</param>
            <param name="normals">The normals</param>
            <param name="point">The point</param>
            <param name="transform">The transform</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Collision.TOI.SeparationFunction">
            <summary>
                The separation function class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.TOI.SeparationFunction.Initialize(Alis.Core.Physic.Collision.Narrowphase.SimplexCache@,Alis.Core.Physic.Collision.Distance.DistanceProxy,Alis.Core.Physic.Collision.TOI.Sweep@,Alis.Core.Physic.Collision.Distance.DistanceProxy,Alis.Core.Physic.Collision.TOI.Sweep@,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Physic.Collision.TOI.SeparationFunctionType@)">
            <summary>
                Initializes the cache
            </summary>
            <param name="cache">The cache</param>
            <param name="proxyA">The proxy</param>
            <param name="sweepA">The sweep</param>
            <param name="proxyB">The proxy</param>
            <param name="sweepB">The sweep</param>
            <param name="t1">The </param>
            <param name="axis">The axis</param>
            <param name="localPoint">The local point</param>
            <param name="type">The type</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.TOI.SeparationFunction.FindMinSeparation(System.Int32@,System.Int32@,System.Single,Alis.Core.Physic.Collision.Distance.DistanceProxy,Alis.Core.Physic.Collision.TOI.Sweep@,Alis.Core.Physic.Collision.Distance.DistanceProxy,Alis.Core.Physic.Collision.TOI.Sweep@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Physic.Collision.TOI.SeparationFunctionType)">
            <summary>
                Finds the min separation using the specified index a
            </summary>
            <param name="indexA">The index</param>
            <param name="indexB">The index</param>
            <param name="t">The </param>
            <param name="proxyA">The proxy</param>
            <param name="sweepA">The sweep</param>
            <param name="proxyB">The proxy</param>
            <param name="sweepB">The sweep</param>
            <param name="axis">The axis</param>
            <param name="localPoint">The local point</param>
            <param name="type">The type</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Collision.TOI.SeparationFunction.Evaluate(System.Int32,System.Int32,System.Single,Alis.Core.Physic.Collision.Distance.DistanceProxy,Alis.Core.Physic.Collision.TOI.Sweep@,Alis.Core.Physic.Collision.Distance.DistanceProxy,Alis.Core.Physic.Collision.TOI.Sweep@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Physic.Collision.TOI.SeparationFunctionType)">
            <summary>
                Evaluates the index a
            </summary>
            <param name="indexA">The index</param>
            <param name="indexB">The index</param>
            <param name="t">The </param>
            <param name="proxyA">The proxy</param>
            <param name="sweepA">The sweep</param>
            <param name="proxyB">The proxy</param>
            <param name="sweepB">The sweep</param>
            <param name="axis">The axis</param>
            <param name="localPoint">The local point</param>
            <param name="type">The type</param>
            <returns>The float</returns>
        </member>
        <member name="T:Alis.Core.Physic.Collision.TOI.SeparationFunctionType">
            <summary>
                The separation function type enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.SeparationFunctionType.Points">
            <summary>
                The points separation function type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.SeparationFunctionType.FaceA">
            <summary>
                The face separation function type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.SeparationFunctionType.FaceB">
            <summary>
                The face separation function type
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.TOI.Sweep">
            <summary>
                This describes the motion of a body/shape for TOI computation. Shapes are defined with respect to the body
                origin, which may no coincide with the center of mass. However, to support dynamics we must interpolate the center
                of
                mass position.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.Sweep.A">
            <summary>World angles</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.Sweep.A0">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.Sweep.Alpha0">
            <summary>Fraction of the current time step in the range [0,1] c0 and a0 are the positions at alpha0.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.Sweep.C">
            <summary>Center world positions</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.Sweep.C0">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.Sweep.LocalCenter">
            <summary>Local center of mass position</summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.TOI.Sweep.GetTransform(Alis.Core.Aspect.Math.Transform@,System.Single)">
            <summary>Get the interpolated transform at a specific time.</summary>
            <param name="xfb">The transform.</param>
            <param name="beta">beta is a factor in [0,1], where 0 indicates alpha0.</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.TOI.Sweep.Advance(System.Single)">
            <summary>Advance the sweep forward, yielding a new initial state.</summary>
            <param name="alpha">new initial time</param>
        </member>
        <member name="M:Alis.Core.Physic.Collision.TOI.Sweep.Normalize">
            <summary>Normalize the angles.</summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.TOI.TimeOfImpact">
            <summary>
                The time of impact class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.TimeOfImpact.ToiCalls">
            <summary>
                The toi max iters
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.TimeOfImpact.ToiIters">
            <summary>
                The toi max iters
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.TimeOfImpact.ToiMaxIters">
            <summary>
                The toi max iters
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.TimeOfImpact.ToiRootIters">
            <summary>
                The toi max root iters
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.TimeOfImpact.ToiMaxRootIters">
            <summary>
                The toi max root iters
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Collision.TOI.TimeOfImpact.CalculateTimeOfImpact(Alis.Core.Physic.Collision.TOI.ToiInput@,Alis.Core.Physic.Collision.TOI.ToiOutput@)">
            <summary>
                Compute the upper bound on time before two shapes penetrate. Time is represented as a fraction between
                [0,tMax]. This uses a swept separating axis and may miss some intermediate, non-tunneling collision. If you change
                the
                time interval, you should call this function again. Note: use Distance() to compute the contact point and normal at
                the
                time of impact.
            </summary>
            <param name="input">The input.</param>
            <param name="output">The output.</param>
        </member>
        <member name="T:Alis.Core.Physic.Collision.TOI.ToiInput">
            <summary>Input parameters for CalculateTimeOfImpact</summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.ToiInput.ProxyA">
            <summary>
                The proxy
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.ToiInput.ProxyB">
            <summary>
                The proxy
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.ToiInput.SweepA">
            <summary>
                The sweep
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.ToiInput.SweepB">
            <summary>
                The sweep
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.ToiInput.Max">
            <summary>
                The max
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.TOI.ToiOutput">
            <summary>
                The toi output
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.ToiOutput.State">
            <summary>
                The state
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.ToiOutput.T">
            <summary>
                The
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Collision.TOI.ToiOutputState">
            <summary>
                The toi output state enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.ToiOutputState.Unknown">
            <summary>
                The unknown toi output state
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.ToiOutputState.Failed">
            <summary>
                The failed toi output state
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.ToiOutputState.Overlapped">
            <summary>
                The overlapped toi output state
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.ToiOutputState.Touching">
            <summary>
                The touching toi output state
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Collision.TOI.ToiOutputState.Seperated">
            <summary>
                The seperated toi output state
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Config.Settings">
            <summary>
                The settings class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.ManifoldPoints">
            <summary>The maximum number of contact points between two convex shapes. DO NOT CHANGE THIS VALUE!</summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.EnableSubStepping">
            <summary>Enable or disable sub stepping. Used for debugging.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.BlockSolve">
            <summary>Enable or disable the block contact solver. Used for debugging.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.SkipSanityChecks">
            <summary>
                Set this to true to skip sanity checks in the engine. This will speed up the tools by removing the overhead of
                the checks, but you will need to handle checks yourself where it is needed.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.UseConvexHullPolygons">
            <summary>
                If true, it will run a GiftWrap convex hull on all polygon inputs. This makes for a more stable engine when
                given random input, but if speed of the creation of polygons are more important, you might want to set this to
                false.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.UseFpeCollisionCategories">
            <summary>
                Velcro Physics has a different way of filtering fixtures than Box2d. We have both FPE and Box2D filtering in
                the engine. If you are upgrading from earlier versions of FPE, set this to true and
                DefaultFixtureCollisionCategories
                to Category.All.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.DefaultFixtureCollisionCategories">
            <summary>
                This is used by the Fixture constructor as the default value for Fixture.CollisionCategories member. Note that
                you may need to change this depending on the setting of UseFPECollisionCategories, above.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.DefaultFixtureCollidesWith">
            <summary>This is used by the Fixture constructor as the default value for Fixture.CollidesWith member.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.DefaultFixtureIgnoreCcdWith">
            <summary>This is used by the Fixture constructor as the default value for Fixture.IgnoreCCDWith member.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.DefaultCollisionGroup">
            <summary>
                Set the default collision group
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.GjkIterations">
            <summary>Defines the maximum number of iterations made by the GJK algorithm.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.AabbExtension">
            <summary>
                This is used to fatten AABBs in the dynamic tree. This allows proxies to move by a small amount without
                triggering a tree adjustment. This is in meters.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.AabbMultiplier">
            <summary>
                This is used to fatten AABBs in the dynamic tree. This is used to predict the future position based on the
                current displacement. This is a dimensionless multiplier.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.LinearSlop">
            <summary>
                A small length used as a collision and constraint tolerance. Usually it is chosen to be numerically
                significant, but visually insignificant.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.AngularSlop">
            <summary>
                A small angle used as a collision and constraint tolerance. Usually it is chosen to be numerically
                significant, but visually insignificant.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.SubSteps">
            <summary>Maximum number of sub-steps per contact in continuous physics simulation.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.ToiContacts">
            <summary>Maximum number of contacts to be handled to solve a TOI impact.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.LinearCorrection">
            <summary>The maximum linear position correction used when solving constraints. This helps to prevent overshoot.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.AngularCorrection">
            <summary>The maximum angular position correction used when solving constraints. This helps to prevent overshoot.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.Translation">
            <summary>
                The maximum linear velocity of a body. This limit is very large and is used to prevent numerical problems. You
                shouldn't need to adjust this.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.Rotation">
            <summary>
                The maximum angular velocity of a body. This limit is very large and is used to prevent numerical problems.
                You shouldn't need to adjust this.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.Baumgarte">
            <summary>
                This scale factor controls how fast overlap is resolved. Ideally this would be 1 so that overlap is removed in
                one time step. However using values close to 1 often lead to overshoot.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.ToiBaumgarte">
            <summary>
                The toi baumgarte
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.TimeToSleep">
            <summary>The time that a body must be still before it will go to sleep.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.LinearSleepTolerance">
            <summary>A body cannot sleep if its linear velocity is above this tolerance.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.AngularSleepTolerance">
            <summary>A body cannot sleep if its angular velocity is above this tolerance.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.AutoClearForces">
            <summary>
                By default, forces are cleared automatically after each call to Step. The default behavior is modified with
                this setting. The purpose of this setting is to support sub-stepping. Sub-stepping is often used to maintain a
                fixed
                sized time step under a variable frame-rate. When you perform sub-stepping you should disable auto clearing of
                forces
                and instead call ClearForces after all sub-steps are complete in one pass of your game loop.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.PolygonVertices">
            <summary>The maximum number of vertices on a convex polygon.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.PolygonRadius">
            <summary>
                The radius of the polygon/edge shape skin. This should not be modified. Making this smaller means polygons
                will have an insufficient buffer for continuous collision. Making it larger may create artifacts for vertex
                collision.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.MixFriction">
            <summary>
                Gets called when there is a collision between 2 fixtures. The first two parameters are the friction values of
                either fixture. The return value should be the desired friction value of the collection.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.MixRestitution">
            <summary>
                Gets called when there is a collision between 2 fixtures. The first two parameters are the restitution values
                of either fixture. The return value should be the desired restitution value of the collection.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Config.Settings.MixRestitutionThreshold">
            <summary>
                The default mix restitution threshold
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Config.Settings.DefaultMixFriction(System.Single,System.Single)">
            <summary>
                Friction mixing law. The idea is to allow either fixture to drive the friction to zero. For example, anything
                slides on ice.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Config.Settings.DefaultMixRestitution(System.Single,System.Single)">
            <summary>
                Restitution mixing law. The idea is allow for anything to bounce off an inelastic surface. For example, a
                superball bounces on anything.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Config.Settings.DefaultMixRestitutionThreshold(System.Single,System.Single)">
            <summary>Restitution mixing law. This picks the lowest value.</summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Body">
            <summary>
                The body class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Body.angularVelocity">
            <summary>
                The angular velocity
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Body.inertia">
            <summary>
                The inertia
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Body.linearVelc">
            <summary>
                The linear velocity
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Body.mass">
            <summary>
                The mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Body.OnCollision">
            <summary>
                Fires when two shapes collide and a contact is created between them. Note that the first fixture argument is
                always the fixture that the delegate is subscribed to.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Body.OnSeparation">
            <summary>
                Fires when two shapes separate and a contact is removed between them. Note: This can in some cases be called
                multiple times, as a fixture can have multiple contacts. Note The first fixture argument is always the fixture that
                the
                delegate is subscribed to.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Body.Type">
            <summary>
                The type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Body.Xf">
            <summary>
                The xf
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.#ctor(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Physic.Dynamics.BodyType,System.Single,System.Single,System.Single,System.Single,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Body" /> class
            </summary>
            <param name="position">The position</param>
            <param name="linearVelocity">The linear velocity</param>
            <param name="bodyType">The body type</param>
            <param name="angle">The angle</param>
            <param name="angularVelocity">The angular velocity</param>
            <param name="linearDamping">The linear damping</param>
            <param name="angularDamping">The angular damping</param>
            <param name="allowSleep">The allow sleep</param>
            <param name="awake">The awake</param>
            <param name="fixedRotation">The fixed rotation</param>
            <param name="isBullet">The is bullet</param>
            <param name="enabled">The enabled</param>
            <param name="gravityScale">The gravity scale</param>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.Flags">
            <summary>
                The flags
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.Force">
            <summary>
                The force
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.InvI">
            <summary>
                The inv
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.InvMass">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.Sweep">
            <summary>
                The sweep
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.Torque">
            <summary>
                The torque
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.ControllerFilter">
            <summary>
                Gets or sets the value of the controller filter
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.PhysicsLogicFilter">
            <summary>
                Gets or sets the value of the physics logic filter
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.SleepTime">
            <summary>
                Gets or sets the value of the sleep time
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.IslandIndex">
            <summary>
                Gets or sets the value of the island index
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.GravityScale">
            <summary>
                Scale the gravity applied to this body. Defaults to 1. A value of 2 means double the gravity is applied to
                this body.
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.Revolutions">
            <summary>Gets the total number revolutions the body has made.</summary>
            <value>The revolutions.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.BodyType">
            <summary>Gets or sets the body type. Warning: Calling this mid-update might cause a crash.</summary>
            <value>The type of body.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.LinearVelocity">
            <summary>Get or sets the linear velocity of the center of mass.</summary>
            <value>The linear velocity.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.AngularVelocity">
            <summary>Gets or sets the angular velocity. Radians/second.</summary>
            <value>The angular velocity.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.LinearDamping">
            <summary>Gets or sets the linear damping.</summary>
            <value>The linear damping.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.AngularDamping">
            <summary>Gets or sets the angular damping.</summary>
            <value>The angular damping.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.IsBullet">
            <summary>Gets or sets a value indicating whether this body should be included in the CCD solver.</summary>
            <value><c>true</c> if this instance is included in CCD; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.SleepingAllowed">
            <summary>You can disable sleeping on this body. If you disable sleeping, the body will be woken.</summary>
            <value><c>true</c> if sleeping is allowed; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.Awake">
            <summary>Set the sleep state of the body. A sleeping body has very low CPU cost.</summary>
            <value><c>true</c> if awake; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.Enabled">
            <summary>
                Set the active state of the body. An inactive body is not simulated and cannot be collided with or woken up.
                If you pass a flag of true, all fixtures will be added to the broad-phase. If you pass a flag of false, all
                fixtures
                will be removed from the broad-phase and all contacts will be destroyed. Fixtures and joints are otherwise
                unaffected.
                You may continue to create/destroy fixtures and joints on inactive bodies. Fixtures on an inactive body are
                implicitly
                inactive and will not participate in collisions, ray-casts, or queries. Joints connected to an inactive body are
                implicitly inactive. An inactive body is still owned by a b2World object and remains in the body list.
            </summary>
            <value><c>true</c> if active; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.FixedRotation">
            <summary>Set this body to have fixed rotation. This causes the mass to be reset.</summary>
            <value><c>true</c> if it has fixed rotation; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.FixtureList">
            <summary>Gets all the fixtures attached to this body.</summary>
            <value>The fixture list.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.JointList">
            <summary>Get the list of all joints attached to this body.</summary>
            <value>The joint list.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.ContactList">
            <summary>
                Get the list of all contacts attached to this body. Warning: this list changes during the time step and you
                may miss some collisions if you don't use ContactListener.
            </summary>
            <value>The contact list.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.Position">
            <summary>Get the world body origin position.</summary>
            <returns>Return the world position of the body's origin.</returns>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.Rotation">
            <summary>Get the angle in radians.</summary>
            <returns>Return the current world rotation angle in radians.</returns>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.IsIsland">
            <summary>
                Gets the value of the is island
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.IsStatic">
            <summary>
                Gets the value of the is static
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.IsKinematic">
            <summary>
                Gets the value of the is kinematic
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.IsDynamic">
            <summary>
                Gets the value of the is dynamic
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.WorldCenter">
            <summary>Get the world position of the center of mass.</summary>
            <value>The world position.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.LocalCenter">
            <summary>Get the local position of the center of mass.</summary>
            <value>The local position.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.Mass">
            <summary>Gets or sets the mass. Usually in kilograms (kg).</summary>
            <value>The mass.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.Inertia">
            <summary>Get or set the rotational inertia of the body about the local origin. usually in kg-m^2.</summary>
            <value>The inertia.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.Restitution">
            <summary>
                Sets the value of the restitution
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.Friction">
            <summary>
                Sets the value of the friction
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.CollisionCategories">
            <summary>
                Sets the value of the collision categories
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.CollidesWith">
            <summary>
                Sets the value of the collides with
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.IgnoreCcdWith">
            <summary>
                Body objects can define which categories of bodies they wish to ignore CCD with. This allows certain bodies to
                be configured to ignore CCD with objects that aren't a penetration problem due to the way content has been
                prepared.
                This is compared against the other Body's fixture CollisionCategories within World.SolveTOI().
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.CollisionGroup">
            <summary>
                Sets the value of the collision group
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.IsSensor">
            <summary>
                Sets the value of the is sensor
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Body.IgnoreCcd">
            <summary>
                Gets or sets the value of the ignore ccd
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.GetMassData(Alis.Core.Physic.Collision.Shapes.MassData@)">
            <summary>
                Gets the mass data using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.ResetDynamics">
            <summary>Resets the dynamics of this body. Sets torque, force and linear/angular velocity to 0</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.AddFixture(Alis.Core.Physic.Dynamics.Fixture)">
            <summary>
                Creates a fixture and attach it to this body. If the density is non-zero, this function automatically updates
                the mass of the body. Contacts are not created until the next time step. Warning: This function is locked during
                callbacks.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.AddFixture(Alis.Core.Physic.Collision.Shapes.Shape)">
            <summary>
                Creates a fixture and attach it to this body. If the density is non-zero, this function automatically updates
                the mass of the body. Contacts are not created until the next time step. Warning: This function is locked during
                callbacks.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.RemoveFixture(Alis.Core.Physic.Dynamics.Fixture)">
            <summary>
                Destroy a fixture. This removes the fixture from the broad-phase and destroys all contacts associated with
                this fixture. This will automatically adjust the mass of the body if the body is dynamic and the fixture has
                positive
                density. All fixtures attached to a body are implicitly destroyed when the body is destroyed. Warning: This
                function is
                locked during callbacks.
            </summary>
            <param name="fixture">The fixture to be removed.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.SetTransform(Alis.Core.Aspect.Math.Vector.Vector2F,System.Single)">
            <summary>
                Set the position of the body's origin and rotation. This breaks any contacts and wakes the other bodies.
                Manipulating a body's transform may cause non-physical behavior.
            </summary>
            <param name="position">The world position of the body's local origin.</param>
            <param name="rotation">The world rotation in radians.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.SetTransform(Alis.Core.Aspect.Math.Vector.Vector2F@,System.Single)">
            <summary>
                Set the position of the body's origin and rotation. This breaks any contacts and wakes the other bodies.
                Manipulating a body's transform may cause non-physical behavior.
            </summary>
            <param name="position">The world position of the body's local origin.</param>
            <param name="rotation">The world rotation in radians.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.GetTransform(Alis.Core.Aspect.Math.Transform@)">
            <summary>Get the body transform for the body's origin.</summary>
            <param name="transform">The transform of the body's origin.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.ApplyForce(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Apply a force at a world point. If the force is not applied at the center of mass, it will generate a torque
                and affect the angular velocity. This wakes up the body.
            </summary>
            <param name="force">The world force vector, usually in Newtons (N).</param>
            <param name="point">The world position of the point of application.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.ApplyForce(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Applies a force at the center of mass.</summary>
            <param name="force">The force.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.ApplyForce(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Applies a force at the center of mass.</summary>
            <param name="force">The force.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.ApplyForce(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Apply a force at a world point. If the force is not applied at the center of mass, it will generate a torque
                and affect the angular velocity. This wakes up the body.
            </summary>
            <param name="force">The world force vector, usually in Newtons (N).</param>
            <param name="point">The world position of the point of application.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.ApplyTorque(System.Single)">
            <summary>Apply a torque. This affects the angular velocity without affecting the linear velocity of the center of mass.</summary>
            <param name="torque">The torque about the z-axis (out of the screen), usually in N-m.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.ApplyLinearImpulse(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Apply an impulse at a point. This immediately modifies the velocity. This wakes up the body.</summary>
            <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.ApplyLinearImpulse(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Apply an impulse at a point. This immediately modifies the velocity. It also modifies the angular velocity if
                the point of application is not at the center of mass. This wakes up the body.
            </summary>
            <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
            <param name="point">The world position of the point of application.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.ApplyLinearImpulse(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Apply an impulse at a point. This immediately modifies the velocity. This wakes up the body.</summary>
            <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.ApplyLinearImpulse(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Apply an impulse at a point. This immediately modifies the velocity. It also modifies the angular velocity if
                the point of application is not at the center of mass. This wakes up the body.
            </summary>
            <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
            <param name="point">The world position of the point of application.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.ApplyAngularImpulse(System.Single)">
            <summary>Apply an angular impulse.</summary>
            <param name="impulse">The angular impulse in units of kg*m*m/s.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.ResetMassData">
            <summary>
                This resets the mass properties to the sum of the mass properties of the fixtures. This normally does not need
                to be called unless you called SetMassData to override the mass and you later want to reset the mass.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.GetWorldPoint(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Get the world coordinates of a point given the local coordinates.</summary>
            <param name="localPoint">A point on the body measured relative the body's origin.</param>
            <returns>The same point expressed in world coordinates.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.GetWorldPoint(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Get the world coordinates of a point given the local coordinates.</summary>
            <param name="localPoint">A point on the body measured relative the body's origin.</param>
            <returns>The same point expressed in world coordinates.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.GetWorldVector(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Get the world coordinates of a vector given the local coordinates. Note that the vector only takes the
                rotation into account, not the position.
            </summary>
            <param name="localVector">A vector fixed in the body.</param>
            <returns>The same vector expressed in world coordinates.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.GetWorldVector(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Get the world coordinates of a vector given the local coordinates.</summary>
            <param name="localVector">A vector fixed in the body.</param>
            <returns>The same vector expressed in world coordinates.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.GetLocalPoint(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Gets a local point relative to the body's origin given a world point. Note that the vector only takes the
                rotation into account, not the position.
            </summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The corresponding local point relative to the body's origin.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.GetLocalPoint(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Gets a local point relative to the body's origin given a world point.</summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The corresponding local point relative to the body's origin.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.GetLocalVector(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Gets a local vector given a world vector. Note that the vector only takes the rotation into account, not the
                position.
            </summary>
            <param name="worldVector">A vector in world coordinates.</param>
            <returns>The corresponding local vector.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.GetLocalVector(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Gets a local vector given a world vector. Note that the vector only takes the rotation into account, not the
                position.
            </summary>
            <param name="worldVector">A vector in world coordinates.</param>
            <returns>The corresponding local vector.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.GetLinearVelocityFromWorldPoint(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Get the world linear velocity of a world point attached to this body.</summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.GetLinearVelocityFromWorldPoint(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Get the world linear velocity of a world point attached to this body.</summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.GetLinearVelocityFromLocalPoint(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Get the world velocity of a local point.</summary>
            <param name="localPoint">A point in local coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.GetLinearVelocityFromLocalPoint(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Get the world velocity of a local point.</summary>
            <param name="localPoint">A point in local coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.RemoveFromWorld">
            <summary> Calling this will remove the body from its associated world.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.SynchronizeFixtures">
            <summary>
                Synchronizes the fixtures
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.SynchronizeTransform">
            <summary>
                Synchronizes the transform
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.ShouldCollide(Alis.Core.Physic.Dynamics.Body)">
            <summary>This is used to prevent connected bodies from colliding. It may lie, depending on the collideConnected flag.</summary>
            <param name="other">The other body.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.ClearFlags">
            <summary>
            Initializes a new instance of the <see cref="M:Alis.Core.Physic.Dynamics.Body.ClearFlags"/> class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.Advance(System.Single)">
            <summary>
                Advances the alpha
            </summary>
            <param name="alpha">The alpha</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Body.ClearForces">
            <summary>
            Clears the forces
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.BodyFlags">
            <summary>
                The body flags enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.BodyFlags.Unknown">
            <summary>
                The unknown body flags
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.BodyFlags.IslandFlag">
            <summary>
                The island flag body flags
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.BodyFlags.AwakeFlag">
            <summary>
                The awake flag body flags
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.BodyFlags.AutoSleepFlag">
            <summary>
                The auto sleep flag body flags
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.BodyFlags.BulletFlag">
            <summary>
                The bullet flag body flags
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.BodyFlags.FixedRotationFlag">
            <summary>
                The fixed rotation flag body flags
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.BodyFlags.Enabled">
            <summary>
                The enabled body flags
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.BodyFlags.IgnoreCcd">
            <summary>
                The ignore ccd body flags
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.BodyType">
            <summary>The body type.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.BodyType.Static">
            <summary>Zero velocity, may be manually moved. Note: even static bodies have mass.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.BodyType.Kinematic">
            <summary>Zero mass, non-zero velocity set by user, moved by solver</summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.BodyType.Dynamic">
            <summary>Positive mass, non-zero velocity determined by forces, moved by solver</summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.BreakableBody">
            <summary>A type of body that supports multiple fixtures that can break apart.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.BreakableBody.world">
            <summary>
                The world
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.BreakableBody.angularVelocitiesCache">
            <summary>
                The angular velocities cache
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.BreakableBody.break">
            <summary>
                The break
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.BreakableBody.velocitiesCache">
            <summary>
                The vector
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.BreakableBody.#ctor(Alis.Core.Physic.World,System.Collections.Generic.ICollection{Alis.Core.Physic.Shared.Vertices},System.Single,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.BreakableBody" /> class
            </summary>
            <param name="world">The world</param>
            <param name="parts">The parts</param>
            <param name="density">The density</param>
            <param name="position">The position</param>
            <param name="rotation">The rotation</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.BreakableBody.#ctor(Alis.Core.Physic.World,System.Collections.Generic.IEnumerable{Alis.Core.Physic.Collision.Shapes.Shape},Alis.Core.Aspect.Math.Vector.Vector2F,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.BreakableBody" /> class
            </summary>
            <param name="world">The world</param>
            <param name="shapes">The shapes</param>
            <param name="position">The position</param>
            <param name="rotation">The rotation</param>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.BreakableBody.Strength">
            <summary>The force needed to break the body apart. Default: 500</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.BreakableBody.Broken">
            <summary>
                Gets or sets the value of the broken
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.BreakableBody.MainBody">
            <summary>
                Gets the value of the main body
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.BreakableBody.Parts">
            <summary>
                Gets the value of the parts
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.BreakableBody.PostSolve(Alis.Core.Physic.Collision.ContactSystem.Contact,Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint)">
            <summary>
                Posts the solve using the specified contact
            </summary>
            <param name="contact">The contact</param>
            <param name="impulse">The impulse</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.BreakableBody.Update">
            <summary>
                Updates this instance
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.BreakableBody.Decompose">
            <summary>
                Decomposes this instance
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.BreakableBody.Break">
            <summary>
                Breaks this instance
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Fixture">
            <summary>
                A fixture is used to attach a Shape to a body for collision detection. A fixture inherits its transform from
                its parent. Fixtures hold additional non-geometric data such as friction, collision filters, etc. Fixtures are
                created
                via Body.CreateFixture. Warning: You cannot reuse fixtures.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Fixture.AfterCollision">
            <summary>Fires after two shapes has collided and are solved. This gives you a chance to get the impact force.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Fixture.BeforeCollision">
            <summary>
                Fires when two fixtures are close to each other. Due to how the broadphase works, this can be quite inaccurate
                as shapes are approximated using AABBs.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Fixture.CollidesWithprivate">
            <summary>
                The collides with
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Fixture.CollisionCategoriesprivate">
            <summary>
                The collision categories
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Fixture.CollisionGroupPrivate">
            <summary>
                The collision group
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Fixture.IsSensorPrivate">
            <summary>
                The is sensor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Fixture.OnCollision">
            <summary>
                Fires when two shapes collide and a contact is created between them. Note that the first fixture argument is
                always the fixture that the delegate is subscribed to.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Fixture.OnSeparation">
            <summary>
                Fires when two shapes separate and a contact is removed between them. Note: This can in some cases be called
                multiple times, as a fixture can have multiple contacts. Note The first fixture argument is always the fixture that
                the
                delegate is subscribed to.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Fixture.#ctor(Alis.Core.Physic.Collision.Shapes.Shape,Alis.Core.Physic.Collision.Filtering.Filter,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Fixture" /> class
            </summary>
            <param name="shape">The shape</param>
            <param name="filter">The filter</param>
            <param name="friction">The friction</param>
            <param name="restitution">The restitution</param>
            <param name="restitutionThreshold">The restitution threshold</param>
            <param name="isSensor">The is sensor</param>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Fixture.Filter">
            <summary>Contact filtering data.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Fixture.IgnoreCcdWith">
            <summary>
                Gets or sets the value of the ignore ccd with
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Fixture.Proxies">
            <summary>
                Gets the value of the proxies
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Fixture.ProxyCount">
            <summary>
                Gets the value of the proxy count
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Fixture.RestitutionThreshold">
            <summary>Get or set the restitution threshold. This will _not_ change the restitution threshold of existing contacts.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Fixture.CollisionGroup">
            <summary>
                Defaults to 0 If Settings.UseFPECollisionCategories is set to false: Collision groups allow a certain group of
                objects to never collide (negative) or always collide (positive). Zero means no collision group. Non-zero group
                filtering always wins against the mask bits. If Settings.UseFPECollisionCategories is set to true: If 2 fixtures
                are in
                the same collision group, they will not collide.
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Fixture.CollidesWith">
            <summary>
                Defaults to Category.All The collision mask bits. This states the categories that this fixture would accept
                for collision. Use Settings.UseFPECollisionCategories to change the behavior.
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Fixture.CollisionCategories">
            <summary>
                The collision categories this fixture is a part of. If Settings.UseFPECollisionCategories is set to false:
                Defaults to Category.Cat1 If Settings.UseFPECollisionCategories is set to true: Defaults to Category.All
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Fixture.Shape">
            <summary>
                Get the child Shape. You can modify the child Shape, however you should not change the number of vertices
                because this will crash some collision caching mechanisms.
            </summary>
            <value>The shape.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Fixture.IsSensor">
            <summary>Gets or sets a value indicating whether this fixture is a sensor.</summary>
            <value><c>true</c> if this instance is a sensor; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Fixture.Body">
            <summary>Get the parent body of this fixture. This is null if the fixture is not attached.</summary>
            <value>The body.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Fixture.Friction">
            <summary>Set the coefficient of friction. This will _not_ change the friction of existing contacts.</summary>
            <value>The friction.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Fixture.Restitution">
            <summary>Set the coefficient of restitution. This will not change the restitution of existing contacts.</summary>
            <value>The restitution.</value>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Fixture.Refilter">
            <summary>
                Contacts are persistent and will keep being persistent unless they are flagged for filtering. This methods
                flags all contacts associated with the body for filtering.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Fixture.TestPoint(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Test a point for containment in this fixture.</summary>
            <param name="point">A point in world coordinates.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Fixture.RayCast(Alis.Core.Physic.Collision.RayCast.RayCastOutput@,Alis.Core.Physic.Collision.RayCast.RayCastInput@,System.Int32)">
            <summary>Cast a ray against this Shape.</summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="childIndex">Index of the child.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Fixture.GetAabb(Alis.Core.Physic.Shared.Aabb@,System.Int32)">
            <summary>
                Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a more accurate AABB, compute it
                using the Shape and the body transform.
            </summary>
            <param name="aabb">The AABB.</param>
            <param name="childIndex">Index of the child.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Fixture.Destroy">
            <summary>
                Destroys this instance
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Fixture.CreateProxies(Alis.Core.Physic.Collision.Broadphase.IBroadPhase,Alis.Core.Aspect.Math.Transform@)">
            <summary>
                Creates the proxies using the specified broad phase
            </summary>
            <param name="broadPhase">The broad phase</param>
            <param name="xf">The xf</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Fixture.DestroyProxies(Alis.Core.Physic.Collision.Broadphase.IBroadPhase)">
            <summary>
                Destroys the proxies using the specified broad phase
            </summary>
            <param name="broadPhase">The broad phase</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Fixture.Synchronize(Alis.Core.Physic.Collision.Broadphase.IBroadPhase,Alis.Core.Aspect.Math.Transform@,Alis.Core.Aspect.Math.Transform@)">
            <summary>
                Synchronizes the broad phase
            </summary>
            <param name="broadPhase">The broad phase</param>
            <param name="transform1">The transform</param>
            <param name="transform2">The transform</param>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.FixtureProxy">
            <summary>This proxy is used internally to connect fixtures to the broad-phase.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.FixtureProxy.Aabb">
            <summary>
                The aabb
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.FixtureProxy.ChildIndex">
            <summary>
                The child index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.FixtureProxy.Fixture">
            <summary>
                The fixture
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.FixtureProxy.ProxyId">
            <summary>
                The proxy id
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Handlers.BodyHandler">
            <summary>
                The body handler
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Handlers.ControllerHandler">
            <summary>
                The controller handler
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Handlers.FixtureHandler">
            <summary>
                The fixture handler
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Handlers.JointHandler">
            <summary>
                The joint handler
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Handlers.PostSolveHandler">
            <summary>
                The post solve handler
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Handlers.PreSolveHandler">
            <summary>
                The pre solve handler
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Joints.AngleJoint">
            <summary>Maintains a fixed angle between two bodies</summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.AngleJoint.bias">
            <summary>
                The bias
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.AngleJoint.biasFactor">
            <summary>
                The bias factor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.AngleJoint.jointError">
            <summary>
                The joint error
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.AngleJoint.massFactor">
            <summary>
                The mass factor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.AngleJoint.maxImpulse">
            <summary>
                The max impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.AngleJoint.softness">
            <summary>
                The softness
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.AngleJoint.targetAngle">
            <summary>
                The target angle
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.AngleJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Joints.AngleJoint" /> class
            </summary>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.AngleJoint.WorldAnchorA">
            <summary>
                Gets or sets the value of the world anchor a
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.AngleJoint.WorldAnchorB">
            <summary>
                Gets or sets the value of the world anchor b
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.AngleJoint.TargetAngle">
            <summary>The desired angle between BodyA and BodyB</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.AngleJoint.BiasFactor">
            <summary>Gets or sets the bias factor. Defaults to 0.2</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.AngleJoint.Impulse">
            <summary>Gets or sets the maximum impulse. Defaults to float.MaxValue</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.AngleJoint.Softness">
            <summary>Gets or sets the softness of the joint. Defaults to 0</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.AngleJoint.GetReactionForce(System.Single)">
            <summary>
                Gets the reaction force using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.AngleJoint.GetReactionTorque(System.Single)">
            <summary>
                Gets the reaction torque using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.AngleJoint.InitVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Inits the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.AngleJoint.SolveVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Solves the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.AngleJoint.SolvePositionConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Describes whether this instance solve position constraints
            </summary>
            <param name="data">The data</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Joints.DistanceJoint">
            <summary>
                A distance joint constrains two points on two bodies to remain at a fixed distance from each other. You can
                view this as a massless, rigid rod.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.bias">
            <summary>
                The bias
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.currentLength">
            <summary>
                The current length
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.damping">
            <summary>
                The damping
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.gamma">
            <summary>
                The gamma
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.impulse">
            <summary>
                The impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.indexA">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.indexB">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.invIa">
            <summary>
                The inv ia
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.invIb">
            <summary>
                The inv ib
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.invMassA">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.invMassB">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.lengthPrivate">
            <summary>
                The length
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.localAnchorA">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.localAnchorB">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.localCenterA">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.localCenterB">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.lowerImpulse">
            <summary>
                The lower impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.mass">
            <summary>
                The mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.maxLength">
            <summary>
                The max length
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.minLength">
            <summary>
                The min length
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.rA">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.rB">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.softMass">
            <summary>
                The soft mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.stiffness">
            <summary>
                The stiffness
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.u">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.upperImpulse">
            <summary>
                The upper impulse
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Joints.JointType,System.Boolean,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Joints.DistanceJoint" /> class
            </summary>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="jointType">The type</param>
            <param name="collideConnected">The collide connected</param>
            <param name="localAnchorA">The local anchor</param>
            <param name="localAnchorB">The local anchor</param>
            <param name="length">The length</param>
            <param name="minLength">The min length</param>
            <param name="maxLength">The max length</param>
            <param name="stiffness">The stiffness</param>
            <param name="damping">The damping</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>
                This requires defining an anchor point on both bodies and the non-zero length of the distance joint. If you
                don't supply a length, the local anchor points is used so that the initial configuration can violate the constraint
                slightly. This helps when saving and loading a game. Warning Do not use a zero or short length.
            </summary>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
            <param name="anchorA">The first body anchor</param>
            <param name="anchorB">The second body anchor</param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.LocalAnchorA">
            <summary>The local anchor point relative to bodyA's origin.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.LocalAnchorB">
            <summary>The local anchor point relative to bodyB's origin.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.WorldAnchorA">
            <summary>The anchor on <see cref="P:Alis.Core.Physic.Dynamics.Joints.Joint.BodyA" /> in world coordinates</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.WorldAnchorB">
            <summary>The anchor on <see cref="P:Alis.Core.Physic.Dynamics.Joints.Joint.BodyB" /> in world coordinates</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.LengthPropertie">
            <summary>The rest length of this joint. Clamped to a stable minimum value.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.Stiffness">
            <summary>Set/get the linear stiffness in N/m</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.Damping">
            <summary>Set/get linear damping in N*s/m</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.MinLength">
            <summary>Minimum length. Clamped to a stable minimum value.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.Length">
            <summary>Maximum length. Must be greater than or equal to the minimum length.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.GetReactionForce(System.Single)">
            <summary>Get the reaction force given the inverse time step. Unit is N.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.GetReactionTorque(System.Single)">
            <summary>Get the reaction torque given the inverse time step. Unit is N*m. This is always zero for a distance joint.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.InitVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Inits the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.SolveVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Solves the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.DistanceJoint.SolvePositionConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Describes whether this instance solve position constraints
            </summary>
            <param name="data">The data</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint">
            <summary>
                A mouse joint is used to make a point on a body track a specified world point. This a soft constraint with a
                maximum force. This allows the constraint to stretch and without applying huge forces. NOTE: this joint is not
                documented in the manual because it was developed to be used in the testbed. If you want to learn how to use the
                mouse
                joint, look at the testbed.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.beta">
            <summary>
                The beta
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.c">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.damping">
            <summary>
                The damping
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.gamma">
            <summary>
                The gamma
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.impulse">
            <summary>
                The impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.indexA">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.invIa">
            <summary>
                The inv ia
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.invMassA">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.localAnchorA">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.localCenterA">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.mass">
            <summary>
                The mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.maxForce">
            <summary>
                The max force
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.rA">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.stiffness">
            <summary>
                The stiffness
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.targetB">
            <summary>
                The target
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Joints.JointType,System.Boolean,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint" /> class
            </summary>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="jointType">The joint type</param>
            <param name="collideConnected">The collide connected</param>
            <param name="target">The target</param>
            <param name="maxForce">The max force</param>
            <param name="stiffness">The stiffness</param>
            <param name="damping">The damping</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>This requires a world target point, tuning parameters, and the time step.</summary>
            <param name="body">The body.</param>
            <param name="target">The target.</param>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.LocalAnchorA">
            <summary>The local anchor point on BodyB</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.WorldAnchorA">
            <summary>Use this to update the target point.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.WorldAnchorB">
            <summary>
                Gets or sets the value of the world anchor b
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.Force">
            <summary>
                The maximum constraint force that can be exerted to move the candidate body. Usually you will express as some
                multiple of the weight (multiplier * mass * gravity). Set/get the maximum force in Newtons.
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.Stiffness">
            <summary>Set/get the linear stiffness in N/m</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.Damping">
            <summary>Set/get linear damping in N*s/m</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.ShiftOrigin(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Shifts the origin using the specified new origin
            </summary>
            <param name="newOrigin">The new origin</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.GetReactionForce(System.Single)">
            <summary>
                Gets the reaction force using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.GetReactionTorque(System.Single)">
            <summary>
                Gets the reaction torque using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.InitVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Inits the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.SolveVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Solves the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.SolvePositionConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Describes whether this instance solve position constraints
            </summary>
            <param name="data">The data</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Joints.FrictionJoint">
            <summary>
                Friction joint. This is used for top-down friction. It provides 2D translational friction and angular
                friction.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.angularImpulse">
            <summary>
                The angular impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.angularMass">
            <summary>
                The angular mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.indexA">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.indexB">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.invIa">
            <summary>
                The inv ia
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.invIb">
            <summary>
                The inv ib
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.invMassA">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.invMassB">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.linearImpulse">
            <summary>
                The linear impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.linearMass">
            <summary>
                The linear mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.localAnchorA">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.localAnchorB">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.localCenterA">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.localCenterB">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.maxForce">
            <summary>
                The max force
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.maxTorque">
            <summary>
                The max torque
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.rA">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.rB">
            <summary>
                The
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Joints.JointType,System.Boolean,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Joints.FrictionJoint" /> class
            </summary>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="jointType">The joint type</param>
            <param name="collideConnected">The collide connected</param>
            <param name="localAnchorA">The local anchor</param>
            <param name="localAnchorB">The local anchor</param>
            <param name="maxForce">The max force</param>
            <param name="maxTorque">The max torque</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>Constructor for FrictionJoint.</summary>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="anchor"></param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.LocalAnchorA">
            <summary>The local anchor point on BodyA</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.LocalAnchorB">
            <summary>The local anchor point on BodyB</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.WorldAnchorA">
            <summary>
                Gets or sets the value of the world anchor a
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.WorldAnchorB">
            <summary>
                Gets or sets the value of the world anchor b
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.Force">
            <summary>The maximum friction force in N.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.Torque">
            <summary>The maximum friction torque in N-m.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.GetReactionForce(System.Single)">
            <summary>
                Gets the reaction force using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.GetReactionTorque(System.Single)">
            <summary>
                Gets the reaction torque using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.InitVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Inits the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.SolveVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Solves the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.FrictionJoint.SolvePositionConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Describes whether this instance solve position constraints
            </summary>
            <param name="data">The data</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Joints.GearJoint">
            <summary>
                A gear joint is used to connect two joints together. Either joint can be a revolute or prismatic joint. You specify
                a
                gear ratio to bind the motions together:
                <![CDATA[coordinate1 + ratio * coordinate2 = ant]]>
                The ratio can be negative or positive. If one joint is a revolute joint and the other joint is a prismatic joint,
                then
                the ratio will have units of length or units of 1/length. Warning: You have to manually destroy the gear joint if
                jointA or jointB is destroyed.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.bodyC">
            <summary>
                The body
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.bodyD">
            <summary>
                The body
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.constant">
            <summary>
                The constant
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.jointA">
            <summary>
                The joint
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.jointB">
            <summary>
                The joint
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.localAnchorA">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.localAnchorB">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.localAnchorC">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.localAnchorD">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.localAxisC">
            <summary>
                The local axis
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.localAxisD">
            <summary>
                The local axis
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.referenceAngleA">
            <summary>
                The reference angle
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.referenceAngleB">
            <summary>
                The reference angle
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.typeA">
            <summary>
                The type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.typeB">
            <summary>
                The type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.iA">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.iB">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.iC">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.iD">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.impulse">
            <summary>
                The impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.indexA">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.indexB">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.indexC">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.indexD">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.jvAc">
            <summary>
                The jv bd
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.jvBd">
            <summary>
                The jv bd
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.jwA">
            <summary>
                The jw
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.jwB">
            <summary>
                The jw
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.jwC">
            <summary>
                The jw
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.jwD">
            <summary>
                The jw
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.lcA">
            <summary>
                The lc
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.lcB">
            <summary>
                The lc
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.lcC">
            <summary>
                The lc
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.lcD">
            <summary>
                The lc
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.mA">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.mB">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.mC">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.mD">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.mass">
            <summary>
                The mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.GearJoint.ratio">
            <summary>
                The ratio
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.GearJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Joints.JointType,System.Boolean,Alis.Core.Physic.Dynamics.Joints.Joint,Alis.Core.Physic.Dynamics.Joints.Joint,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Joints.GearJoint" /> class
            </summary>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="jointType">The joint type</param>
            <param name="collideConnected">The collide connected</param>
            <param name="jointA">The joint</param>
            <param name="jointB">The joint</param>
            <param name="ratio">The ratio</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.GearJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Joints.Joint,Alis.Core.Physic.Dynamics.Joints.Joint,System.Single)">
            <summary>
                Requires two existing revolute or prismatic joints (any combination will work). The provided joints must
                attach a dynamic body to a static body.
            </summary>
            <param name="jointA">The first joint.</param>
            <param name="jointB">The second joint.</param>
            <param name="ratio">The ratio.</param>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.GearJoint.WorldAnchorA">
            <summary>
                Gets or sets the value of the world anchor a
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.GearJoint.WorldAnchorB">
            <summary>
                Gets or sets the value of the world anchor b
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.GearJoint.Ratio">
            <summary>The gear ratio.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.GearJoint.JointA">
            <summary>The first revolute/prismatic joint attached to the gear joint.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.GearJoint.JointB">
            <summary>The second revolute/prismatic joint attached to the gear joint.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.GearJoint.GetReactionForce(System.Single)">
            <summary>
                Gets the reaction force using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.GearJoint.GetReactionTorque(System.Single)">
            <summary>
                Gets the reaction torque using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.GearJoint.InitVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Inits the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.GearJoint.SolveVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Solves the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.GearJoint.SolvePositionConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Describes whether this instance solve position constraints
            </summary>
            <param name="data">The data</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Joints.Joint">
            <summary>
                The joint class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.Joint.bodyA">
            <summary>Indicate if this join is enabled or not. Disabling a joint means it is still in the simulation, but inactive.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.Joint.bodyB">
            <summary>
                The body
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.Joint.breakpoint">
            <summary>
                The breakpoint
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.Joint.collideConnected">
            <summary>
                The collide connected
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.Joint.enabled">
            <summary>
                The enabled
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.Joint.userData">
            <summary>
                The user data
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.Joint.#ctor(Alis.Core.Physic.Dynamics.Joints.JointType)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Joints.Joint" /> class
            </summary>
            <param name="jointType">The joint type</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.Joint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Joints.JointType)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Joints.Joint" /> class
            </summary>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="jointType">The joint type</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.Joint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Joints.JointType)">
            <summary>Constructor for fixed joint</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.Joint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Joints.JointType,System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Joints.Joint" /> class
            </summary>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="jointType">The type</param>
            <param name="collideConnected">The collide connected</param>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.Joint.EdgeA">
            <summary>
                The joint edge
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.Joint.EdgeB">
            <summary>
                The joint edge
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.Joint.IslandFlag">
            <summary>
                The island flag
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.Joint.JointType">
            <summary>Gets or sets the type of the joint.</summary>
            <value>The type of the joint.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.Joint.Enabled">
            <summary>
                Gets or sets the value of the enabled
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.Joint.BodyA">
            <summary>Get the first body attached to this joint.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.Joint.BodyB">
            <summary>Get the second body attached to this joint.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.Joint.WorldAnchorA">
            <summary>
                Get the anchor point on bodyA in world coordinates. On some joints, this value indicate the anchor point
                within the world.
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.Joint.WorldAnchorB">
            <summary>
                Get the anchor point on bodyB in world coordinates. On some joints, this value indicate the anchor point
                within the world.
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.Joint.UserData">
            <summary>Set the user data pointer.</summary>
            <value>The data.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.Joint.CollideConnected">
            <summary>Set this flag to true if the attached bodies should collide.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.Joint.Breakpoint">
            <summary>
                The Breakpoint simply indicates the maximum Value the JointError can be before it breaks. The default value is
                float.MaxValue, which means it never breaks.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.Joint._jointType">
            <summary>
                The joint type
            </summary>
        </member>
        <member name="E:Alis.Core.Physic.Dynamics.Joints.Joint.Broke">
            <summary>Fires when the joint is broken.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.Joint.GetReactionForce(System.Single)">
            <summary>Get the reaction force on body at the joint anchor in Newtons.</summary>
            <param name="invDt">The inverse delta time.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.Joint.GetReactionTorque(System.Single)">
            <summary>Get the reaction torque on the body at the joint anchor in N*m.</summary>
            <param name="invDt">The inverse delta time.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.Joint.ShiftOrigin(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Shift the origin for any points stored in world coordinates.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.Joint.WakeBodies">
            <summary>
                Wakes the bodies
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.Joint.IsFixedType">
            <summary>Return true if the joint is a fixed type.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.Joint.InitVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Inits the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.Joint.Validate(System.Single)">
            <summary>
                Validates the inv dt
            </summary>
            <param name="invDt">The inv dt</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.Joint.SolveVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Solves the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.Joint.SolvePositionConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>Solves the position constraints.</summary>
            <param name="data"></param>
            <returns>returns true if the position errors are within tolerance.</returns>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Joints.JointEdge">
            <summary>
                A joint edge is used to connect bodies and joints together in a joint graph where each body is a node and each
                joint is an edge. A joint edge belongs to a doubly linked list maintained in each attached body. Each joint has two
                joint nodes, one for each attached body.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointEdge.Joint">
            <summary>The joint.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointEdge.Next">
            <summary>The next joint edge in the body's joint list.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointEdge.Other">
            <summary>Provides quick access to the other body attached.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointEdge.Prev">
            <summary>The previous joint edge in the body's joint list.</summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Joints.JointType">
            <summary>
                The joint type enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.Unknown">
            <summary>
                The unknown joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.Revolute">
            <summary>
                The revolute joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.Prismatic">
            <summary>
                The prismatic joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.Distance">
            <summary>
                The distance joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.Pulley">
            <summary>
                The pulley joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.Gear">
            <summary>
                The gear joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.Wheel">
            <summary>
                The wheel joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.Weld">
            <summary>
                The weld joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.Friction">
            <summary>
                The friction joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.Motor">
            <summary>
                The motor joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.Angle">
            <summary>
                The angle joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.FixedMouse">
            <summary>
                The fixed mouse joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.FixedRevolute">
            <summary>
                The fixed revolute joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.FixedDistance">
            <summary>
                The fixed distance joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.FixedLine">
            <summary>
                The fixed line joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.FixedPrismatic">
            <summary>
                The fixed prismatic joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.FixedAngle">
            <summary>
                The fixed angle joint type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.JointType.FixedFriction">
            <summary>
                The fixed friction joint type
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Joints.LimitState">
            <summary>
                The limit state enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.LimitState.Inactive">
            <summary>
                The inactive limit state
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.LimitState.AtLower">
            <summary>
                The at lower limit state
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.LimitState.AtUpper">
            <summary>
                The at upper limit state
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.LimitState.Equal">
            <summary>
                The equal limit state
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Joints.MotorJoint">
            <summary>
                A motor joint is used to control the relative motion between two bodies. A typical usage is to control the
                movement of a dynamic body with respect to the ground.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.angularError">
            <summary>
                The angular error
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.angularImpulse">
            <summary>
                The angular impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.angularMass">
            <summary>
                The angular mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.angularOffset">
            <summary>
                The angular offset
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.correctionFactor">
            <summary>
                The correction factor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.indexA">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.indexB">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.invIa">
            <summary>
                The inv ia
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.invIb">
            <summary>
                The inv ib
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.invMassA">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.invMassB">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.linearError">
            <summary>
                The linear error
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.linearImpulse">
            <summary>
                The linear impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.linearMass">
            <summary>
                The linear mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.linearOffset">
            <summary>
                The linear offset
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.localCenterA">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.localCenterB">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.maxForce">
            <summary>
                The max force
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.maxTorque">
            <summary>
                The max torque
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.rA">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.MotorJoint.rB">
            <summary>
                The
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.MotorJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Joints.JointType,System.Boolean,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,System.Single,System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Joints.MotorJoint" /> class
            </summary>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="jointType">The joint type</param>
            <param name="collideConnected">The collide connected</param>
            <param name="linearOffset">The linear offset</param>
            <param name="angularOffset">The angular offset</param>
            <param name="maxForce">The max force</param>
            <param name="maxTorque">The max torque</param>
            <param name="correctionFactor">The correction factor</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.MotorJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,System.Boolean)">
            <summary>Constructor for MotorJoint.</summary>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.MotorJoint.WorldAnchorA">
            <summary>
                Gets or sets the value of the world anchor a
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.MotorJoint.WorldAnchorB">
            <summary>
                Gets or sets the value of the world anchor b
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.MotorJoint.Force">
            <summary>Get/set the maximum friction force in N.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.MotorJoint.Torque">
            <summary>Get/set the maximum friction torque in N*m.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.MotorJoint.CorrectionFactor">
            <summary>
                Get/set the position correction factor in the range [0,1].
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.MotorJoint.LinearOffset">
            <summary>The linear (translation) offset.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.MotorJoint.AngularOffset">
            <summary>Get or set the angular offset.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.MotorJoint.GetReactionForce(System.Single)">
            <summary>
                Gets the reaction force using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.MotorJoint.GetReactionTorque(System.Single)">
            <summary>
                Gets the reaction torque using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.MotorJoint.InitVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Inits the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.MotorJoint.SolveVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Solves the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.MotorJoint.SolvePositionConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Describes whether this instance solve position constraints
            </summary>
            <param name="data">The data</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint">
            <summary>
                A prismatic joint. This joint provides one degree of freedom: translation along an axis fixed in bodyA.
                Relative rotation is prevented. You can use a joint limit to restrict the range of motion and a joint motor to
                drive
                the motion or to model joint friction.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.a1">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.a2">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.axialMass">
            <summary>
                The axial mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.axis">
            <summary>
                The perp
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.perp">
            <summary>
                The perp
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.enableLimit">
            <summary>
                The enable limit
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.enableMotor">
            <summary>
                The enable motor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.impulse">
            <summary>
                The impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.indexA">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.indexB">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.invIa">
            <summary>
                The inv ia
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.invIb">
            <summary>
                The inv ib
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.invMassA">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.invMassB">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.k">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.localAnchorA">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.localAnchorB">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.localCenterA">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.localCenterB">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.localXAxisA">
            <summary>
                The local axis
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.localYAxisA">
            <summary>
                The local axis
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.lowerImpulse">
            <summary>
                The lower impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.lowerTranslation">
            <summary>
                The lower translation
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.maxMotorForce">
            <summary>
                The max motor force
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.motorImpulse">
            <summary>
                The motor impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.motorSpeed">
            <summary>
                The motor speed
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.referenceAngle">
            <summary>
                The reference angle
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.s1">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.s2">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.translation">
            <summary>
                The translation
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.upperImpulse">
            <summary>
                The upper impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.upperTranslation">
            <summary>
                The upper translation
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>
                This requires defining a line of motion using an axis and an anchor point. The definition uses local anchor
                points and a local axis so that the initial configuration can violate the constraint slightly. The joint
                translation is
                zero when the local anchor points coincide in world space. Using local anchors and a local axis helps when saving
                and
                loading a game.
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="anchorA">The first body anchor.</param>
            <param name="anchorB">The second body anchor.</param>
            <param name="axis">The axis.</param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint" /> class
            </summary>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="anchor">The anchor</param>
            <param name="axis">The axis</param>
            <param name="useWorldCoordinates">The use world coordinates</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Joints.JointType,System.Boolean,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,System.Boolean,System.Single,System.Single,System.Boolean,System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint" /> class
            </summary>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="jointType">The joint type</param>
            <param name="collideConnected">The collide connected</param>
            <param name="localAnchorA">The local anchor</param>
            <param name="localAnchorB">The local anchor</param>
            <param name="localAxisA">The local axis</param>
            <param name="referenceAngle">The reference angle</param>
            <param name="enableLimit">The enable limit</param>
            <param name="lowerTranslation">The lower translation</param>
            <param name="upperTranslation">The upper translation</param>
            <param name="enableMotor">The enable motor</param>
            <param name="maxMotorForce">The max motor force</param>
            <param name="motorSpeed">The motor speed</param>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.LocalAnchorA">
            <summary>The local anchor point on BodyA</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.LocalAnchorB">
            <summary>The local anchor point on BodyB</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.WorldAnchorA">
            <summary>
                Gets or sets the value of the world anchor a
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.WorldAnchorB">
            <summary>
                Gets or sets the value of the world anchor b
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.JointTranslation">
            <summary>Get the current joint translation, usually in meters.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.JointSpeed">
            <summary>Get the current joint translation speed, usually in meters per second.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.LimitEnabled">
            <summary>Is the joint limit enabled?</summary>
            <value><c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.LowerLimit">
            <summary>Get the lower joint limit, usually in meters.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.UpperLimit">
            <summary>Get the upper joint limit, usually in meters.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.MotorEnabled">
            <summary>Is the joint motor enabled?</summary>
            <value><c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.MotorSpeed">
            <summary>Set the motor speed, usually in meters per second.</summary>
            <value>The speed.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.MotorForce">
            <summary>Set the maximum motor force, usually in N.</summary>
            <value>The force.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.LocalXAxisA">
            <summary>The local joint axis relative to bodyA.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.LocalYAxisA">
            <summary>
                Gets the value of the local y axis a
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.ReferenceAngle">
            <summary>Get the reference angle.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.GetMotorForce(System.Single)">
            <summary>Get the current motor force given the inverse time step, usually in N.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.SetLimits(System.Single,System.Single)">
            <summary>Set the joint limits, usually in meters.</summary>
            <param name="lower">The lower limit</param>
            <param name="upper">The upper limit</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.GetReactionForce(System.Single)">
            <summary>
                Gets the reaction force using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.GetReactionTorque(System.Single)">
            <summary>
                Gets the reaction torque using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.InitVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Inits the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.SolveVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Solves the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.SolvePositionConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Describes whether this instance solve position constraints
            </summary>
            <param name="data">The data</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.Initialize(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>
                Initializes the local anchor a
            </summary>
            <param name="localAnchorA">The local anchor</param>
            <param name="localAnchorB">The local anchor</param>
            <param name="axis">The axis</param>
            <param name="useWorldCoordinates">The use world coordinates</param>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Joints.PulleyJoint">
            <summary>
                The pulley joint is connected to two bodies and two fixed world points. The pulley supports a ratio such that:
                <![CDATA[length1 + ratio * length2 <= constant]]>
                Yes, the force transmitted is scaled by the ratio. Warning: the pulley joint can get a bit squirrelly by itself.
                They
                often work better when combined with prismatic joints. You should also cover the the anchor points with static
                shapes
                to prevent one side from going to zero length.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.constant">
            <summary>
                The constant
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.impulse">
            <summary>
                The impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.indexA">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.indexB">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.invIa">
            <summary>
                The inv ia
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.invIb">
            <summary>
                The inv ib
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.invMassA">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.invMassB">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.lengthA">
            <summary>
                The length
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.lengthB">
            <summary>
                The length
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.localAnchorA">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.localAnchorB">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.localCenterA">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.localCenterB">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.mass">
            <summary>
                The mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.rA">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.ratio">
            <summary>
                The ratio
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.rB">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.uA">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.uB">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.worldAnchorA">
            <summary>
                The world anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.worldAnchorB">
            <summary>
                The world anchor
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Joints.JointType,System.Boolean,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Joints.PulleyJoint" /> class
            </summary>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="jointType">The joint type</param>
            <param name="collideConnected">The collide connected</param>
            <param name="groundAnchorA">The ground anchor</param>
            <param name="groundAnchorB">The ground anchor</param>
            <param name="localAnchorA">The local anchor</param>
            <param name="localAnchorB">The local anchor</param>
            <param name="lengthA">The length</param>
            <param name="lengthB">The length</param>
            <param name="ratio">The ratio</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,System.Boolean)">
            <summary>Constructor for PulleyJoint.</summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="anchorA">The anchor on the first body.</param>
            <param name="anchorB">The anchor on the second body.</param>
            <param name="worldAnchorA">The world anchor for the first body.</param>
            <param name="worldAnchorB">The world anchor for the second body.</param>
            <param name="ratio">The ratio.</param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.LocalAnchorA">
            <summary>The local anchor point on BodyA</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.LocalAnchorB">
            <summary>The local anchor point on BodyB</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.WorldAnchorA">
            <summary>Get the first world anchor.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.WorldAnchorB">
            <summary>Get the second world anchor.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.LengthA">
            <summary>Get the current length of the segment attached to BodyA.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.LengthB">
            <summary>Get the current length of the segment attached to BodyB.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.CurrentLengthA">
            <summary>The current length between the anchor point on BodyA and WorldAnchorA</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.CurrentLengthB">
            <summary>The current length between the anchor point on BodyB and WorldAnchorB</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.Ratio">
            <summary>Get the pulley ratio.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.ShiftOrigin(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Shifts the origin using the specified new origin
            </summary>
            <param name="newOrigin">The new origin</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.GetReactionForce(System.Single)">
            <summary>
                Gets the reaction force using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.GetReactionTorque(System.Single)">
            <summary>
                Gets the reaction torque using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.InitVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Inits the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.SolveVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Solves the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.PulleyJoint.SolvePositionConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Describes whether this instance solve position constraints
            </summary>
            <param name="data">The data</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint">
            <summary>
                A revolute joint constrains to bodies to share a common point while they are free to rotate about the point.
                The relative rotation about the shared point is the joint angle. You can limit the relative rotation with a joint
                limit
                that specifies a lower and upper angle. You can use a motor to drive the relative rotation about the shared point.
                A
                maximum motor torque is provided so that infinite forces are not generated.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.angle">
            <summary>
                The angle
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.axialMass">
            <summary>
                The axial mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.enableLimit">
            <summary>
                The enable limit
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.enableMotor">
            <summary>
                The enable motor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.impulse">
            <summary>
                The impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.indexA">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.indexB">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.invIa">
            <summary>
                The inv ia
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.invIb">
            <summary>
                The inv ib
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.invMassA">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.invMassB">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.k">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.localAnchorA">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.localAnchorB">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.localCenterA">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.localCenterB">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.lowerAngle">
            <summary>
                The lower angle
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.lowerImpulse">
            <summary>
                The lower impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.maxMotorTorque">
            <summary>
                The max motor torque
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.motorImpulse">
            <summary>
                The motor impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.motorSpeed">
            <summary>
                The motor speed
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.rA">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.rB">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.referenceAngle">
            <summary>
                The reference angle
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.upperAngle">
            <summary>
                The upper angle
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.upperImpulse">
            <summary>
                The upper impulse
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Joints.JointType,System.Boolean,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint" /> class
            </summary>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="jointType">The joint type</param>
            <param name="collideConnected">The collide connected</param>
            <param name="localAnchorA">The local anchor</param>
            <param name="localAnchorB">The local anchor</param>
            <param name="referenceAngle">The reference angle</param>
            <param name="lowerAngle">The lower angle</param>
            <param name="upperAngle">The upper angle</param>
            <param name="motorTorque">The motor torque</param>
            <param name="motorSpeed">The motor speed</param>
            <param name="enableLimit">The enable limit</param>
            <param name="enableMotor">The enable motor</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>Constructor of RevoluteJoint.</summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="anchorA">The first body anchor.</param>
            <param name="anchorB">The second anchor.</param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>Constructor of RevoluteJoint.</summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="anchor">The shared anchor.</param>
            <param name="useWorldCoordinates"></param>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.EnableLimit">
            <summary>A flag to enable joint limits.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.EnableMotor">
            <summary>A flag to enable the joint motor.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.LowerAngle">
            <summary>The lower angle for the joint limit (radians).</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.UpperAngle">
            <summary>The upper angle for the joint limit (radians).</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.LocalAnchorA">
            <summary>The local anchor point on BodyA</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.LocalAnchorB">
            <summary>The local anchor point on BodyB</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.WorldAnchorA">
            <summary>
                Gets or sets the value of the world anchor a
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.WorldAnchorB">
            <summary>
                Gets or sets the value of the world anchor b
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.ReferenceAngle">
            <summary>The referance angle computed as BodyB angle minus BodyA angle.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.JointAngle">
            <summary>Get the current joint angle in radians.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.JointSpeed">
            <summary>Get the current joint angle speed in radians per second.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.LimitEnabled">
            <summary>Is the joint limit enabled?</summary>
            <value><c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.LowerLimit">
            <summary>Get the lower joint limit in radians.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.UpperLimit">
            <summary>Get the upper joint limit in radians.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.MotorEnabled">
            <summary>Is the joint motor enabled?</summary>
            <value><c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.MotorSpeed">
            <summary>Get or set the motor speed in radians per second.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.MotorTorque">
            <summary>Get or set the maximum motor torque, usually in N-m.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.SetLimits(System.Single,System.Single)">
            <summary>Set the joint limits, usually in meters.</summary>
            <param name="lower">The lower limit</param>
            <param name="upper">The upper limit</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.GetMotorTorque(System.Single)">
            <summary>Gets the motor torque in N-m.</summary>
            <param name="invDt">The inverse delta time</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.GetReactionForce(System.Single)">
            <summary>
                Gets the reaction force using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.GetReactionTorque(System.Single)">
            <summary>
                Gets the reaction torque using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.InitVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Inits the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.SolveVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Solves the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.SolvePositionConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Describes whether this instance solve position constraints
            </summary>
            <param name="data">The data</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Joints.WeldJoint">
            <summary>
                A weld joint essentially glues two bodies together. A weld joint may distort somewhat because the island
                constraint solver is approximate. The joint is soft constraint based, which means the two bodies will move relative
                to
                each other, when a force is applied. To combine two bodies in a rigid fashion, combine the fixtures to a single
                body
                instead.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.referenceAngle">
            <summary>
                The reference angle
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.bias">
            <summary>
                The bias
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.damping">
            <summary>
                The damping
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.gamma">
            <summary>
                The gamma
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.impulse">
            <summary>
                The impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.indexA">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.indexB">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.invIa">
            <summary>
                The inv ia
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.invIb">
            <summary>
                The inv ib
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.invMassA">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.invMassB">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.localAnchorA">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.localAnchorB">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.localCenterA">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.localCenterB">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.mass">
            <summary>
                The mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.rA">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.rB">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WeldJoint.stiffness">
            <summary>
                The stiffness
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WeldJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Joints.JointType,System.Boolean,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Joints.WeldJoint" /> class
            </summary>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="jointType">The joint type</param>
            <param name="collideConnected">The collide connected</param>
            <param name="localAnchorA">The local anchor</param>
            <param name="localAnchorB">The local anchor</param>
            <param name="referenceAngle">The reference angle</param>
            <param name="stiffness">The stiffness</param>
            <param name="damping">The damping</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WeldJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>
                You need to specify an anchor point where they are attached. The position of the anchor point is important for
                computing the reaction torque.
            </summary>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
            <param name="anchorA">The first body anchor.</param>
            <param name="anchorB">The second body anchor.</param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WeldJoint.LocalAnchorA">
            <summary>The local anchor point on BodyA</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WeldJoint.LocalAnchorB">
            <summary>The local anchor point on BodyB</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WeldJoint.WorldAnchorA">
            <summary>
                Gets or sets the value of the world anchor a
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WeldJoint.WorldAnchorB">
            <summary>
                Gets or sets the value of the world anchor b
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WeldJoint.ReferenceAngle">
            <summary>The bodyB angle minus bodyA angle in the reference state (radians).</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WeldJoint.Stiffness">
            <summary>
                The frequency of the joint. A higher frequency means a stiffer joint, but a too high value can cause the joint
                to oscillate. Default is 0, which means the joint does no spring calculations.
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WeldJoint.Damping">
            <summary>
                The damping on the joint. The damping is only used when the joint has a frequency (> 0). A higher value means
                more damping.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WeldJoint.GetReactionForce(System.Single)">
            <summary>
                Gets the reaction force using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WeldJoint.GetReactionTorque(System.Single)">
            <summary>
                Gets the reaction torque using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WeldJoint.InitVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Inits the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WeldJoint.SolveVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Solves the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WeldJoint.SolvePositionConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Describes whether this instance solve position constraints
            </summary>
            <param name="data">The data</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Joints.WheelJoint">
            <summary>
                A wheel joint. This joint provides two degrees of freedom: translation along an axis fixed in bodyA and
                rotation in the plane. In other words, it is a point to line constraint with a rotational motor and a linear
                spring/damper. The spring/damper is initialized upon creation. This joint is designed for vehicle suspensions.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.localXAxisA">
            <summary>
                The local axis
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.localYAxisA">
            <summary>
                The local axis
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.ax">
            <summary>
                The ay
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.ay">
            <summary>
                The ay
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.axialMass">
            <summary>
                The axial mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.bias">
            <summary>
                The bias
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.damping">
            <summary>
                The damping
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.enableLimit">
            <summary>
                The enable limit
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.enableMotor">
            <summary>
                The enable motor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.gamma">
            <summary>
                The gamma
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.impulse">
            <summary>
                The impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.indexA">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.indexB">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.invIa">
            <summary>
                The inv ia
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.invIb">
            <summary>
                The inv ib
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.invMassA">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.invMassB">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.localAnchorA">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.localAnchorB">
            <summary>
                The local anchor
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.localCenterA">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.localCenterB">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.lowerImpulse">
            <summary>
                The lower impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.lowerTranslation">
            <summary>
                The lower translation
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.mass">
            <summary>
                The mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.maxMotorTorque">
            <summary>
                The max motor torque
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.motorImpulse">
            <summary>
                The motor impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.motorMass">
            <summary>
                The motor mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.motorSpeed">
            <summary>
                The motor speed
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.sAx">
            <summary>
                The bx
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.sBx">
            <summary>
                The bx
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.sAy">
            <summary>
                The by
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.sBy">
            <summary>
                The by
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.springImpulse">
            <summary>
                The spring impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.springMass">
            <summary>
                The spring mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.stiffness">
            <summary>
                The stiffness
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.translation">
            <summary>
                The translation
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.upperImpulse">
            <summary>
                The upper impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Joints.WheelJoint.upperTranslation">
            <summary>
                The upper translation
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WheelJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>Constructor for WheelJoint</summary>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
            <param name="anchor">The anchor point</param>
            <param name="axis">The axis</param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WheelJoint.#ctor(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Joints.JointType,System.Boolean,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean,System.Single,System.Single,System.Boolean,System.Single,System.Single,System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Joints.WheelJoint" /> class
            </summary>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="jointType">The joint type</param>
            <param name="collideConnected">The collide connected</param>
            <param name="localAnchorA">The local anchor</param>
            <param name="localAnchorB">The local anchor</param>
            <param name="localAxisA">The local axis</param>
            <param name="enableLimit">The enable limit</param>
            <param name="lowerTranslation">The lower translation</param>
            <param name="upperTranslation">The upper translation</param>
            <param name="enableMotor">The enable motor</param>
            <param name="maxMotorTorque">The max motor torque</param>
            <param name="motorSpeed">The motor speed</param>
            <param name="stiffness">The stiffness</param>
            <param name="damping">The damping</param>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.LocalXAxisA">
            <summary>
                Gets the value of the local x axis a
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.LocalYAxisA">
            <summary>
                Gets the value of the local y axis a
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.LocalAnchorA">
            <summary>The local anchor point on BodyA</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.LocalAnchorB">
            <summary>The local anchor point on BodyB</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.WorldAnchorA">
            <summary>
                Gets or sets the value of the world anchor a
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.WorldAnchorB">
            <summary>
                Gets or sets the value of the world anchor b
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.LocalXAxis">
            <summary>The axis in local coordinates relative to BodyA</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.MotorSpeed">
            <summary>The desired motor speed in radians per second.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.MotorTorque">
            <summary>The maximum motor torque, usually in N-m.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.JointTranslation">
            <summary>Gets the translation along the axis</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.JointLinearSpeed">
            <summary>
                Gets the value of the joint linear speed
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.JointAngle">
            <summary>
                Gets the value of the joint angle
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.JointAngularSpeed">
            <summary>Gets the angular velocity of the joint</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.MotorEnabled">
            <summary>Enable/disable the joint motor.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.UpperLimit">
            <summary>
                Gets or sets the value of the upper limit
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.LowerLimit">
            <summary>
                Gets or sets the value of the lower limit
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.EnableLimit">
            <summary>
                Gets or sets the value of the enable limit
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.Damping">
            <summary>
                Gets or sets the value of the damping
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Dynamics.Joints.WheelJoint.Stiffness">
            <summary>
                Gets or sets the value of the stiffness
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WheelJoint.SetLimits(System.Single,System.Single)">
            <summary>
                Sets the limits using the specified lower
            </summary>
            <param name="lower">The lower</param>
            <param name="upper">The upper</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WheelJoint.GetMotorTorque(System.Single)">
            <summary>Gets the torque of the motor</summary>
            <param name="invDt">inverse delta time</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WheelJoint.GetReactionForce(System.Single)">
            <summary>
                Gets the reaction force using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WheelJoint.GetReactionTorque(System.Single)">
            <summary>
                Gets the reaction torque using the specified inv dt
            </summary>
            <param name="invDt">The inv dt</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WheelJoint.InitVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Inits the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WheelJoint.SolveVelocityConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Solves the velocity constraints using the specified data
            </summary>
            <param name="data">The data</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Joints.WheelJoint.SolvePositionConstraints(Alis.Core.Physic.Dynamics.Solver.SolverData@)">
            <summary>
                Describes whether this instance solve position constraints
            </summary>
            <param name="data">The data</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Profile">
            <summary>
                The profile
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Profile.Step">
            <summary>
                The time it takes to complete the full World.Step()
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Profile.Collide">
            <summary>
                The time it takes to find collisions in the CollisionManager
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Profile.Solve">
            <summary>
                The time it takes to solve integration of velocities, constraints and integrate positions
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Profile.SolveInit">
            <summary>
                Timings from the island solver. The time it takes to initialize velocity constraints.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Profile.SolveVelocity">
            <summary>
                Timings from the island solver. It includes the time it takes to solve joint velocity constraints.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Profile.SolvePosition">
            <summary>
                Timings from the island solver. In includes the time it takes to solve join positions.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Profile.Broadphase">
            <summary>
                The time it takes for the broad-phase to update
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Profile.SolveToi">
            <summary>
                The time it takes for the time-of-impact solver
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Profile.AddRemoveTime">
            <summary>
                Time it takes to process newly added and removed bodies/joints/controllers from the world
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Profile.NewContactsTime">
            <summary>
                The time it takes for the contact manager to find new contacts in the world
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Profile.ControllersUpdateTime">
            <summary>
                The time it takes to update controller logic
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Profile.BreakableBodies">
            <summary>
                The time it takes to update breakable bodies
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint">
            <summary>
                The contact position constraint class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint.IndexA">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint.IndexB">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint.InvIa">
            <summary>
                The inv ib
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint.InvIb">
            <summary>
                The inv ib
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint.InvMassA">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint.InvMassB">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint.LocalCenterA">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint.LocalCenterB">
            <summary>
                The local center
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint.LocalNormal">
            <summary>
                The local normal
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint.LocalPoint">
            <summary>
                The local point
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint.LocalPoints">
            <summary>
                The max manifold points
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint.PointCount">
            <summary>
                The point count
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint.RadiusA">
            <summary>
                The radius
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint.RadiusB">
            <summary>
                The radius
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint.Type">
            <summary>
                The type
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Solver.ContactSolver">
            <summary>
                The contact solver class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactSolver.contacts">
            <summary>
                The contacts
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactSolver.count">
            <summary>
                The count
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactSolver.positionConstraints">
            <summary>
                The position constraints
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactSolver.positions">
            <summary>
                The positions
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactSolver.step">
            <summary>
                The step
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactSolver.velocities">
            <summary>
                The velocities
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactSolver.VelocityConstraints">
            <summary>
                The velocity constraints
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.ContactSolver.Reset(Alis.Core.Aspect.Time.TimeStep,System.Int32,Alis.Core.Physic.Collision.ContactSystem.Contact[],Alis.Core.Physic.Dynamics.Solver.Position[],Alis.Core.Physic.Dynamics.Solver.Velocity[])">
            <summary>
                Resets the step
            </summary>
            <param name="step">The step</param>
            <param name="count">The count</param>
            <param name="contacts">The contacts</param>
            <param name="positions">The positions</param>
            <param name="velocities">The velocities</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.ContactSolver.InitializeVelocityConstraints">
            <summary>Initialize position dependent portions of the velocity constraints.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.ContactSolver.WarmStart">
            <summary>
                Warms the start
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.ContactSolver.SolveVelocityConstraints">
            <summary>
                Solves the velocity constraints
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.ContactSolver.StoreImpulses">
            <summary>
                Stores the impulses
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.ContactSolver.SolvePositionConstraints">
            <summary>
                Describes whether this instance solve position constraints
            </summary>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.ContactSolver.SolveToiPositionConstraints(System.Int32,System.Int32)">
            <summary>
                Describes whether this instance solve toi position constraints
            </summary>
            <param name="toiIndexA">The toi index</param>
            <param name="toiIndexB">The toi index</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint">
            <summary>
                The contact velocity constraint class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.ContactIndex">
            <summary>
                The contact index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.Friction">
            <summary>
                The friction
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.IndexA">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.IndexB">
            <summary>
                The index
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.InvIa">
            <summary>
                The inv ib
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.InvIb">
            <summary>
                The inv ib
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.InvMassA">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.InvMassB">
            <summary>
                The inv mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.K">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.Normal">
            <summary>
                The normal
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.NormalMass">
            <summary>
                The normal mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.PointCount">
            <summary>
                The point count
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.Points">
            <summary>
                The max manifold points
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.Restitution">
            <summary>
                The restitution
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.TangentSpeed">
            <summary>
                The tangent speed
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.Threshold">
            <summary>
                The threshold
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint" /> class
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Solver.Island">
            <summary>This is an internal class.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.angTolSqr">
            <summary>
                The angular sleep tolerance
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.contactSolver">
            <summary>
                The contact solver
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.linTolSqr">
            <summary>
                The linear sleep tolerance
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.timer">
            <summary>
                The stopwatch
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.Bodies">
            <summary>
                The bodies
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.BodyCapacity">
            <summary>
                The body capacity
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.BodyCount">
            <summary>
                The body count
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.ContactCapacity">
            <summary>
                The contact capacity
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.ContactCount">
            <summary>
                The contact count
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.contactManager">
            <summary>
                The contact manager
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.contacts">
            <summary>
                The contacts
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.jointCapacity">
            <summary>
                The joint capacity
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.jointCount">
            <summary>
                The joint count
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.joints">
            <summary>
                The joints
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.positions">
            <summary>
                The positions
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Island.velocities">
            <summary>
                The velocities
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.Island.Reset(System.Int32,System.Int32,System.Int32,Alis.Core.Physic.Collision.ContactSystem.ContactManager)">
            <summary>
                Resets the body capacity
            </summary>
            <param name="bodyCapacity">The body capacity</param>
            <param name="contactCapacity">The contact capacity</param>
            <param name="jointCapacity">The joint capacity</param>
            <param name="contactManager">The contact manager</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.Island.Clear">
            <summary>
                Clears this instance
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.Island.Solve(Alis.Core.Aspect.Time.TimeStep,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>
                Solves the profile
            </summary>
            <param name="step">The step</param>
            <param name="gravity">The gravity</param>
            <param name="allowSleep">The allow sleep</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.Island.SolveToi(Alis.Core.Aspect.Time.TimeStep@,System.Int32,System.Int32)">
            <summary>
                Solves the toi using the specified sub step
            </summary>
            <param name="subStep">The sub step</param>
            <param name="toiIndexA">The toi index</param>
            <param name="toiIndexB">The toi index</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.Island.Add(Alis.Core.Physic.Dynamics.Body)">
            <summary>
                Adds the body
            </summary>
            <param name="body">The body</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.Island.Add(Alis.Core.Physic.Collision.ContactSystem.Contact)">
            <summary>
                Adds the contact
            </summary>
            <param name="contact">The contact</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.Island.Add(Alis.Core.Physic.Dynamics.Joints.Joint)">
            <summary>
                Adds the joint
            </summary>
            <param name="joint">The joint</param>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.Island.Report(Alis.Core.Physic.Dynamics.Solver.ContactVelocityConstraint[])">
            <summary>
                Reports the constraints
            </summary>
            <param name="constraints">The constraints</param>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Solver.Position">
            This is an internal structure.
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Position.C">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Position.A">
            <summary>
                The
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Solver.PositionSolverManifold">
            <summary>
                The position solver manifold class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Dynamics.Solver.PositionSolverManifold.Initialize(Alis.Core.Physic.Dynamics.Solver.ContactPositionConstraint,Alis.Core.Aspect.Math.Transform@,Alis.Core.Aspect.Math.Transform@,System.Int32,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,System.Single@)">
            <summary>
                Initializes the pc
            </summary>
            <param name="pc">The pc</param>
            <param name="xfA">The xf</param>
            <param name="xfB">The xf</param>
            <param name="index">The index</param>
            <param name="normal">The normal</param>
            <param name="point">The point</param>
            <param name="separation">The separation</param>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Solver.SolverData">
            <summary>
                The solver data
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.SolverData.Step">
            <summary>
                The step
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.SolverData.Positions">
            <summary>
                The positions
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.SolverData.Velocities">
            <summary>
                The velocities
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Solver.Velocity">
            This is an internal structure.
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Velocity.V">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.Velocity.W">
            <summary>
                The
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Dynamics.Solver.VelocityConstraintPoint">
            <summary>
                The velocity constraint point class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.VelocityConstraintPoint.NormalImpulse">
            <summary>
                The normal impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.VelocityConstraintPoint.NormalMass">
            <summary>
                The normal mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.VelocityConstraintPoint.Ra">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.VelocityConstraintPoint.Rb">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.VelocityConstraintPoint.TangentImpulse">
            <summary>
                The tangent impulse
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.VelocityConstraintPoint.TangentMass">
            <summary>
                The tangent mass
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Dynamics.Solver.VelocityConstraintPoint.VelocityBias">
            <summary>
                The velocity bias
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.Controllers.ControllerBase.Controller">
            <summary>
                The controller class
            </summary>
            <seealso cref="T:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData" />
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.ControllerBase.Controller.type">
            <summary>
                The type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.ControllerBase.Controller.Enabled">
            <summary>
                The enabled
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.ControllerBase.Controller.World">
            <summary>
                The world
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.ControllerBase.Controller.#ctor(Alis.Core.Physic.Extensions.Controllers.ControllerBase.ControllerType)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Extensions.Controllers.ControllerBase.Controller" /> class
            </summary>
            <param name="controllerType">The controller type</param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.ControllerBase.Controller.IsActiveOn(Alis.Core.Physic.Dynamics.Body)">
            <summary>
                Describes whether this instance is active on
            </summary>
            <param name="body">The body</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.ControllerBase.Controller.Update(System.Single)">
            <summary>
                Updates the dt
            </summary>
            <param name="dt">The dt</param>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.Controllers.ControllerBase.ControllerFilter">
            <summary>
                The controller filter
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.ControllerBase.ControllerFilter.ControllerFlags">
            <summary>
                The controller flags
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.ControllerBase.ControllerFilter.IgnoreController(Alis.Core.Physic.Extensions.Controllers.ControllerBase.ControllerType)">
            <summary>Ignores the controller. The controller has no effect on this body.</summary>
            <param name="controller">The controller type.</param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.ControllerBase.ControllerFilter.RestoreController(Alis.Core.Physic.Extensions.Controllers.ControllerBase.ControllerType)">
            <summary>Restore the controller. The controller affects this body.</summary>
            <param name="controller">The controller type.</param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.ControllerBase.ControllerFilter.IsControllerIgnored(Alis.Core.Physic.Extensions.Controllers.ControllerBase.ControllerType)">
            <summary>Determines whether this body ignores the specified controller.</summary>
            <param name="controller">The controller type.</param>
            <returns><c>true</c> if the body has the specified flag; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.Controllers.ControllerBase.ControllerType">
            <summary>
                The controller type enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.ControllerBase.ControllerType.GravityController">
            <summary>
                The gravity controller controller type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.ControllerBase.ControllerType.VelocityLimitController">
            <summary>
                The velocity limit controller controller type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.ControllerBase.ControllerType.AbstractForceController">
            <summary>
                The abstract force controller controller type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.ControllerBase.ControllerType.BuoyancyController">
            <summary>
                The buoyancy controller controller type
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityController">
            <summary>
                The gravity controller class
            </summary>
            <seealso cref="T:Alis.Core.Physic.Extensions.Controllers.ControllerBase.Controller" />
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityController.#ctor(System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityController" /> class
            </summary>
            <param name="strength">The strength</param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityController.#ctor(System.Single,System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityController" /> class
            </summary>
            <param name="strength">The strength</param>
            <param name="maxRadius">The max radius</param>
            <param name="minRadius">The min radius</param>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityController.MinRadius">
            <summary>
                Gets or sets the value of the min radius
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityController.Radius">
            <summary>
                Gets or sets the value of the max radius
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityController.Strength">
            <summary>
                Gets or sets the value of the strength
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityController.GravityType">
            <summary>
                Gets or sets the value of the gravity type
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityController.Bodies">
            <summary>
                Gets or sets the value of the bodies
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityController.Points">
            <summary>
                Gets or sets the value of the points
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityController.Update(System.Single)">
            <summary>
                Updates the dt
            </summary>
            <param name="dt">The dt</param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityController.AddBody(Alis.Core.Physic.Dynamics.Body)">
            <summary>
                Adds the body using the specified body
            </summary>
            <param name="body">The body</param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityController.AddPoint(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Adds the point using the specified point
            </summary>
            <param name="point">The point</param>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityType">
            <summary>
                The gravity type enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityType.Linear">
            <summary>
                The linear gravity type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Gravity.GravityType.DistanceSquared">
            <summary>
                The distance squared gravity type
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController">
            <summary>
                Put a limit on the linear (translation - the move speed) and angular (rotation) velocity of bodies added to
                this controller.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController.bodies">
            <summary>
                The body
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController.LimitAngularVelocity">
            <summary>
                The limit angular velocity
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController.LimitLinearVelocity">
            <summary>
                The limit linear velocity
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController.maxAngularSqared">
            <summary>
                The max angular sqared
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController.maxAngularVelocity">
            <summary>
                The max angular velocity
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController.maxLinearSqared">
            <summary>
                The max linear sqared
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController.maxLinearVelocity">
            <summary>
                The max linear velocity
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController" /> class. Sets the max linear velocity
                to Settings.MaxTranslation Sets the max angular velocity to Settings.MaxRotation
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController.#ctor(System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController" /> class. Pass in 0 or float.MaxValue to
                disable the limit. maxAngularVelocity = 0 will disable the angular velocity limit.
            </summary>
            <param name="maxLinearVelocity">The max linear velocity.</param>
            <param name="maxAngularVelocity">The max angular velocity.</param>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController.AngularVelocity">
            <summary>Gets or sets the max angular velocity.</summary>
            <value>The max angular velocity.</value>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController.LinearVelocity">
            <summary>Gets or sets the max linear velocity.</summary>
            <value>The max linear velocity.</value>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController.Update(System.Single)">
            <summary>
                Updates the dt
            </summary>
            <param name="dt">The dt</param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController.AddBody(Alis.Core.Physic.Dynamics.Body)">
            <summary>
                Adds the body using the specified body
            </summary>
            <param name="body">The body</param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Velocity.VelocityLimitController.RemoveBody(Alis.Core.Physic.Dynamics.Body)">
            <summary>
                Removes the body using the specified body
            </summary>
            <param name="body">The body</param>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController">
            <summary>
                The abstract force controller class
            </summary>
            <seealso cref="T:Alis.Core.Physic.Extensions.Controllers.ControllerBase.Controller" />
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.DecayCurve">
            <summary>Curve to be used for Decay in Curve mode</summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.ForceType">
            <summary>The Forcetype of the instance</summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.Randomize">
            <summary>Provided for reuse to provide Variation functionality in inheriting classes</summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.StrengthCurve">
            <summary>
                Curve used by Curve Mode as an animated multiplier for the force strength. Only positions between 0 and 1 are
                considered as that range is stretched to have ImpulseLength.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController" /> class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.#ctor(Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.TimingModes)">
            <summary>Overloaded Contstructor with supplying Timing Mode</summary>
            <param name="mode"></param>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.Strength">
            <summary>Global Strength of the force to be applied</summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.Position">
            <summary>Position of the Force. Can be ignored (left at (0,0) for forces that are not position-dependent</summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.MaximumSpeed">
            <summary>Maximum speed of the bodies. Bodies that are travelling faster are supposed to be ignored</summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.TimingMode">
            <summary>Timing Mode of the force instance</summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.ImpulseTime">
            <summary>Time of the current impulse. Incremented in update till ImpulseLength is reached</summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.ImpulseLength">
            <summary>Length of a triggered impulse. Used in both Triggered and Curve Mode</summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.Triggered">
            <summary>Indicating if we are currently during an Impulse (Triggered and Curve Mode)</summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.Variation">
            <summary>Variation of the force applied to each body affected !! Must be used in inheriting classes properly !!</summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.DecayMode">
            <summary>See DecayModes</summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.DecayStart">
            <summary>Start of the distance based Decay. To set a non decaying area</summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.DecayEnd">
            <summary>Maximum distance a force should be applied</summary>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.DecayModes">
            <summary>Modes for Decay. Actual Decay must be implemented in inheriting classes</summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.DecayModes.None">
            <summary>
                The none decay modes
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.DecayModes.Step">
            <summary>
                The step decay modes
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.DecayModes.Linear">
            <summary>
                The linear decay modes
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.DecayModes.InverseSquare">
            <summary>
                The inverse square decay modes
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.DecayModes.Curve">
            <summary>
                The curve decay modes
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.ForceTypes">
            <summary>
                Forcetypes are used in the decay math to properly get the distance. They are also used to draw a
                representation in DebugView
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.ForceTypes.Point">
            <summary>
                The point force types
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.ForceTypes.Line">
            <summary>
                The line force types
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.ForceTypes.Area">
            <summary>
                The area force types
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.TimingModes">
            <summary>
                Timing Modes Switched: Standard on/off mode using the baseclass enabled property Triggered: When the Trigger()
                method is called the force is active for a specified Impulse Length Curve: Still to be defined. The basic idea is
                having a Trigger combined with a curve for the strength
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.TimingModes.Switched">
            <summary>
                The switched timing modes
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.TimingModes.Triggered">
            <summary>
                The triggered timing modes
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.TimingModes.Curve">
            <summary>
                The curve timing modes
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.GetDecayMultiplier(Alis.Core.Physic.Dynamics.Body)">
            <summary>
                Calculate the Decay for a given body. Meant to ease force development and stick to the DRY principle and
                provide unified and predictable decay math.
            </summary>
            <param name="body">The body to calculate decay for</param>
            <returns>A multiplier to multiply the force with to add decay support in inheriting classes</returns>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.Trigger">
            <summary>Triggers the trigger modes (Trigger and Curve)</summary>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.Update(System.Single)">
            <summary>Inherited from Controller Depending on the TimingMode perform timing logic and call ApplyForce()</summary>
            <param name="dt"></param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Wind.AbstractForceController.ApplyForce(System.Single,System.Single)">
            <summary>Apply the force supplying strength which is modified in Update() according to the TimingMode</summary>
            <param name="dt"></param>
            <param name="strength">The strength</param>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveLoopType">
            <summary>
                Defines how the <see cref="N:Alis.Core.Physic.Extensions.Controllers.Wind.Curve" /> value is determined for position before first point or after the end
                point on the <see cref="N:Alis.Core.Physic.Extensions.Controllers.Wind.Curve" />.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveLoopType.Constant">
            <summary>
                The value of <see cref="N:Alis.Core.Physic.Extensions.Controllers.Wind.Curve" /> will be evaluated as first point for positions before the beginning and end
                point for positions after the end.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveLoopType.Cycle">
            <summary>The positions will wrap around from the end to beginning of the <see cref="N:Alis.Core.Physic.Extensions.Controllers.Wind.Curve" /> for determined the value.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveLoopType.CycleOffset">
            <summary>
                The positions will wrap around from the end to beginning of the <see cref="N:Alis.Core.Physic.Extensions.Controllers.Wind.Curve" />. The value will be offset
                by the difference between the values of first and end <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" /> multiplied by the wrap amount. If the
                position is before the beginning of the <see cref="N:Alis.Core.Physic.Extensions.Controllers.Wind.Curve" /> the difference will be subtracted from its value;
                otherwise the difference will be added.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveLoopType.Oscillate">
            <summary>
                The value at the end of the <see cref="N:Alis.Core.Physic.Extensions.Controllers.Wind.Curve" /> act as an offset from the same side of the
                <see cref="N:Alis.Core.Physic.Extensions.Controllers.Wind.Curve" /> toward the opposite side.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveLoopType.Linear">
            <summary>The linear interpolation will be performed for determined the value.</summary>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveTangent">
            <summary>
                Defines the different tangent types to be calculated for <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" /> points in a
                <see cref="N:Alis.Core.Physic.Extensions.Controllers.Wind.Curve" />.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveTangent.Flat">
            <summary>The tangent which always has a value equal to zero.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveTangent.Linear">
            <summary>
                The tangent which contains a difference between current tangent value and the tangent value from the previous
                <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" />.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveTangent.Smooth">
            <summary>
                The smoouth tangent which contains the inflection between <see cref="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.TangentIn" /> and
                <see cref="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.TangentOut" /> by taking into account the values of both neighbors of the
                <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" />.
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.Controllers.Wind.SimpleWindForce">
            <summary>
                Reference implementation for forces based on AbstractForceController It supports all features provided by the
                base class and illustrates proper usage as an easy to understand example. As a side-effect it is a nice and easy to
                use
                wind force for your projects
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Wind.SimpleWindForce.Direction">
            <summary>Direction of the windforce</summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Wind.SimpleWindForce.Divergence">
            <summary>The amount of Direction randomization. Allowed range is 0-1.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Extensions.Controllers.Wind.SimpleWindForce.IgnorePosition">
            <summary>
                Ignore the position and apply the force. If off only in the "front" (relative to position and direction) will
                be affected
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.Controllers.Wind.SimpleWindForce.ApplyForce(System.Single,System.Single)">
            <summary>
                Applies the force using the specified dt
            </summary>
            <param name="dt">The dt</param>
            <param name="strength">The strength</param>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData">
            <summary>Contains filter data that can determine whether an object should be processed or not.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData.DisabledOnCategories">
            <summary>Disable the logic on specific categories. Category.None by default.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData.DisabledOnGroup">
            <summary>Disable the logic on specific groups</summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData.EnabledOnCategories">
            <summary>Enable the logic on specific categories Category.All by default.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData.EnabledOnGroup">
            <summary>Enable the logic on specific groups.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData.IsActiveOn(Alis.Core.Physic.Dynamics.Body)">
            <summary></summary>
            <param name="body"></param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData.AddDisabledCategory(Alis.Core.Physic.Collision.Filtering.Category)">
            <summary>Adds the category.</summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData.RemoveDisabledCategory(Alis.Core.Physic.Collision.Filtering.Category)">
            <summary>Removes the category.</summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData.IsInDisabledCategory(Alis.Core.Physic.Collision.Filtering.Category)">
            <summary>Determines whether this body ignores the the specified controller.</summary>
            <param name="category">The category.</param>
            <returns><c>true</c> if the object has the specified category; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData.AddEnabledCategory(Alis.Core.Physic.Collision.Filtering.Category)">
            <summary>Adds the category.</summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData.RemoveEnabledCategory(Alis.Core.Physic.Collision.Filtering.Category)">
            <summary>Removes the category.</summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData.IsInEnabledInCategory(Alis.Core.Physic.Collision.Filtering.Category)">
            <summary>Determines whether this body ignores the the specified controller.</summary>
            <param name="category">The category.</param>
            <returns><c>true</c> if the object has the specified category; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogic">
            <summary>
                The physics logic class
            </summary>
            <seealso cref="T:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData" />
        </member>
        <member name="F:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogic.type">
            <summary>
                The type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogic.World">
            <summary>
                The world
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogic.#ctor(Alis.Core.Physic.World,Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicType)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogic" /> class
            </summary>
            <param name="world">The world</param>
            <param name="type">The type</param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogic.IsActiveOn(Alis.Core.Physic.Dynamics.Body)">
            <summary>
                Describes whether this instance is active on
            </summary>
            <param name="body">The body</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicFilter">
            <summary>
                The physics logic filter
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicFilter.ControllerIgnores">
            <summary>
                The controller ignores
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicFilter.IgnorePhysicsLogic(Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicType)">
            <summary>Ignores the controller. The controller has no effect on this body.</summary>
            <param name="type">The logic type.</param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicFilter.RestorePhysicsLogic(Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicType)">
            <summary>Restore the controller. The controller affects this body.</summary>
            <param name="type">The logic type.</param>
        </member>
        <member name="M:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicFilter.IsPhysicsLogicIgnored(Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicType)">
            <summary>Determines whether this body ignores the specified controller.</summary>
            <param name="type">The logic type.</param>
            <returns><c>true</c> if the body has the specified flag; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicType">
            <summary>
                The physics logic type enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicType.Explosion">
            <summary>
                The explosion physics logic type
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.ShapeData">
            <summary>
                The shape data
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.ShapeData.Body">
            <summary>
                The body
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.ShapeData.Max">
            <summary>
                The max
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Extensions.PhysicsLogics.PhysicsLogicBase.ShapeData.Min">
            <summary>
                The min
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Factories.BodyFactory">
            <summary>
                The body factory class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateBody(Alis.Core.Physic.World,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,Alis.Core.Physic.Dynamics.BodyType)">
            <summary>
                Creates the body using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="position">The position</param>
            <param name="rotation">The rotation</param>
            <param name="bodyType">The body type</param>
            <returns>The body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateEdge(Alis.Core.Physic.World,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Object)">
            <summary>
                Creates the edge using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="start">The start</param>
            <param name="end">The end</param>
            <param name="userData">The user data</param>
            <returns>The body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateChainShape(Alis.Core.Physic.World,Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Vector.Vector2F,System.Object)">
            <summary>
                Creates the chain shape using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="vertices">The vertices</param>
            <param name="position">The position</param>
            <param name="userData">The user data</param>
            <returns>The body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateLoopShape(Alis.Core.Physic.World,Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Vector.Vector2F,System.Object)">
            <summary>
                Creates the loop shape using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="vertices">The vertices</param>
            <param name="position">The position</param>
            <param name="userData">The user data</param>
            <returns>The body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateRectangle(Alis.Core.Physic.World,System.Single,System.Single,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,Alis.Core.Physic.Dynamics.BodyType,System.Object)">
            <summary>
                Creates the rectangle using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="width">The width</param>
            <param name="height">The height</param>
            <param name="density">The density</param>
            <param name="position">The position</param>
            <param name="rotation">The rotation</param>
            <param name="bodyType">The body type</param>
            <param name="userData">The user data</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Height must be more than 0 meters</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Width must be more than 0 meters</exception>
            <returns>The body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateCircle(Alis.Core.Physic.World,System.Single,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Physic.Dynamics.BodyType,System.Object)">
            <summary>
                Creates the circle using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="radius">The radius</param>
            <param name="density">The density</param>
            <param name="position">The position</param>
            <param name="bodyType">The body type</param>
            <param name="userData">The user data</param>
            <returns>The body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateEllipse(Alis.Core.Physic.World,System.Single,System.Single,System.Int32,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,Alis.Core.Physic.Dynamics.BodyType,System.Object)">
            <summary>
                Creates the ellipse using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="xRadius">The radius</param>
            <param name="yRadius">The radius</param>
            <param name="edges">The edges</param>
            <param name="density">The density</param>
            <param name="position">The position</param>
            <param name="rotation">The rotation</param>
            <param name="bodyType">The body type</param>
            <param name="userData">The user data</param>
            <returns>The body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreatePolygon(Alis.Core.Physic.World,Alis.Core.Physic.Shared.Vertices,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,Alis.Core.Physic.Dynamics.BodyType,System.Object)">
            <summary>
                Creates the polygon using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="vertices">The vertices</param>
            <param name="density">The density</param>
            <param name="position">The position</param>
            <param name="rotation">The rotation</param>
            <param name="bodyType">The body type</param>
            <param name="userData">The user data</param>
            <returns>The body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateCompoundPolygon(Alis.Core.Physic.World,System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices},System.Single,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,Alis.Core.Physic.Dynamics.BodyType,System.Object)">
            <summary>
                Creates the compound polygon using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="list">The list</param>
            <param name="density">The density</param>
            <param name="position">The position</param>
            <param name="rotation">The rotation</param>
            <param name="bodyType">The body type</param>
            <param name="userData">The user data</param>
            <returns>The body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateGear(Alis.Core.Physic.World,System.Single,System.Int32,System.Single,System.Single,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,Alis.Core.Physic.Dynamics.BodyType,System.Object)">
            <summary>
                Creates the gear using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="radius">The radius</param>
            <param name="numberOfTeeth">The number of teeth</param>
            <param name="tipPercentage">The tip percentage</param>
            <param name="toothHeight">The tooth height</param>
            <param name="density">The density</param>
            <param name="position">The position</param>
            <param name="rotation">The rotation</param>
            <param name="bodyType">The body type</param>
            <param name="userData">The user data</param>
            <returns>The body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateCapsule(Alis.Core.Physic.World,System.Single,System.Single,System.Int32,System.Single,System.Int32,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,Alis.Core.Physic.Dynamics.BodyType,System.Object)">
            <summary>
                Creates the capsule using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="height">The height</param>
            <param name="topRadius">The top radius</param>
            <param name="topEdges">The top edges</param>
            <param name="bottomRadius">The bottom radius</param>
            <param name="bottomEdges">The bottom edges</param>
            <param name="density">The density</param>
            <param name="position">The position</param>
            <param name="rotation">The rotation</param>
            <param name="bodyType">The body type</param>
            <param name="userData">The user data</param>
            <returns>The body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateCapsule(Alis.Core.Physic.World,System.Single,System.Single,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,Alis.Core.Physic.Dynamics.BodyType,System.Object)">
            <summary>
                Creates the capsule using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="height">The height</param>
            <param name="endRadius">The end radius</param>
            <param name="density">The density</param>
            <param name="position">The position</param>
            <param name="rotation">The rotation</param>
            <param name="bodyType">The body type</param>
            <param name="userData">The user data</param>
            <returns>The body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateRoundedRectangle(Alis.Core.Physic.World,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,Alis.Core.Physic.Dynamics.BodyType,System.Object)">
            <summary>
                Creates the rounded rectangle using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="width">The width</param>
            <param name="height">The height</param>
            <param name="xRadius">The radius</param>
            <param name="yRadius">The radius</param>
            <param name="segments">The segments</param>
            <param name="density">The density</param>
            <param name="position">The position</param>
            <param name="rotation">The rotation</param>
            <param name="bodyType">The body type</param>
            <param name="userData">The user data</param>
            <returns>The body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateLineArc(Alis.Core.Physic.World,System.Single,System.Int32,System.Single,System.Boolean,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,Alis.Core.Physic.Dynamics.BodyType,System.Object)">
            <summary>
                Creates the line arc using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="radians">The radians</param>
            <param name="sides">The sides</param>
            <param name="radius">The radius</param>
            <param name="closed">The closed</param>
            <param name="position">The position</param>
            <param name="rotation">The rotation</param>
            <param name="bodyType">The body type</param>
            <param name="userData">The user data</param>
            <returns>The body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateSolidArc(Alis.Core.Physic.World,System.Single,System.Single,System.Int32,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,Alis.Core.Physic.Dynamics.BodyType,System.Object)">
            <summary>
                Creates the solid arc using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="density">The density</param>
            <param name="radians">The radians</param>
            <param name="sides">The sides</param>
            <param name="radius">The radius</param>
            <param name="position">The position</param>
            <param name="rotation">The rotation</param>
            <param name="bodyType">The body type</param>
            <param name="userData">The user data</param>
            <returns>The body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateBreakableBody(Alis.Core.Physic.World,Alis.Core.Physic.Shared.Vertices,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single)">
            <summary>
                Creates the breakable body using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="vertices">The vertices</param>
            <param name="density">The density</param>
            <param name="position">The position</param>
            <param name="rotation">The rotation</param>
            <returns>The breakable body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateBreakableBody(Alis.Core.Physic.World,System.Collections.Generic.IEnumerable{Alis.Core.Physic.Collision.Shapes.Shape},Alis.Core.Aspect.Math.Vector.Vector2F,System.Single)">
            <summary>
                Creates the breakable body using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="shapes">The shapes</param>
            <param name="position">The position</param>
            <param name="rotation">The rotation</param>
            <returns>The breakable body</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.BodyFactory.CreateFromDef(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body)">
            <summary>
                Creates the from def using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="def">The def</param>
            <returns>The body</returns>
        </member>
        <member name="T:Alis.Core.Physic.Factories.FixtureFactory">
            <summary>An easy to use factory for creating bodies</summary>
        </member>
        <member name="M:Alis.Core.Physic.Factories.FixtureFactory.AttachEdge(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Physic.Dynamics.Body,System.Object)">
            <summary>
                Attaches the edge using the specified start
            </summary>
            <param name="start">The start</param>
            <param name="end">The end</param>
            <param name="body">The body</param>
            <param name="userData">The user data</param>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.FixtureFactory.AttachChainShape(Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Dynamics.Body,System.Object)">
            <summary>
                Attaches the chain shape using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <param name="body">The body</param>
            <param name="userData">The user data</param>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.FixtureFactory.AttachLoopShape(Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Dynamics.Body,System.Object)">
            <summary>
                Attaches the loop shape using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <param name="body">The body</param>
            <param name="userData">The user data</param>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.FixtureFactory.AttachRectangle(System.Single,System.Single,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Physic.Dynamics.Body,System.Object)">
            <summary>
                Attaches the rectangle using the specified width
            </summary>
            <param name="width">The width</param>
            <param name="height">The height</param>
            <param name="density">The density</param>
            <param name="offset">The offset</param>
            <param name="body">The body</param>
            <param name="userData">The user data</param>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.FixtureFactory.AttachCircle(System.Single,System.Single,Alis.Core.Physic.Dynamics.Body,System.Object)">
            <summary>
                Attaches the circle using the specified radius
            </summary>
            <param name="radius">The radius</param>
            <param name="density">The density</param>
            <param name="body">The body</param>
            <param name="userData">The user data</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Radius must be more than 0 meters</exception>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.FixtureFactory.AttachCircle(System.Single,System.Single,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,System.Object)">
            <summary>
                Attaches the circle using the specified radius
            </summary>
            <param name="radius">The radius</param>
            <param name="density">The density</param>
            <param name="body">The body</param>
            <param name="offset">The offset</param>
            <param name="userData">The user data</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Radius must be more than 0 meters</exception>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.FixtureFactory.AttachPolygon(Alis.Core.Physic.Shared.Vertices,System.Single,Alis.Core.Physic.Dynamics.Body,System.Object)">
            <summary>
                Attaches the polygon using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <param name="density">The density</param>
            <param name="body">The body</param>
            <param name="userData">The user data</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Too few points to be a polygon</exception>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.FixtureFactory.AttachEllipse(System.Single,System.Single,System.Int32,System.Single,Alis.Core.Physic.Dynamics.Body,System.Object)">
            <summary>
                Attaches the ellipse using the specified x radius
            </summary>
            <param name="xRadius">The radius</param>
            <param name="yRadius">The radius</param>
            <param name="edges">The edges</param>
            <param name="density">The density</param>
            <param name="body">The body</param>
            <param name="userData">The user data</param>
            <exception cref="T:System.ArgumentOutOfRangeException">X-radius must be more than 0</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Y-radius must be more than 0</exception>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.FixtureFactory.AttachCompoundPolygon(System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices},System.Single,Alis.Core.Physic.Dynamics.Body)">
            <summary>
                Attaches the compound polygon using the specified list
            </summary>
            <param name="list">The list</param>
            <param name="density">The density</param>
            <param name="body">The body</param>
            <returns>The res</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.FixtureFactory.AttachLineArc(System.Single,System.Int32,System.Single,System.Boolean,Alis.Core.Physic.Dynamics.Body)">
            <summary>
                Attaches the line arc using the specified radians
            </summary>
            <param name="radians">The radians</param>
            <param name="sides">The sides</param>
            <param name="radius">The radius</param>
            <param name="closed">The closed</param>
            <param name="body">The body</param>
            <returns>The fixture</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.FixtureFactory.AttachSolidArc(System.Single,System.Single,System.Int32,System.Single,Alis.Core.Physic.Dynamics.Body)">
            <summary>
                Attaches the solid arc using the specified density
            </summary>
            <param name="density">The density</param>
            <param name="radians">The radians</param>
            <param name="sides">The sides</param>
            <param name="radius">The radius</param>
            <param name="body">The body</param>
            <returns>A list of fixture</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.FixtureFactory.CreateFromDef(Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Fixture)">
            <summary>
                Creates the from def using the specified body
            </summary>
            <param name="body">The body</param>
            <param name="fixture">The fixture def</param>
            <returns>The fixture</returns>
        </member>
        <member name="T:Alis.Core.Physic.Factories.JointFactory">
            <summary>An easy to use factory for using joints.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreateMotorJoint(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,System.Boolean)">
            <summary>
                Creates the motor joint using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="useWorldCoordinates">The use world coordinates</param>
            <returns>The joint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreateWeldJoint(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>
                Creates the weld joint using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="anchorA">The anchor</param>
            <param name="anchorB">The anchor</param>
            <param name="useWorldCoordinates">The use world coordinates</param>
            <returns>The weld joint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreatePrismaticJoint(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>
                Creates the prismatic joint using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="anchor">The anchor</param>
            <param name="axis">The axis</param>
            <param name="useWorldCoordinates">The use world coordinates</param>
            <returns>The joint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreateAngleJoint(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body)">
            <summary>
                Creates the angle joint using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <returns>The angle joint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreateGearJoint(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Joints.Joint,Alis.Core.Physic.Dynamics.Joints.Joint,System.Single)">
            <summary>
                Creates the gear joint using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="jointA">The joint</param>
            <param name="jointB">The joint</param>
            <param name="ratio">The ratio</param>
            <returns>The gear joint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreatePulleyJoint(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,System.Boolean)">
            <summary>
                Creates the pulley joint using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="anchorA">The anchor</param>
            <param name="anchorB">The anchor</param>
            <param name="worldAnchorA">The world anchor</param>
            <param name="worldAnchorB">The world anchor</param>
            <param name="ratio">The ratio</param>
            <param name="useWorldCoordinates">The use world coordinates</param>
            <returns>The pulley joint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreateFixedMouseJoint(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Creates the fixed mouse joint using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="body">The body</param>
            <param name="worldAnchor">The world anchor</param>
            <returns>The joint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreateRevoluteJoint(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>
                Creates the revolute joint using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="anchorA">The anchor</param>
            <param name="anchorB">The anchor</param>
            <param name="useWorldCoordinates">The use world coordinates</param>
            <returns>The joint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreateRevoluteJoint(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Creates the revolute joint using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="anchor">The anchor</param>
            <returns>The joint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreateWheelJoint(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>
                Creates the wheel joint using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="anchor">The anchor</param>
            <param name="axis">The axis</param>
            <param name="useWorldCoordinates">The use world coordinates</param>
            <returns>The joint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreateWheelJoint(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Creates the wheel joint using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="axis">The axis</param>
            <returns>The wheel joint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreateDistanceJoint(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>
                Creates the distance joint using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="anchorA">The anchor</param>
            <param name="anchorB">The anchor</param>
            <param name="useWorldCoordinates">The use world coordinates</param>
            <returns>The distance joint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreateDistanceJoint(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body)">
            <summary>
                Creates the distance joint using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <returns>The distance joint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreateFrictionJoint(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>
                Creates the friction joint using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <param name="anchor">The anchor</param>
            <param name="useWorldCoordinates">The use world coordinates</param>
            <returns>The friction joint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreateFrictionJoint(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Body,Alis.Core.Physic.Dynamics.Body)">
            <summary>
                Creates the friction joint using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="bodyA">The body</param>
            <param name="bodyB">The body</param>
            <returns>The friction joint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Factories.JointFactory.CreateFromDef(Alis.Core.Physic.World,Alis.Core.Physic.Dynamics.Joints.Joint)">
            <summary>
                Creates the from def using the specified world
            </summary>
            <param name="world">The world</param>
            <param name="def">The def</param>
            <returns>The joint</returns>
        </member>
        <member name="T:Alis.Core.Physic.Shared.Aabb">
            <summary>An axis aligned bounding box.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.Aabb.LowerBound">
            <summary>The lower vertex</summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.Aabb.UpperBound">
            <summary>The upper vertex</summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Aabb.#ctor(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Shared.Aabb" /> class
            </summary>
            <param name="min">The min</param>
            <param name="max">The max</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Aabb.#ctor(Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Shared.Aabb" /> class
            </summary>
            <param name="center">The center</param>
            <param name="width">The width</param>
            <param name="height">The height</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Aabb.#ctor(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Shared.Aabb" /> class
            </summary>
            <param name="min">The min</param>
            <param name="max">The max</param>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Aabb.Width">
            <summary>
                Gets the value of the width
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Aabb.Height">
            <summary>
                Gets the value of the height
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Aabb.Center">
            <summary>Get the center of the AABB.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Aabb.Extents">
            <summary>Get the extents of the AABB (half-widths).</summary>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Aabb.Perimeter">
            <summary>Get the perimeter length</summary>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Aabb.Vertices">
            <summary>Gets the vertices of the AABB.</summary>
            <value>The corners of the AABB</value>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Aabb.Q1">
            <summary>First quadrant</summary>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Aabb.Q2">
            <summary>Second quadrant</summary>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Aabb.Q3">
            <summary>Third quadrant</summary>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Aabb.Q4">
            <summary>Forth quadrant</summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Aabb.IsValid">
            <summary>Verify that the bounds are sorted. And the bounds are valid numbers (not NaN).</summary>
            <returns><c>true</c> if this instance is valid; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Aabb.Combine(Alis.Core.Physic.Shared.Aabb@)">
            <summary>Combine an AABB into this one.</summary>
            <param name="aabb">The AABB.</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Aabb.Combine(Alis.Core.Physic.Shared.Aabb@,Alis.Core.Physic.Shared.Aabb@)">
            <summary>Combine two AABBs into this one.</summary>
            <param name="aabb1">The aabb1.</param>
            <param name="aabb2">The aabb2.</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Aabb.Contains(Alis.Core.Physic.Shared.Aabb@)">
            <summary>Does this AABB contain the provided AABB.</summary>
            <param name="aabb">The AABB.</param>
            <returns><c>true</c> if it contains the specified AABB; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Aabb.Contains(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Determines whether the AABB contains the specified point.</summary>
            <param name="point">The point.</param>
            <returns><c>true</c> if it contains the specified point; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Aabb.TestOverlap(Alis.Core.Physic.Shared.Aabb@,Alis.Core.Physic.Shared.Aabb@)">
            <summary>Test if the two AABBs overlap.</summary>
            <param name="a">The first AABB.</param>
            <param name="b">The second AABB.</param>
            <returns>True if they are overlapping.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Aabb.RayCast(Alis.Core.Physic.Collision.RayCast.RayCastInput@,Alis.Core.Physic.Collision.RayCast.RayCastOutput@,System.Boolean)">
            <summary>Raycast against this AABB using the specified points and maxfraction (found in input)</summary>
            <param name="input">The parameters for the raycast.</param>
            <param name="output">The results of the raycast.</param>
            <param name="doInteriorCheck"></param>
            <returns>True if the ray intersects the AABB</returns>
        </member>
        <member name="T:Alis.Core.Physic.Shared.Contracts.Contract">
            <summary>
                The contract class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Contracts.Contract.RequireNotNull(System.Object,System.String)">
            <summary>
                Requires the not null using the specified obj
            </summary>
            <param name="obj">The obj</param>
            <param name="message">The message</param>
            <exception cref="T:Alis.Core.Physic.Shared.Contracts.RequiredException"></exception>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Contracts.Contract.Requires(System.Boolean,System.String)">
            <summary>
                Requireses the condition
            </summary>
            <param name="condition">The condition</param>
            <param name="message">The message</param>
            <exception cref="T:Alis.Core.Physic.Shared.Contracts.RequiredException"></exception>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Contracts.Contract.Warn(System.Boolean,System.String)">
            <summary>
                Warns the condition
            </summary>
            <param name="condition">The condition</param>
            <param name="message">The message</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Contracts.Contract.Ensures(System.Boolean,System.String)">
            <summary>
                Ensureses the condition
            </summary>
            <param name="condition">The condition</param>
            <param name="message">The message</param>
            <exception cref="T:Alis.Core.Physic.Shared.Contracts.EnsuresException"></exception>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Contracts.Contract.RequireForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
                Requires the for all using the specified value
            </summary>
            <typeparam name="T">The </typeparam>
            <param name="value">The value</param>
            <param name="check">The check</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Contracts.Contract.Fail(System.String)">
            <summary>
                Fails the message
            </summary>
            <param name="message">The message</param>
            <exception cref="T:Alis.Core.Physic.Shared.Contracts.RequiredException"></exception>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Contracts.Contract.BuildMessage(System.String,System.String)">
            <summary>
                Builds the message using the specified type
            </summary>
            <param name="type">The type</param>
            <param name="message">The message</param>
            <returns>The string</returns>
        </member>
        <member name="T:Alis.Core.Physic.Shared.Contracts.EnsuresException">
            <summary>
                The ensures exception class
            </summary>
            <seealso cref="T:System.Exception" />
        </member>
        <member name="M:Alis.Core.Physic.Shared.Contracts.EnsuresException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Shared.Contracts.EnsuresException" /> class
            </summary>
            <param name="message">The message</param>
        </member>
        <member name="T:Alis.Core.Physic.Shared.Contracts.RequiredException">
            <summary>
                The required exception class
            </summary>
            <seealso cref="T:System.Exception" />
        </member>
        <member name="M:Alis.Core.Physic.Shared.Contracts.RequiredException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Shared.Contracts.RequiredException" /> class
            </summary>
            <param name="message">The message</param>
        </member>
        <member name="T:Alis.Core.Physic.Shared.Graph`1">
            <summary>This graph is a doubly linked circular list. It is circular to avoid branches in Add/Remove methods.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.Graph`1.comparer">
            <summary>
                The comparer
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Graph`1.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Shared.Graph`1" /> class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Graph`1.#ctor(System.Collections.Generic.EqualityComparer{`0})">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Shared.Graph`1" /> class
            </summary>
            <param name="comparer">The comparer</param>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Graph`1.Count">
            <summary>The number of items in the graph</summary>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Graph`1.First">
            <summary>The first node in the graph</summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Graph`1.GetEnumerator">
            <summary>
                Gets the enumerator
            </summary>
            <returns>An enumerator of t</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Graph`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Gets the enumerator
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Graph`1.Add(`0)">
            <summary>Add a value to the graph</summary>
            <remarks>Note that this method is O(n) in worst case.</remarks>
            <returns>The node that represents the value</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Graph`1.Add(Alis.Core.Physic.Shared.GraphNode{`0})">
            <summary>Add a node to the graph</summary>
            <remarks>Note that this method is O(1) in worst case.</remarks>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Graph`1.Contains(`0)">
            <summary>Check if the specified value is contained within the graph.</summary>
            <remarks>Note that this method is O(n) in worst case.</remarks>
            <returns>True if it found the value, otherwise false.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Graph`1.Find(`0)">
            <summary>Finds the specified value</summary>
            <remarks>Note that this method is O(n) in worst case.</remarks>
            <returns>The graph node that was found if any. Otherwise it returns null.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Graph`1.Clear">
            <summary>
                Clears this instance
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Graph`1.Remove(`0)">
            <summary>Remove the specified value</summary>
            <remarks>Note that this method is O(n) in worst case.</remarks>
            <returns>True if the value was removed, otherwise false.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Graph`1.Remove(Alis.Core.Physic.Shared.GraphNode{`0})">
            <summary>Remove the specified node from the graph.</summary>
            <remarks>Note that this method is O(1) in worst case.</remarks>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Graph`1.GetNodes">
            <summary>
                Gets the nodes
            </summary>
            <returns>An enumerable of graph node t</returns>
        </member>
        <member name="T:Alis.Core.Physic.Shared.GraphNode`1">
            <summary>
                The graph node class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.GraphNode`1.#ctor(`0)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Shared.GraphNode`1" /> class
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="P:Alis.Core.Physic.Shared.GraphNode`1.Item">
            <summary>The item.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Shared.GraphNode`1.Next">
            <summary>The next item in the list.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Shared.GraphNode`1.Prev">
            <summary>The previous item in the list.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.GraphNode`1.Invalidate">
            <summary>
                Invalidates this instance
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.GraphNode`1.Clear">
            <summary>
                Clears this instance
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Shared.Optimization.FixedArray2`1">
            <summary>
                The fixed array
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.Optimization.FixedArray2`1.Value0">
            <summary>
                The value
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.Optimization.FixedArray2`1.Value1">
            <summary>
                The value
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Optimization.FixedArray2`1.Item(System.Int32)">
            <summary>
                The index
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Optimization.FixedArray2`1.GetEnumerator">
            <summary>
                Gets the enumerator
            </summary>
            <returns>An enumerator of t</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Optimization.FixedArray2`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Gets the enumerator
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Optimization.FixedArray2`1.IndexOf(`0)">
            <summary>
                Indexes the of using the specified value
            </summary>
            <param name="value">The value</param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Optimization.FixedArray2`1.Clear">
            <summary>
                Clears this instance
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Optimization.FixedArray2`1.Enumerate">
            <summary>
                Enumerates this instance
            </summary>
            <returns>An enumerable of t</returns>
        </member>
        <member name="T:Alis.Core.Physic.Shared.Optimization.FixedArray3`1">
            <summary>
                The fixed array
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.Optimization.FixedArray3`1.Value0">
            <summary>
                The value
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.Optimization.FixedArray3`1.Value1">
            <summary>
                The value
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.Optimization.FixedArray3`1.Value2">
            <summary>
                The value
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Optimization.FixedArray3`1.Item(System.Int32)">
            <summary>
                The index
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Optimization.FixedArray3`1.GetEnumerator">
            <summary>
                Gets the enumerator
            </summary>
            <returns>An enumerator of t</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Optimization.FixedArray3`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Gets the enumerator
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Optimization.FixedArray3`1.IndexOf(`0)">
            <summary>
                Indexes the of using the specified value
            </summary>
            <param name="value">The value</param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Optimization.FixedArray3`1.Clear">
            <summary>
                Clears this instance
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Optimization.FixedArray3`1.Enumerate">
            <summary>
                Enumerates this instance
            </summary>
            <returns>An enumerable of t</returns>
        </member>
        <member name="T:Alis.Core.Physic.Shared.Optimization.IPoolable`1">
            <summary>
                The poolable interface
            </summary>
            <seealso cref="T:System.IDisposable" />
        </member>
        <member name="M:Alis.Core.Physic.Shared.Optimization.IPoolable`1.Reset">
            <summary>
                Resets this instance
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Shared.PolygonError">
            <summary>
                The polygon error enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.PolygonError.NoError">
            <summary>There were no errors in the polygon</summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.PolygonError.InvalidAmountOfVertices">
            <summary>Polygon must have between 3 and Settings.MaxPolygonVertices vertices.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.PolygonError.NotSimple">
            <summary>Polygon must be simple. This means no overlapping edges.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.PolygonError.NotCounterClockWise">
            <summary>Polygon must have a counter clockwise winding.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.PolygonError.NotConvex">
            <summary>The polygon is concave, it needs to be convex.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.PolygonError.AreaTooSmall">
            <summary>Polygon area is too small.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.PolygonError.SideTooSmall">
            <summary>The polygon has a side that is too short.</summary>
        </member>
        <member name="T:Alis.Core.Physic.Shared.Pool`1">
            <summary>
                The pool class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.Pool`1.objectCreator">
            <summary>
                The object creator
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.Pool`1.objectReset">
            <summary>
                The object reset
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Shared.Pool`1.queue">
            <summary>
                The queue
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Pool`1.#ctor(System.Func{`0},System.Action{`0},System.Int32,System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Shared.Pool`1" /> class
            </summary>
            <param name="objectCreator">The object creator</param>
            <param name="objectReset">The object reset</param>
            <param name="capacity">The capacity</param>
            <param name="preCreateInstances">The pre create instances</param>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Pool`1.LeftInPool">
            <summary>
                Gets the value of the left in pool
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Pool`1.GetFromPool(System.Boolean)">
            <summary>
                Gets the from pool using the specified reset
            </summary>
            <param name="reset">The reset</param>
            <returns>The obj</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Pool`1.GetManyFromPool(System.Int32)">
            <summary>
                Gets the many from pool using the specified count
            </summary>
            <param name="count">The count</param>
            <returns>An enumerable of t</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Pool`1.ReturnToPool(`0,System.Boolean)">
            <summary>
                Returns the to pool using the specified obj
            </summary>
            <param name="obj">The obj</param>
            <param name="reset">The reset</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Pool`1.ReturnToPool(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
                Returns the to pool using the specified objs
            </summary>
            <param name="objs">The objs</param>
            <param name="reset">The reset</param>
        </member>
        <member name="T:Alis.Core.Physic.Shared.Vertices">
            <summary>
                The vertices class
            </summary>
            <seealso cref="T:System.Collections.Generic.List`1" />
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Shared.Vertices" /> class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.#ctor(System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Shared.Vertices" /> class
            </summary>
            <param name="capacity">The capacity</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.#ctor(System.Collections.Generic.IEnumerable{Alis.Core.Aspect.Math.Vector.Vector2F})">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Shared.Vertices" /> class
            </summary>
            <param name="vertices">The vertices</param>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Vertices.AttachedToBody">
            <summary>
                Gets or sets the value of the attached to body
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Shared.Vertices.Holes">
            <summary>
                You can add holes to this collection. It will get respected by some of the triangulation algoithms, but
                otherwise not used.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.NextIndex(System.Int32)">
            <summary>Gets the next index. Used for iterating all the edges with wrap-around.</summary>
            <param name="index">The current index</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.NextVertex(System.Int32)">
            <summary>Gets the next vertex. Used for iterating all the edges with wrap-around.</summary>
            <param name="index">The current index</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.PreviousIndex(System.Int32)">
            <summary>Gets the previous index. Used for iterating all the edges with wrap-around.</summary>
            <param name="index">The current index</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.PreviousVertex(System.Int32)">
            <summary>Gets the previous vertex. Used for iterating all the edges with wrap-around.</summary>
            <param name="index">The current index</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.GetSignedArea">
            <summary>Gets the signed area. If the area is less than 0, it indicates that the polygon is clockwise winded.</summary>
            <returns>The signed area</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.GetArea">
            <summary>Gets the area.</summary>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.GetCentroid">
            <summary>Gets the centroid.</summary>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.GetAabb">
            <summary>Returns an AABB that fully contains this polygon.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.Translate(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Translates the vertices with the specified vector.</summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.Translate(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Translates the vertices with the specified vector.</summary>
            <param name="value">The vector.</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.Scale(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Scales the vertices with the specified vector.</summary>
            <param name="value">The Value.</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.Scale(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Scales the vertices with the specified vector.</summary>
            <param name="value">The Value.</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.Rotate(System.Single)">
            <summary>
                Rotate the vertices with the defined value in radians. Warning: Using this method on an active set of vertices
                of a Body, will cause problems with collisions. Use Body.Rotation instead.
            </summary>
            <param name="value">The amount to rotate by in radians.</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.IsConvex">
            <summary>
                Determines whether the polygon is convex. O(n^2) running time. Assumptions: - The polygon is in counter
                clockwise order - The polygon has no overlapping edges
            </summary>
            <returns><c>true</c> if it is convex; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.IsCounterClockWise">
            <summary>
                Indicates if the vertices are in counter clockwise order. Warning: If the area of the polygon is 0, it is
                unable to determine the winding.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.ForceCounterClockWise">
            <summary>Forces the vertices to be counter clock wise order.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.IsSimple">
            <summary>Checks if the vertices forms an simple polygon by checking for edge crossings.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.CheckPolygon">
            <summary>
                Checks if the polygon is valid for use in the engine. Performs a full check, for simplicity, convexity,
                orientation, minimum angle, and volume. From Eric Jordan's convex decomposition library
            </summary>
            <returns>PolygonError.NoError if there were no error.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.ProjectToAxis(Alis.Core.Aspect.Math.Vector.Vector2F@,System.Single@,System.Single@)">
            <summary>Projects to axis.</summary>
            <param name="axis">The axis.</param>
            <param name="min">The min.</param>
            <param name="max">The max.</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.PointInPolygon(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Winding number test for a point in a polygon.</summary>
            See more info about the algorithm here: http://softsurfer.com/Archive/algorithm_0103/algorithm_0103.htm
            <param name="point">The point to be tested.</param>
            <returns>
                -1 if the winding number is zero and the point is outside the polygon, 1 if the point is inside the polygon,
                and 0 if the point is on the polygons edge.
            </returns>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.PointInPolygonAngle(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Compute the sum of the angles made between the test point and each pair of points making up the polygon. If
                this sum is 2pi then the point is an interior point, if 0 then the point is an exterior point. ref:
                http://ozviz.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/  - Solution 2
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.Transform(Alis.Core.Aspect.Math.Matrix.Matrix4X4F@)">
            <summary>Transforms the polygon using the defined matrix.</summary>
            <param name="transform">The matrix to use as transformation.</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.Transform(Alis.Core.Aspect.Math.Vector.Vector2F[],Alis.Core.Aspect.Math.Matrix.Matrix4X4F@,Alis.Core.Aspect.Math.Vector.Vector2F[])">
            <summary>
                Transforms the source array
            </summary>
            <param name="sourceArray">The source array</param>
            <param name="matrix">The matrix</param>
            <param name="destinationArray">The destination array</param>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.Transform(Alis.Core.Aspect.Math.Vector.Vector2F[],System.Int32,Alis.Core.Aspect.Math.Matrix.Matrix4X4F@,Alis.Core.Aspect.Math.Vector.Vector2F[],System.Int32,System.Int32)">
            <summary>
                Transforms the source array
            </summary>
            <param name="sourceArray">The source array</param>
            <param name="sourceIndex">The source index</param>
            <param name="matrix">The matrix</param>
            <param name="destinationArray">The destination array</param>
            <param name="destinationIndex">The destination index</param>
            <param name="length">The length</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Destination array length is lesser than destinationIndex + length</exception>
            <exception cref="T:System.ArgumentException">Source array length is lesser than sourceIndex + length</exception>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.FlipHorizontally">
            <summary>
                Flips the horizontally
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.FlipVertically">
            <summary>
                Flips the vertically
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Shared.Vertices.ToString">
            <summary>
                Returns the string
            </summary>
            <returns>The string</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.ConvexHull.ChainHull">
            <summary>
                Andrew's Monotone Chain Convex Hull algorithm. Used to get the convex hull of a point cloud.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.ConvexHull.ChainHull.PointComparerPrivate">
            <summary>
                The point comparer
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.ConvexHull.ChainHull.GetConvexHull(Alis.Core.Physic.Shared.Vertices)">
            <summary>Returns the convex hull from the given vertices..</summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.ConvexHull.GiftWrap">
            <summary>
                Giftwrap convex hull algorithm. O(n * h) time complexity, where n is the number of points and h is the number
                of points on the convex hull. See http://en.wikipedia.org/wiki/Gift_wrapping_algorithm for more details.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.ConvexHull.GiftWrap.GetConvexHull(Alis.Core.Physic.Shared.Vertices)">
            <summary>Returns the convex hull from the given vertices.</summary>
            <param name="vertices">The vertices.</param>
        </member>
        <member name="T:Alis.Core.Physic.Tools.ConvexHull.Melkman">
            <summary>
                Creates a convex hull.
                Note:
                1. Vertices must be of a simple polygon, i.e. edges do not overlap.
                2. Melkman does not work on point clouds
            </summary>
            <remarks>
                Implemented using Melkman's Convex Hull Algorithm - O(n) time complexity.
                Reference: http://www.ams.sunysb.edu/~jsbm/courses/345/melkman.pdf
            </remarks>
        </member>
        <member name="M:Alis.Core.Physic.Tools.ConvexHull.Melkman.GetConvexHull(Alis.Core.Physic.Shared.Vertices)">
            <summary>Returns a convex hull from the given vertices.</summary>
            <returns>A convex hull in counter clockwise winding order.</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.ConvexHull.PointComparer">
            <summary>
                The point comparer class
            </summary>
            <seealso cref="T:System.Collections.Generic.Comparer`1" />
        </member>
        <member name="M:Alis.Core.Physic.Tools.ConvexHull.PointComparer.Compare(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Compares the a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <returns>The int</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Cutting.Simple.PolyClipError">
            <summary>
                The poly clip error enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Cutting.Simple.PolyClipError.None">
            <summary>
                The none poly clip error
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Cutting.Simple.PolyClipError.DegeneratedOutput">
            <summary>
                The degenerated output poly clip error
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Cutting.Simple.PolyClipError.NonSimpleInput">
            <summary>
                The non simple input poly clip error
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Cutting.Simple.PolyClipError.BrokenResult">
            <summary>
                The broken result poly clip error
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Cutting.Simple.PolyClipType">
            <summary>
                The poly clip type enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Cutting.Simple.PolyClipType.Intersect">
            <summary>
                The intersect poly clip type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Cutting.Simple.PolyClipType.Union">
            <summary>
                The union poly clip type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Cutting.Simple.PolyClipType.Difference">
            <summary>
                The difference poly clip type
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Cutting.YuPengClipper">
            <summary>
                The yu peng clipper class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Cutting.YuPengClipper.ClipperEpsilonSquared">
            <summary>
                The clipper epsilon squared
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.Union(Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Tools.Cutting.Simple.PolyClipError@)">
            <summary>
                Unions the polygon 1
            </summary>
            <param name="polygon1">The polygon</param>
            <param name="polygon2">The polygon</param>
            <param name="error">The error</param>
            <returns>A list of vertices</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.Difference(Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Tools.Cutting.Simple.PolyClipError@)">
            <summary>
                Differences the polygon 1
            </summary>
            <param name="polygon1">The polygon</param>
            <param name="polygon2">The polygon</param>
            <param name="error">The error</param>
            <returns>A list of vertices</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.Intersect(Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Tools.Cutting.Simple.PolyClipError@)">
            <summary>
                Intersects the polygon 1
            </summary>
            <param name="polygon1">The polygon</param>
            <param name="polygon2">The polygon</param>
            <param name="error">The error</param>
            <returns>A list of vertices</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.Execute(Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Tools.Cutting.Simple.PolyClipType,Alis.Core.Physic.Tools.Cutting.Simple.PolyClipError@)">
            <summary>
                Implements "A new algorithm for Boolean operations on general polygons" available here:
                http://liama.ia.ac.cn/wiki/_media/user:dong:dong_cg_05.pdf Merges two polygons, a subject and a clip with the
                specified
                operation. Polygons may not be self-intersecting. Warning: May yield incorrect results or even crash if polygons
                contain collinear points.
            </summary>
            <param name="subject">The subject polygon.</param>
            <param name="clip">The clip polygon, which is added, substracted or intersected with the subject</param>
            <param name="clipType">The operation to be performed. Either Union, Difference or Intersection.</param>
            <param name="error">The error generated (if any)</param>
            <returns>
                A list of closed polygons, which make up the result of the clipping operation. Outer contours are ordered
                counter clockwise, holes are ordered clockwise.
            </returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.CalculateIntersections(Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Shared.Vertices@,Alis.Core.Physic.Shared.Vertices@)">
            <summary>Calculates all intersections between two polygons.</summary>
            <param name="polygon1">The first polygon.</param>
            <param name="polygon2">The second polygon.</param>
            <param name="slicedPoly1">Returns the first polygon with added intersection points.</param>
            <param name="slicedPoly2">Returns the second polygon with added intersection points.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.CalculateSimplicalChain(Alis.Core.Physic.Shared.Vertices,System.Collections.Generic.List{System.Single}@,System.Collections.Generic.List{Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge}@)">
            <summary>Calculates the simplical chain corresponding to the input polygon.</summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.CalculateResultChain(System.Collections.Generic.List{System.Single},System.Collections.Generic.List{Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge},System.Collections.Generic.List{System.Single},System.Collections.Generic.List{Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge},Alis.Core.Physic.Tools.Cutting.Simple.PolyClipType,System.Collections.Generic.List{Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge}@)">
            <summary>
                Calculates the characteristics function for all edges of the given simplical chains and builds the result
                chain.
            </summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.BuildPolygonsFromChain(System.Collections.Generic.List{Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge},System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices}@)">
            <summary>Calculates the polygon(s) from the result simplical chain.</summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.CalculateBeta(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge,System.Single)">
            <summary>Needed to calculate the characteristics function of a simplex.</summary>
            <remarks>Used by method <c>CalculateEdgeCharacter()</c>.</remarks>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.GetAlpha(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Needed for sorting multiple intersections points on the same edge.</summary>
            <remarks>Used by method <c>CalculateIntersections()</c>.</remarks>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.CalculateSimplexCoefficient(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Returns the coefficient of a simplex.</summary>
            <remarks>Used by method <c>CalculateSimplicalChain()</c>.</remarks>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.PointInSimplex(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge)">
            <summary>Winding number test for a point in a simplex.</summary>
            <param name="point">The point to be tested.</param>
            <param name="edge">The edge that the point is tested against.</param>
            <returns>False if the winding number is even and the point is outside the simplex and True otherwise.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.PointOnLineSegment(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Tests if a point lies on a line segment.</summary>
            <remarks>Used by method <c>CalculateBeta()</c>.</remarks>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.VectorEqual(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Describes whether vector equal
            </summary>
            <param name="vec1">The vec</param>
            <param name="vec2">The vec</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge">
            <summary>Specifies an Edge. Edges are used to represent simplicies in simplical chains</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge.#ctor(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge" /> class
            </summary>
            <param name="edgeStart">The edge start</param>
            <param name="edgeEnd">The edge end</param>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge.EdgeStart">
            <summary>
                Gets or sets the value of the edge start
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge.EdgeEnd">
            <summary>
                Gets or sets the value of the edge end
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge.GetCenter">
            <summary>
                Gets the center
            </summary>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge.Equals(System.Object)">
            <summary>
                Describes whether this instance equals
            </summary>
            <param name="obj">The obj</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge.Equals(Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge)">
            <summary>
                Describes whether this instance equals
            </summary>
            <param name="e">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Cutting.YuPengClipper.Edge.GetHashCode">
            <summary>
                Gets the hash code
            </summary>
            <returns>The int</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.PathGenerator.LinkFactory">
            <summary>
                The link factory class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.LinkFactory.CreateChain(Alis.Core.Physic.World,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,System.Single,System.Int32,System.Single,System.Boolean)">
            <summary>Creates a chain.</summary>
            <param name="world">The world.</param>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
            <param name="linkWidth">The width.</param>
            <param name="linkHeight">The height.</param>
            <param name="numberOfLinks">The number of links.</param>
            <param name="linkDensity">The link density.</param>
            <param name="attachRopeJoint">
                Creates a rope joint between start and end. This enforces the length of the rope. Said in
                another way: it makes the rope less bouncy.
            </param>
        </member>
        <member name="T:Alis.Core.Physic.Tools.PathGenerator.Path">
            <summary>
                Path: Very similar to Vertices, but this class contains vectors describing control points on a Catmull-Rom
                curve.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.PathGenerator.Path.ControlPoints">
            <summary>All the points that makes up the curve</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.PathGenerator.Path.deltaT">
            <summary>
                The delta
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.PathGenerator.Path" /> class.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.#ctor(Alis.Core.Aspect.Math.Vector.Vector2F[])">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.PathGenerator.Path" /> class.</summary>
            <param name="vertices">The vertices to created the path from.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.#ctor(System.Collections.Generic.IList{Alis.Core.Aspect.Math.Vector.Vector2F})">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.PathGenerator.Path" /> class.</summary>
            <param name="vertices">The vertices to created the path from.</param>
        </member>
        <member name="P:Alis.Core.Physic.Tools.PathGenerator.Path.Closed">
            <summary>True if the curve is closed.</summary>
            <value><c>true</c> if closed; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.NextIndex(System.Int32)">
            <summary>Gets the next index of a controlpoint</summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.PreviousIndex(System.Int32)">
            <summary>Gets the previous index of a controlpoint</summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.Translate(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Translates the control points by the specified vector.</summary>
            <param name="vector">The vector.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.Scale(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Scales the control points by the specified vector.</summary>
            <param name="value">The Value.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.Rotate(System.Single)">
            <summary>Rotate the control points by the defined value in radians.</summary>
            <param name="value">The amount to rotate by in radians.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.ToString">
            <summary>
                Returns the string
            </summary>
            <returns>The string</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.GetVertices(System.Int32)">
            <summary>Returns a set of points defining the curve with the specifed number of divisions between each control point.</summary>
            <param name="divisions">Number of divisions between each control point.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.GetPosition(System.Single)">
            <summary>
                Gets the position using the specified time
            </summary>
            <param name="time">The time</param>
            <exception cref="T:System.Exception">You need at least 2 control points to calculate a position.</exception>
            <returns>The temp</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.CatmullRom(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single)">
            <summary>
                Catmulls the rom using the specified value 1
            </summary>
            <param name="value1">The value</param>
            <param name="value2">The value</param>
            <param name="value3">The value</param>
            <param name="value4">The value</param>
            <param name="amount">The amount</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.GetPositionNormal(System.Single)">
            <summary>Gets the normal for the given time.</summary>
            <param name="time">The time</param>
            <returns>The normal.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.Add(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Adds the point
            </summary>
            <param name="point">The point</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.Remove(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Removes the point
            </summary>
            <param name="point">The point</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.RemoveAt(System.Int32)">
            <summary>
                Removes the at using the specified index
            </summary>
            <param name="index">The index</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.GetLength">
            <summary>
                Gets the length
            </summary>
            <returns>The length</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.Path.SubdivideEvenly(System.Int32)">
            <summary>
                Subdivides the evenly using the specified divisions
            </summary>
            <param name="divisions">The divisions</param>
            <returns>The verts</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.PathGenerator.PathManager">
            <summary>An easy to use manager for creating paths.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.PathManager.ConvertPathToEdges(Alis.Core.Physic.Tools.PathGenerator.Path,Alis.Core.Physic.Dynamics.Body,System.Int32)">
            <summary>Convert a path into a set of edges and attaches them to the specified body. Note: use only for static edges.</summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="subdivisions">The subdivisions.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.PathManager.ConvertPathToPolygon(Alis.Core.Physic.Tools.PathGenerator.Path,Alis.Core.Physic.Dynamics.Body,System.Single,System.Int32)">
            <summary>Convert a closed path into a polygon. Convex decomposition is automatically performed.</summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="density">The density.</param>
            <param name="subdivisions">The subdivisions.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.PathManager.EvenlyDistributeShapesAlongPath(Alis.Core.Physic.World,Alis.Core.Physic.Tools.PathGenerator.Path,System.Collections.Generic.IEnumerable{Alis.Core.Physic.Collision.Shapes.Shape},Alis.Core.Physic.Dynamics.BodyType,System.Int32,System.Object)">
            <summary>Duplicates the given Body along the given path for approximately the given copies.</summary>
            <param name="world">The world.</param>
            <param name="path">The path.</param>
            <param name="shapes">The shapes.</param>
            <param name="type">The type.</param>
            <param name="copies">The copies.</param>
            <param name="userData"></param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.PathManager.EvenlyDistributeShapesAlongPath(Alis.Core.Physic.World,Alis.Core.Physic.Tools.PathGenerator.Path,Alis.Core.Physic.Collision.Shapes.Shape,Alis.Core.Physic.Dynamics.BodyType,System.Int32,System.Object)">
            <summary>Duplicates the given Body along the given path for approximately the given copies.</summary>
            <param name="world">The world.</param>
            <param name="path">The path.</param>
            <param name="shape">The shape.</param>
            <param name="type">The type.</param>
            <param name="copies">The copies.</param>
            <param name="userData">The user data.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.PathManager.MoveBodyOnPath(Alis.Core.Physic.Tools.PathGenerator.Path,Alis.Core.Physic.Dynamics.Body,System.Single,System.Single,System.Single)">
            <summary>Moves the given body along the defined path.</summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="time">The time.</param>
            <param name="strength">The strength.</param>
            <param name="timeStep">The time step.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PathGenerator.PathManager.AttachBodiesWithRevoluteJoint(Alis.Core.Physic.World,System.Collections.Generic.List{Alis.Core.Physic.Dynamics.Body},Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean,System.Boolean)">
            <summary>Attaches the bodies with revolute joints.</summary>
            <param name="world">The world.</param>
            <param name="bodies">The bodies.</param>
            <param name="localAnchorA">The local anchor A.</param>
            <param name="localAnchorB">The local anchor B.</param>
            <param name="connectFirstAndLast">if set to <c>true</c> [connect first and last].</param>
            <param name="collideConnected">if set to <c>true</c> [collide connected].</param>
        </member>
        <member name="T:Alis.Core.Physic.Tools.PolygonManipulation.SimpleCombiner">
            <summary>
                Combines a list of triangles into a list of convex polygons. Starts with a seed triangle, keep adding
                triangles to it until you can't add any more without making the polygon non-convex.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PolygonManipulation.SimpleCombiner.PolygonizeTriangles(System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices},System.Int32,System.Single)">
            <summary>Combine a list of triangles into a list of convex polygons. Note: This only works on triangles.</summary>
            <param name="triangles">The triangles.</param>
            <param name="maxPolys">The maximun number of polygons to return.</param>
            <param name="tolerance">The tolerance</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PolygonManipulation.SimpleCombiner.AddTriangle(Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Adds the triangle using the specified t
            </summary>
            <param name="t">The </param>
            <param name="vertices">The vertices</param>
            <returns>The result</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.PolygonManipulation.SimplifyTools">
            <summary>Provides a set of tools to simplify polygons in various ways.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PolygonManipulation.SimplifyTools.CollinearSimplify(Alis.Core.Physic.Shared.Vertices,System.Single)">
            <summary>Removes all collinear points on the polygon.</summary>
            <param name="vertices">The polygon that needs simplification.</param>
            <param name="collinearityTolerance">The collinearity tolerance.</param>
            <returns>A simplified polygon.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PolygonManipulation.SimplifyTools.DouglasPeuckerSimplify(Alis.Core.Physic.Shared.Vertices,System.Single)">
            <summary>
                Ramer-Douglas-Peucker polygon simplification algorithm. This is the general recursive version that does not
                use the speed-up technique by using the Melkman convex hull. If you pass in 0, it will remove all collinear points.
            </summary>
            <returns>The simplified polygon</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PolygonManipulation.SimplifyTools.SimplifySection(Alis.Core.Physic.Shared.Vertices,System.Int32,System.Int32,System.Boolean[],System.Single)">
            <summary>
                Simplifies the section using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <param name="i">The </param>
            <param name="j">The </param>
            <param name="usePoint">The use point</param>
            <param name="distanceTolerance">The distance tolerance</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PolygonManipulation.SimplifyTools.MergeParallelEdges(Alis.Core.Physic.Shared.Vertices,System.Single)">
            <summary>Merges all parallel edges in the list of vertices</summary>
            <param name="vertices">The vertices.</param>
            <param name="tolerance">The tolerance.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PolygonManipulation.SimplifyTools.MergeIdenticalPoints(Alis.Core.Physic.Shared.Vertices)">
            <summary>Merges the identical points in the polygon.</summary>
            <param name="vertices">The vertices.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PolygonManipulation.SimplifyTools.ReduceByDistance(Alis.Core.Physic.Shared.Vertices,System.Single)">
            <summary>Reduces the polygon by distance.</summary>
            <param name="vertices">The vertices.</param>
            <param name="distance">The distance between points. Points closer than this will be removed.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PolygonManipulation.SimplifyTools.ReduceByNth(Alis.Core.Physic.Shared.Vertices,System.Int32)">
            <summary>Reduces the polygon by removing the Nth vertex in the vertices list.</summary>
            <param name="vertices">The vertices.</param>
            <param name="nth">The Nth point to remove. Example: 5.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.PolygonManipulation.SimplifyTools.ReduceByArea(Alis.Core.Physic.Shared.Vertices,System.Single)">
            <summary>
                Simplify the polygon by removing all points that in pairs of 3 have an area less than the tolerance. Pass in 0
                as tolerance, and it will only remove collinear points.
            </summary>
            <param name="vertices"></param>
            <param name="areaTolerance"></param>
            <returns></returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.TextureTools.MarchingSquares">
            <summary>
                The marching squares class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.LookMarch">
            <summary>
                Linearly interpolate between (x0 to x1) given a value at these coordinates (v0 and v1) such as to approximate
                value(return) = 0
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.DetectSquares(Alis.Core.Physic.Shared.Aabb,System.Single,System.Single,System.SByte[0:,0:],System.Int32,System.Boolean)">
            <summary>
                Marching squares over the given domain using the mesh defined via the dimensions (wid,hei) to build a set of
                polygons such that f(x,y) less than 0, using the given number 'bin' for recursive linear inteprolation along cell
                boundaries. if 'comb' is true, then the polygons will also be composited into larger possible concave polygons.
            </summary>
            <param name="domain"></param>
            <param name="cellWidth"></param>
            <param name="cellHeight"></param>
            <param name="f"></param>
            <param name="lerpCount"></param>
            <param name="combine"></param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.Lerp(System.Single,System.Single,System.Single,System.Single)">
            <summary>
                Lerps the x 0
            </summary>
            <param name="x0">The </param>
            <param name="x1">The </param>
            <param name="v0">The </param>
            <param name="v1">The </param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.Xlerp(System.Single,System.Single,System.Single,System.Single,System.Single,System.SByte[0:,0:],System.Int32)">
            <summary>Recursive linear interpolation for use in marching squares</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.Ylerp(System.Single,System.Single,System.Single,System.Single,System.Single,System.SByte[0:,0:],System.Int32)">
            <summary>Recursive linear interpolation for use in marching squares</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.Square(System.Single)">
            <summary>Square value for use in marching squares</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.VecDsq(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Vecs the dsq using the specified a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.VecCross(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Vecs the cross using the specified a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.MarchSquare(System.SByte[0:,0:],System.SByte[0:,0:],Alis.Core.Physic.Tools.TextureTools.MarchingSquares.GeomPoly@,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
                Look-up table to relate polygon key with the vertices that should be used for the sub polygon in marching
                squares Perform a single celled marching square for for the given cell defined by (x0,y0) (x1,y1) using the
                function f
                for recursive interpolation, given the look-up table 'fs' of the values of 'f' at cell vertices with the result to
                be
                stored in 'poly' given the actual coordinates of 'ax' 'ay' in the marching squares mesh.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CombLeft(Alis.Core.Physic.Tools.TextureTools.MarchingSquares.GeomPoly@,Alis.Core.Physic.Tools.TextureTools.MarchingSquares.GeomPoly@)">
            <summary>
                Used in polygon composition to composit polygons into scan lines Combining polya and polyb into one
                super-polygon stored in polya.
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1">
            <summary>Designed as a complete port of CxFastList from CxStd.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1.head">
            <summary>
                The head
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1.Begin">
            <summary>Iterator to start of list (O(1))</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1.End">
            <summary>Iterator to end of list (O(1))</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1.Front">
            <summary>Returns first element of list (O(1))</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1.Add(`0)">
            <summary>add object to list (O(1))</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1.Remove(`0)">
            <summary>remove object from list, returns true if an element was removed (O(n))</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1.Pop">
            <summary>
                pop element from head of list (O(1)) Note: this does not return the object popped! There is good reason to
                this, and it regards the Alloc list variants which guarantee objects are released to the object pool. You do not
                want
                to retrieve an element through pop or else that object may suddenly be used by another piece of code which
                retrieves it
                from the object pool.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1.Insert(Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastListNode{`0},`0)">
            <summary>insert object after 'node' returning an iterator to the inserted object.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1.Erase(Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastListNode{`0},Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastListNode{`0})">
            <summary>
                removes the element pointed to by 'node' with 'prev' being the previous iterator, returning an iterator to the
                element following that of 'node' (O(1))
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1.Empty">
            <summary>whether the list is empty (O(1))</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1.Size">
            <summary>computes size of list (O(n))</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1.Clear">
            <summary>empty the list (O(1) if CxMixList, O(n) otherwise)</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1.Has(`0)">
            <summary>returns true if 'value' is an element of the list (O(n))</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1.Find(`0)">
            <summary>
                Finds the value
            </summary>
            <param name="value">The value</param>
            <returns>A cx fast list node of t</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastList`1.GetListOfElements">
            <summary>
                Gets the list of elements
            </summary>
            <returns>The list</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastListNode`1">
            <summary>
                The cx fast list node class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastListNode`1.#ctor(`0)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastListNode`1" /> class
            </summary>
            <param name="obj">The obj</param>
        </member>
        <member name="P:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastListNode`1.Elt">
            <summary>
                The elt
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastListNode`1.Next">
            <summary>
                The next
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastListNode`1.GetElem">
            <summary>
                Elems this instance
            </summary>
            <returns>The elt</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.CxFastListNode`1.GetNext">
            <summary>
                Nexts this instance
            </summary>
            <returns>The next</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.GeomPoly">
            <summary>
                The geom poly class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.GeomPoly.Length">
            <summary>
                The length
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.GeomPoly.Points">
            <summary>
                The points
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.GeomPoly.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.GeomPoly" /> class
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.GeomPolyVal">
            <summary>
                The geom poly val class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.GeomPolyVal.Key">
            Associated polygon at coordinate *
            Key of original sub-polygon *
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.GeomPolyVal.GeomP">
            <summary>
                The geom
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.GeomPolyVal.#ctor(Alis.Core.Physic.Tools.TextureTools.MarchingSquares.GeomPoly,System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.TextureTools.MarchingSquares.GeomPolyVal" /> class
            </summary>
            <param name="geomP">The geom</param>
            <param name="k">The </param>
        </member>
        <member name="T:Alis.Core.Physic.Tools.TextureTools.Terrain">
            <summary>Simple class to maintain a terrain. It can keep track</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.bodyMap">
            <summary>Generated bodies.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.CellSize">
            <summary>Points per cell.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.Center">
            <summary>Center of terrain in world units.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.Decomposer">
            <summary>
                Decomposer to use when regenerating terrain. Can be changed on the fly without consequence. Note: Some
                decomposerers are unstable.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.dirtyArea">
            <summary>
                The dirty area
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.Height">
            <summary>Height of terrain in world units.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.Iterations">
            <summary>
                Number of iterations to perform in the Marching Squares algorithm. Note: More then 3 has almost no effect on
                quality.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.localHeight">
            <summary>
                The local height
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.localWidth">
            <summary>
                The local width
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.PointsPerUnit">
            <summary>Points per each world unit used to define the terrain in the point cloud.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.SubCellSize">
            <summary>Points per sub cell.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.terrainMap">
            <summary>Point cloud defining the terrain.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.topLeft">
            <summary>
                The top left
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.Width">
            <summary>Width of terrain in world units.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.World">
            <summary>World to manage terrain in.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.xnum">
            <summary>
                The xnum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.Terrain.ynum">
            <summary>
                The ynum
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.Terrain.#ctor(Alis.Core.Physic.World,Alis.Core.Physic.Shared.Aabb)">
            <summary>Creates a new terrain.</summary>
            <param name="world">The World</param>
            <param name="area">The area of the terrain.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.Terrain.#ctor(Alis.Core.Physic.World,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single,System.Single)">
            <summary>Creates a new terrain</summary>
            <param name="world">The World</param>
            <param name="position">The position (center) of the terrain.</param>
            <param name="width">The width of the terrain.</param>
            <param name="height">The height of the terrain.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.Terrain.Initialize">
            <summary>Initialize the terrain for use.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.Terrain.ApplyData(System.SByte[0:,0:],Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Apply the specified texture data to the terrain.</summary>
            <param name="data"></param>
            <param name="offset"></param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.Terrain.ModifyTerrain(Alis.Core.Aspect.Math.Vector.Vector2F,System.SByte)">
            <summary>Modify a single point in the terrain.</summary>
            <param name="location">World location to modify. Automatically clipped.</param>
            <param name="value">-1 = inside terrain, 1 = outside terrain</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.Terrain.RegenerateTerrain">
            <summary>Regenerate the terrain.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.Terrain.RemoveOldData(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                Removes the old data using the specified x start
            </summary>
            <param name="xStart">The start</param>
            <param name="xEnd">The end</param>
            <param name="yStart">The start</param>
            <param name="yEnd">The end</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.Terrain.GenerateTerrain(System.Int32,System.Int32)">
            <summary>
                Generates the terrain using the specified gx
            </summary>
            <param name="gx">The gx</param>
            <param name="gy">The gy</param>
        </member>
        <member name="T:Alis.Core.Physic.Tools.TextureTools.TextureConverter">
            <summary>
                The texture converter class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.TextureConverter.alphaTolerance">
            <summary>
                The alpha tolerance
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.TextureConverter.data">
            <summary>
                The data
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.TextureConverter.dataLength">
            <summary>
                The data length
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.TextureConverter.height">
            <summary>
                The height
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.TextureConverter.holeDetection">
            <summary>
                The hole detection
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.TextureConverter.hullTolerance">
            <summary>
                The hull tolerance
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.TextureConverter.multipartDetection">
            <summary>
                The multipart detection
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.TextureConverter.pixelOffsetOptimization">
            <summary>
                The pixel offset optimization
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.TextureConverter.polygonDetectionType">
            <summary>
                The polygon detection type
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.TextureConverter.tempIsSolidX">
            <summary>
                The temp is solid
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.TextureConverter.tempIsSolidY">
            <summary>
                The temp is solid
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.TextureConverter.transform">
            <summary>
                The identity
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.TextureConverter.width">
            <summary>
                The width
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.TextureTools.TextureConverter" /> class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.#ctor(System.Nullable{System.Byte},System.Nullable{System.Single},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{Alis.Core.Aspect.Math.Matrix.Matrix4X4F})">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.TextureTools.TextureConverter" /> class
            </summary>
            <param name="alphaTolerance">The alpha tolerance</param>
            <param name="hullTolerance">The hull tolerance</param>
            <param name="holeDetection">The hole detection</param>
            <param name="multipartDetection">The multipart detection</param>
            <param name="pixelOffsetOptimization">The pixel offset optimization</param>
            <param name="transform">The transform</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.#ctor(System.UInt32[],System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.TextureTools.TextureConverter" /> class
            </summary>
            <param name="data">The data</param>
            <param name="width">The width</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.#ctor(System.UInt32[],System.Int32,System.Nullable{System.Byte},System.Nullable{System.Single},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{Alis.Core.Aspect.Math.Matrix.Matrix4X4F})">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.TextureTools.TextureConverter" /> class
            </summary>
            <param name="data">The data</param>
            <param name="width">The width</param>
            <param name="alphaTolerance">The alpha tolerance</param>
            <param name="hullTolerance">The hull tolerance</param>
            <param name="holeDetection">The hole detection</param>
            <param name="multipartDetection">The multipart detection</param>
            <param name="pixelOffsetOptimization">The pixel offset optimization</param>
            <param name="transform">The transform</param>
        </member>
        <member name="P:Alis.Core.Physic.Tools.TextureTools.TextureConverter.PolygonDetectionType">
            <summary>Get or set the polygon detection type.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.TextureTools.TextureConverter.HoleDetection">
            <summary>Will detect texture 'holes' if set to true. Slows down the detection. Default is false.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.TextureTools.TextureConverter.MultipartDetection">
            <summary>Will detect texture multiple 'solid' isles if set to true. Slows down the detection. Default is false.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.TextureTools.TextureConverter.PixelOffsetOptimization">
            <summary>
                Will optimize the vertex positions along the interpolated normal between two edges about a half pixel (post
                processing). Default is false.
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.TextureTools.TextureConverter.Transform">
            <summary>Can be used for scaling.</summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.TextureTools.TextureConverter.AlphaTolerance">
            <summary>
                Alpha (coverage) tolerance. Default is 20: Every pixel with a coverage value equal or greater to 20 will be
                counts as solid.
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.TextureTools.TextureConverter.HullTolerance">
            <summary>Default is 1.5f.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.TextureConverter.ClosepixelsLength">
            <summary>
                The closepixels length
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.TextureConverter.ClosePixels">
            <summary>This array is meant to be read-only. It's not because it is accessed very frequently.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.Initialize(System.UInt32[],System.Nullable{System.Int32},System.Nullable{System.Byte},System.Nullable{System.Single},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{Alis.Core.Aspect.Math.Matrix.Matrix4X4F})">
            <summary>
                Initializes the data
            </summary>
            <param name="data">The data</param>
            <param name="width">The width</param>
            <param name="alphaTolerance">The alpha tolerance</param>
            <param name="hullTolerance">The hull tolerance</param>
            <param name="holeDetection">The hole detection</param>
            <param name="multipartDetection">The multipart detection</param>
            <param name="pixelOffsetOptimization">The pixel offset optimization</param>
            <param name="transform">The transform</param>
            <exception cref="T:System.ArgumentNullException">'data' can't be null if 'width' is set.</exception>
            <exception cref="T:System.ArgumentNullException">'width' can't be null if 'data' is set.</exception>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.SetTextureData(System.UInt32[],System.Int32)">
            <summary>
                Sets the texture data using the specified data
            </summary>
            <param name="data">The data</param>
            <param name="width">The width</param>
            <exception cref="T:System.ArgumentNullException">'data' can't be null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                'data' length can't be less then 4. Your texture must be at least 2 x 2
                pixels in size.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                'width' can't be less then 2. Your texture must be at least 2 x 2 pixels
                in size.
            </exception>
            <exception cref="T:System.ArgumentException">'width' has an invalid value.</exception>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.DetectVertices(System.UInt32[],System.Int32)">
            <summary>Detects the vertices of the supplied texture data. (PolygonDetectionType.Integrated)</summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.DetectVertices(System.UInt32[],System.Int32,System.Boolean)">
            <summary>Detects the vertices of the supplied texture data.</summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.DetectVertices(System.UInt32[],System.Int32,System.Single,System.Byte,System.Boolean,System.Boolean)">
            <summary>Detects the vertices of the supplied texture data.</summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
            <param name="hullTolerance">The hull tolerance.</param>
            <param name="alphaTolerance">The alpha tolerance.</param>
            <param name="multiPartDetection">if set to <c>true</c> it will perform multi part detection.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.DetectVertices">
            <summary>
                Detects the vertices
            </summary>
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:System.Exception">
                '_data' can't be null. You have to use SetTextureData(uint[] data, int width) before
                calling this method.
            </exception>
            <exception cref="T:System.Exception">
                '_width' has an invalid value. You have to use SetTextureData(uint[] data, int width)
                before calling this method.
            </exception>
            <exception cref="T:System.Exception">Couldn't detect any vertices.</exception>
            <returns>The detected polygons</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.ApplyTriangulationCompatibleWinding(System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices}@)">
            <summary>
                Applies the triangulation compatible winding using the specified detected polygons
            </summary>
            <param name="detectedPolygons">The detected polygons</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.ApplyTransform(System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices}@)">
            <summary>
                Applies the transform using the specified detected polygons
            </summary>
            <param name="detectedPolygons">The detected polygons</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.SearchHoleEntrance(Alis.Core.Physic.Shared.Vertices,System.Nullable{Alis.Core.Aspect.Math.Vector.Vector2F})">
            <summary>
                Function to search for an entrance point of a hole in a polygon. It searches the polygon from top to bottom
                between the polygon edges.
            </summary>
            <param name="polygon">The polygon to search in.</param>
            <param name="lastHoleEntrance">The last entrance point.</param>
            <returns>The next holes entrance point. Null if there are no holes.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.DistanceToHullAcceptableHoles(Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>
                Describes whether this instance distance to hull acceptable holes
            </summary>
            <param name="polygon">The polygon</param>
            <param name="point">The point</param>
            <param name="higherDetail">The higher detail</param>
            <exception cref="T:System.ArgumentNullException">'polygon' can't be null.</exception>
            <exception cref="T:System.ArgumentException">'polygon.MainPolygon.Count' can't be less then 3.</exception>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.DistanceToHullAcceptable(Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean)">
            <summary>
                Describes whether this instance distance to hull acceptable
            </summary>
            <param name="polygon">The polygon</param>
            <param name="point">The point</param>
            <param name="higherDetail">The higher detail</param>
            <exception cref="T:System.ArgumentNullException">'polygon' can't be null.</exception>
            <exception cref="T:System.ArgumentException">'polygon.Count' can't be less then 3.</exception>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.InPolygon(Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Describes whether this instance in polygon
            </summary>
            <param name="polygon">The polygon</param>
            <param name="point">The point</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.GetTopMostVertex(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Gets the top most vertex using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <returns>The top most</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.GetTopMostCoord(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Gets the top most coord using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <returns>The return value</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.GetBottomMostCoord(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Gets the bottom most coord using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <returns>The return value</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.SearchCrossingEdgesHoles(Alis.Core.Physic.Shared.Vertices,System.Int32)">
            <summary>
                Searches the crossing edges holes using the specified polygon
            </summary>
            <param name="polygon">The polygon</param>
            <param name="y">The </param>
            <exception cref="T:System.ArgumentNullException">'polygon' can't be null.</exception>
            <exception cref="T:System.ArgumentException">'polygon.MainPolygon.Count' can't be less then 3.</exception>
            <returns>The result</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.SearchCrossingEdges(Alis.Core.Physic.Shared.Vertices,System.Int32)">
            <summary>Searches the polygon for the x coordinates of the edges that cross the specified y coordinate.</summary>
            <param name="polygon">Polygon to search in.</param>
            <param name="y">Y coordinate to check for edges.</param>
            <returns>Descending sorted list of x coordinates of edges that cross the specified y coordinate.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.SplitPolygonEdge(Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Vector.Vector2F,System.Int32@,System.Int32@)">
            <summary>
                Describes whether this instance split polygon edge
            </summary>
            <param name="polygon">The polygon</param>
            <param name="coordInsideThePolygon">The coord inside the polygon</param>
            <param name="vertex1Index">The vertex index</param>
            <param name="vertex2Index">The vertex index</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.CreateSimplePolygon(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary></summary>
            <param name="entrance"></param>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.SearchNearPixels(System.Boolean,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Describes whether this instance search near pixels
            </summary>
            <param name="searchingForSolidPixel">The searching for solid pixel</param>
            <param name="current">The current</param>
            <param name="foundPixel">The found pixel</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.IsNearPixel(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Describes whether this instance is near pixel
            </summary>
            <param name="current">The current</param>
            <param name="near">The near</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.SearchHullEntrance(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Describes whether this instance search hull entrance
            </summary>
            <param name="entrance">The entrance</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.SearchNextHullEntrance(System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices},Alis.Core.Aspect.Math.Vector.Vector2F,System.Nullable{Alis.Core.Aspect.Math.Vector.Vector2F}@)">
            <summary>Searches for the next shape.</summary>
            <param name="detectedPolygons">Already detected polygons.</param>
            <param name="start">Search start coordinate.</param>
            <param name="entrance">Returns the found entrance coordinate. Null if no other shapes found.</param>
            <returns>True if a new shape was found.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.GetNextHullPoint(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Describes whether this instance get next hull point
            </summary>
            <param name="last">The last</param>
            <param name="current">The current</param>
            <param name="next">The next</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.SearchForOutstandingVertex(Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Describes whether this instance search for outstanding vertex
            </summary>
            <param name="hullArea">The hull area</param>
            <param name="outstanding">The outstanding</param>
            <returns>The found</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.GetIndexOfFirstPixelToCheck(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Gets the index of first pixel to check using the specified last
            </summary>
            <param name="last">The last</param>
            <param name="current">The current</param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.IsSolid(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Describes whether this instance is solid
            </summary>
            <param name="v">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.IsSolid(System.Int32@,System.Int32@)">
            <summary>
                Describes whether this instance is solid
            </summary>
            <param name="x">The </param>
            <param name="y">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.IsSolid(System.Int32@)">
            <summary>
                Describes whether this instance is solid
            </summary>
            <param name="index">The index</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.TextureTools.TextureConverter.InBounds(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Describes whether this instance in bounds
            </summary>
            <param name="coord">The coord</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.TextureTools.VerticesDetectionType">
            <summary>The detection type affects the resulting polygon data.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.VerticesDetectionType.Integrated">
            <summary>Holes are integrated into the main polygon.</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.TextureTools.VerticesDetectionType.Separated">
            <summary>The data of the main polygon and hole polygons is returned separately.</summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Bayazit.BayazitDecomposer">
            <summary>
                Convex decomposition algorithm created by Mark Bayazit (http://mnbayazit.com/)
                Properties:
                - Tries to decompose using polygons instead of triangles.
                - Tends to produce optimal results with low processing time.
                - Running time is O(nr), n = number of vertices, r = reflex vertices.
                - Does not support holes.
                For more information about this algorithm, see http://mnbayazit.com/406/bayazit
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Bayazit.BayazitDecomposer.ConvexPartition(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Decompose the polygon into several smaller non-concave polygon. If the polygon is already convex, it will
                return the original polygon, unless it is over Settings.MaxPolygonVertices.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Bayazit.BayazitDecomposer.TriangulatePolygon(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Triangulates the polygon using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <returns>The list</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Bayazit.BayazitDecomposer.At(System.Int32,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Ats the i
            </summary>
            <param name="i">The </param>
            <param name="vertices">The vertices</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Bayazit.BayazitDecomposer.Copy(System.Int32,System.Int32,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Copies the i
            </summary>
            <param name="i">The </param>
            <param name="j">The </param>
            <param name="vertices">The vertices</param>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Bayazit.BayazitDecomposer.CanSee(System.Int32,System.Int32,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Describes whether can see
            </summary>
            <param name="i">The </param>
            <param name="j">The </param>
            <param name="vertices">The vertices</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Bayazit.BayazitDecomposer.Reflex(System.Int32,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Describes whether reflex
            </summary>
            <param name="i">The </param>
            <param name="vertices">The vertices</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Bayazit.BayazitDecomposer.Right(System.Int32,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Describes whether right
            </summary>
            <param name="i">The </param>
            <param name="vertices">The vertices</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Bayazit.BayazitDecomposer.Left(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Describes whether left
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <param name="c">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Bayazit.BayazitDecomposer.LeftOn(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Describes whether left on
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <param name="c">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Bayazit.BayazitDecomposer.Right(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Describes whether right
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <param name="c">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Bayazit.BayazitDecomposer.RightOn(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Describes whether right on
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <param name="c">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Bayazit.BayazitDecomposer.SquareDist(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Squares the dist using the specified a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <returns>The float</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.CdtDecomposer">
            <summary>
                2D constrained Delaunay triangulation algorithm.
                Based on the paper "Sweep-line algorithm for constrained Delaunay triangulation" by V. Domiter and and B. Zalik
                Properties:
                - Creates triangles with a large interior angle.
                - Supports holes
                - Generate a lot of garbage due to incapsulation of the Poly2Tri library.
                - Running time is O(n^2), n = number of vertices.
                - Does not care about winding order.
                Source: http://code.google.com/p/poly2tri/
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.CdtDecomposer.ConvexPartition(Alis.Core.Physic.Shared.Vertices)">
            <summary>Decompose the polygon into several smaller non-concave polygon.</summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle">
            <summary>
                The delaunay triangle class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.EdgeIsConstrained">
            <summary>Neighbor pointers. Flags to determine if an edge is a Delauney edge</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.EdgeIsDelaunay">
            <summary>Flags to determine if an edge is a Constrained edge</summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Neighbors">
            <summary>
                The neighbors
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Points">
            <summary>Has this triangle been marked as an interior triangle?</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.#ctor(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle" /> class
            </summary>
            <param name="p1">The </param>
            <param name="p2">The </param>
            <param name="p3">The </param>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.IsInterior">
            <summary>
                Gets or sets the value of the is interior
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.IndexOf(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Indexes the of using the specified p
            </summary>
            <param name="p">The </param>
            <exception cref="T:System.Exception">Calling index with a point that doesn't exist in triangle</exception>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.IndexCw(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Indexes the cw using the specified p
            </summary>
            <param name="p">The </param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.IndexCcw(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Indexes the ccw using the specified p
            </summary>
            <param name="p">The </param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Contains(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance contains
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Contains(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint)">
            <summary>
                Describes whether this instance contains
            </summary>
            <param name="e">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Contains(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance contains
            </summary>
            <param name="p">The </param>
            <param name="q">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkNeighbor(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>Update neighbor pointers</summary>
            <param name="p1">Point 1 of the shared edge</param>
            <param name="p2">Point 2 of the shared edge</param>
            <param name="t">This triangle's new neighbor</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkNeighbor(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>Exhaustive search to update neighbor pointers</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.ClearNeighbors">
            <summary>
                Clears the neighbors
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.ClearNeighbor(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Clears the neighbor using the specified triangle
            </summary>
            <param name="triangle">The triangle</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Clear">
            <summary>Clears all references to all other triangles and points</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.OppositePoint(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <param name="t">Opposite triangle</param>
            <param name="p">The point in t that isn't shared between the triangles</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.NeighborCw(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Neighbors the cw using the specified point
            </summary>
            <param name="point">The point</param>
            <returns>The delaunay triangle</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.NeighborCcw(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Neighbors the ccw using the specified point
            </summary>
            <param name="point">The point</param>
            <returns>The delaunay triangle</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.NeighborAcross(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Neighbors the across using the specified point
            </summary>
            <param name="point">The point</param>
            <returns>The delaunay triangle</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.PointCcw(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Points the ccw using the specified point
            </summary>
            <param name="point">The point</param>
            <returns>The triangulation point</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.PointCw(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Points the cw using the specified point
            </summary>
            <param name="point">The point</param>
            <returns>The triangulation point</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.RotateCw">
            <summary>
                Rotates the cw
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Legalize(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>Legalize triangle by rotating clockwise around oPoint</summary>
            <param name="oPoint">The origin point to rotate around</param>
            <param name="nPoint">???</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.ToString">
            <summary>
                Returns the string
            </summary>
            <returns>The string</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkNeighborEdges">
            <summary>Finalize edge marking</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkEdge(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Marks the edge using the specified triangle
            </summary>
            <param name="triangle">The triangle</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkEdge(System.Collections.Generic.List{Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle})">
            <summary>
                Marks the edge using the specified t list
            </summary>
            <param name="tList">The list</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkConstrainedEdge(System.Int32)">
            <summary>
                Marks the constrained edge using the specified index
            </summary>
            <param name="index">The index</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkConstrainedEdge(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint)">
            <summary>
                Marks the constrained edge using the specified edge
            </summary>
            <param name="edge">The edge</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkConstrainedEdge(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>Mark edge as constrained</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Area">
            <summary>
                Areas this instance
            </summary>
            <returns>The double</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Centroid">
            <summary>
                Centroids this instance
            </summary>
            <returns>The triangulation point</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.EdgeIndex(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>Get the index of the neighbor that shares this edge (or -1 if it isn't shared)</summary>
            <returns>index of the shared edge or -1 if edge isn't shared</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.GetConstrainedEdgeCcw(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance get constrained edge ccw
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.GetConstrainedEdgeCw(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance get constrained edge cw
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.GetConstrainedEdgeAcross(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance get constrained edge across
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.SetConstrainedEdgeCcw(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,System.Boolean)">
            <summary>
                Sets the constrained edge ccw using the specified p
            </summary>
            <param name="p">The </param>
            <param name="ce">The ce</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.SetConstrainedEdgeCw(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,System.Boolean)">
            <summary>
                Sets the constrained edge cw using the specified p
            </summary>
            <param name="p">The </param>
            <param name="ce">The ce</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.SetConstrainedEdgeAcross(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,System.Boolean)">
            <summary>
                Sets the constrained edge across using the specified p
            </summary>
            <param name="p">The </param>
            <param name="ce">The ce</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.GetDelaunayEdgeCcw(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance get delaunay edge ccw
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.GetDelaunayEdgeCw(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance get delaunay edge cw
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.GetDelaunayEdgeAcross(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance get delaunay edge across
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.SetDelaunayEdgeCcw(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,System.Boolean)">
            <summary>
                Sets the delaunay edge ccw using the specified p
            </summary>
            <param name="p">The </param>
            <param name="ce">The ce</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.SetDelaunayEdgeCw(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,System.Boolean)">
            <summary>
                Sets the delaunay edge cw using the specified p
            </summary>
            <param name="p">The </param>
            <param name="ce">The ce</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle.SetDelaunayEdgeAcross(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,System.Boolean)">
            <summary>
                Sets the delaunay edge across using the specified p
            </summary>
            <param name="p">The </param>
            <param name="ce">The ce</param>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront">
            @author Thomas Åhlen (thahlen@gmail.com)
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.Head">
            <summary>
                The head
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.Search">
            <summary>
                The search
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.Tail">
            <summary>
                The tail
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.#ctor(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront" /> class
            </summary>
            <param name="head">The head</param>
            <param name="tail">The tail</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.AddNode(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Adds the node using the specified node
            </summary>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.RemoveNode(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Removes the node using the specified node
            </summary>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.ToString">
            <summary>
                Returns the string
            </summary>
            <returns>The string</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.FindSearchNode(System.Double)">
            <summary>
                MM:  This seems to be used by LocateNode to guess a position in the implicit linked list of
                AdvancingFrontNodes near x Removed an overload that depended on this being exact
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.LocateNode(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>We use a balancing tree to locate a node smaller or equal to given key value</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.LocateNode(System.Double)">
            <summary>
                Locates the node using the specified x
            </summary>
            <param name="x">The </param>
            <returns>The advancing front node</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.LocatePoint(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>This implementation will use simple node traversal algorithm to find a point on the front</summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode">
            <summary>
                The advancing front node class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.Next">
            <summary>
                The next
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.Point">
            <summary>
                The point
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.Prev">
            <summary>
                The prev
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.Triangle">
            <summary>
                The triangle
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.Value">
            <summary>
                The value
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.#ctor(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode" /> class
            </summary>
            <param name="point">The point</param>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.HasNext">
            <summary>
                Gets the value of the has next
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.HasPrev">
            <summary>
                Gets the value of the has prev
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep">
            <summary>
                The dt sweep class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.PiDiv2">
            <summary>
                The pi
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.Pi3Div4">
            <summary>
                The pi
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.Triangulate(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext)">
            <summary>Triangulate simple polygon with holes</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.Sweep(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext)">
            <summary>Start sweeping the Y-sorted point set from bottom to top</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FinalizationConvexHull(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext)">
            <summary>If this is a Delaunay Triangulation of a pointset we need to fill so the triangle mesh gets a ConvexHull</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.TurnAdvancingFrontConvex(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>We will traverse the entire advancing front and fill it to form a convex hull.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FinalizationPolygon(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext)">
            <summary>
                Finalizations the polygon using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.PointEvent(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Find closes node to the left of the new point and create a new triangle. If needed new holes and basins will
                be filled to.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.NewFrontTriangle(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>Creates a new front triangle and legalize it</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.EdgeEvent(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Edges the event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillEdgeEvent(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillRightConcaveEdgeEvent(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the right concave edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillRightConvexEdgeEvent(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the right convex edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillRightBelowEdgeEvent(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the right below edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillRightAboveEdgeEvent(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the right above edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillLeftConvexEdgeEvent(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the left convex edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillLeftConcaveEdgeEvent(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the left concave edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillLeftBelowEdgeEvent(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the left below edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillLeftAboveEdgeEvent(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the left above edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.IsEdgeSideOfTriangle(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether is edge side of triangle
            </summary>
            <param name="triangle">The triangle</param>
            <param name="ep">The ep</param>
            <param name="eq">The eq</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.EdgeEvent(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Edges the event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="ep">The ep</param>
            <param name="eq">The eq</param>
            <param name="triangle">The triangle</param>
            <param name="point">The point</param>
            <exception cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.PointOnEdgeException">EdgeEvent - Point on constrained edge not supported yet</exception>
            <exception cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.PointOnEdgeException">EdgeEvent - Point on constrained edge not supported yet</exception>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FlipEdgeEvent(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Flips the edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="ep">The ep</param>
            <param name="eq">The eq</param>
            <param name="t">The </param>
            <param name="p">The </param>
            <exception cref="T:System.Exception">Intersecting Constraints</exception>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.NextFlipPoint(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                When we need to traverse from one triangle to the next we need the point in current triangle that is the
                opposite point to the next triangle.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.NextFlipTriangle(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Orientation,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                After a flip we have two triangles and know that only one will still be intersecting the edge. So decide which
                to contiune with and legalize the other
            </summary>
            <param name="tcx"></param>
            <param name="o">should be the result of an TriangulationUtil.orient2d( eq, op, ep )</param>
            <param name="t">triangle 1</param>
            <param name="ot">triangle 2</param>
            <param name="p">a point shared by both triangles</param>
            <param name="op">another point shared by both triangles</param>
            <returns>returns the triangle still intersecting the edge</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FlipScanEdgeEvent(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Scan part of the FlipScan algorithm When a triangle pair isn't flippable we will scan for the next point that
                is inside the flip triangle scan area. When found we generate a new flipEdgeEvent
            </summary>
            <param name="tcx"></param>
            <param name="ep">last point on the edge we are traversing</param>
            <param name="eq">first point on the edge we are traversing</param>
            <param name="flipTriangle">the current triangle sharing the point eq with edge</param>
            <param name="t"></param>
            <param name="p"></param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillAdvancingFront(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>Fills holes in the Advancing Front</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.LargeHole_DontFill(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Describes whether large hole dont fill
            </summary>
            <param name="node">The node</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.AngleExceeds90Degrees(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether angle exceeds 90 degrees
            </summary>
            <param name="origin">The origin</param>
            <param name="pa">The pa</param>
            <param name="pb">The pb</param>
            <returns>The exceeds 90 degrees</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.AngleExceedsPlus90DegreesOrIsNegative(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether angle exceeds plus 90 degrees or is negative
            </summary>
            <param name="origin">The origin</param>
            <param name="pa">The pa</param>
            <param name="pb">The pb</param>
            <returns>The exceeds plus 90 degrees or is negative</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.Angle(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Angles the origin
            </summary>
            <param name="origin">The origin</param>
            <param name="pa">The pa</param>
            <param name="pb">The pb</param>
            <returns>The angle</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillBasin(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills a basin that has formed on the Advancing Front to the right of given node. First we decide a left,bottom
                and right node that forms the boundaries of the basin. Then we do a reqursive fill.
            </summary>
            <param name="tcx"></param>
            <param name="node">starting node, this or next node will be left node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillBasinReq(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>Recursive algorithm to fill a Basin with triangles</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.IsShallow(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Describes whether is shallow
            </summary>
            <param name="tcx">The tcx</param>
            <param name="node">The node</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.HoleAngle(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>???</summary>
            <param name="node">middle node</param>
            <returns>the angle between 3 front nodes</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.BasinAngle(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>The basin angle is decided against the horizontal line [1,0]</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.Fill(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>Adds a triangle to the advancing front to fill a hole.</summary>
            <param name="tcx"></param>
            <param name="node">middle node, that is the bottom of the hole</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.Legalize(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>Returns true if triangle was legalized</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.RotateTrianglePair(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Rotates a triangle pair one vertex CW
                n2                    n2
                Position +-----+             Position +-----+
                | t  /|               |\  t |
                |   / |               | \   |
                n1|  /  |n3           n1|  \  |n3
                | /   |    after CW   |   \ |
                |/ oT |               | oT \|
                +-----+ oP            +-----+
                n4                    n4
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint">
            <summary>
                The dt sweep constraint class
            </summary>
            <seealso cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationConstraint" />
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint.#ctor(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>Give two points in any order. Will always be ordered so that q.y > p.y and q.x > p.x if same y value</summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext">
            @author Thomas Åhlén, thahlen@gmail.com
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.comparator">
            <summary>
                The dt sweep point comparator
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.AFront">
            <summary>
                The front
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.Basin">
            <summary>
                The dt sweep basin
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.EdgeEvent">
            <summary>
                The dt sweep edge event
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext" /> class
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.Head">
            <summary>
                Gets or sets the value of the head
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.Tail">
            <summary>
                Gets or sets the value of the tail
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.Alpha">
            <summary>
                The alpha
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.RemoveFromList(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Removes the from list using the specified triangle
            </summary>
            <param name="triangle">The triangle</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.MeshClean(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Meshes the clean using the specified triangle
            </summary>
            <param name="triangle">The triangle</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.MeshCleanReq(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Meshes the clean req using the specified triangle
            </summary>
            <param name="triangle">The triangle</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.Clear">
            <summary>
                Clears this instance
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.AddNode(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Adds the node using the specified node
            </summary>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.RemoveNode(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Removes the node using the specified node
            </summary>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.LocateNode(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Locates the node using the specified point
            </summary>
            <param name="point">The point</param>
            <returns>The advancing front node</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.CreateAdvancingFront">
            <summary>
                Creates the advancing front
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.MapTriangleToNodes(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>Try to map a node to all sides of this triangle that don't have a neighbor.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.PrepareTriangulation(Alis.Core.Physic.Tools.Triangulation.Delaunay.ITriangulatable)">
            <summary>
                Prepares the triangulation using the specified t
            </summary>
            <param name="t">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.FinalizeTriangulation">
            <summary>
                Finalizes the triangulation
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.NewConstraint(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                News the constraint using the specified a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <returns>The triangulation constraint</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepBasin">
            <summary>
                The dt sweep basin class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepBasin.BottomNode">
            <summary>
                The bottom node
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepBasin.LeftHighest">
            <summary>
                The left highest
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepBasin.LeftNode">
            <summary>
                The left node
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepBasin.RightNode">
            <summary>
                The right node
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepBasin.Width">
            <summary>
                The width
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepEdgeEvent">
            <summary>
                The dt sweep edge event class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepEdgeEvent.ConstrainedEdge">
            <summary>
                The constrained edge
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepEdgeEvent.Right">
            <summary>
                The right
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepPointComparator">
            <summary>
                The dt sweep point comparator class
            </summary>
            <seealso cref="T:System.Collections.Generic.IComparer`1" />
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepPointComparator.Compare(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Compares the p 1
            </summary>
            <param name="p1">The </param>
            <param name="p2">The </param>
            <returns>The int</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.PointOnEdgeException">
            <summary>
                The point on edge exception class
            </summary>
            <seealso cref="T:System.NotImplementedException" />
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.PointOnEdgeException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.PointOnEdgeException" /> class
            </summary>
            <param name="message">The message</param>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Orientation">
            <summary>
                The orientation enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Orientation.Cw">
            <summary>
                The cw orientation
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Orientation.Ccw">
            <summary>
                The ccw orientation
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Orientation.Collinear">
            <summary>
                The collinear orientation
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon">
            <summary>
                The polygon class
            </summary>
            <seealso cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.ITriangulatable" />
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.HolesPrivate">
            <summary>
                The holes
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.LastPrivate">
            <summary>
                The last
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.PointsPrivate">
            <summary>
                The triangulation point
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.SteinerPointsPrivate">
            <summary>
                The steiner points
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.TrianglesPrivate">
            <summary>
                The triangles
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.#ctor(System.Collections.Generic.IList{Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonPoint})">
            <summary>Create a polygon from a list of at least 3 points with no duplicates.</summary>
            <param name="points">A list of unique points</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.#ctor(System.Collections.Generic.IEnumerable{Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonPoint})">
            <summary>Create a polygon from a list of at least 3 points with no duplicates.</summary>
            <param name="points">A list of unique points.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon" /> class
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.Holes">
            <summary>
                Gets the value of the holes
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.TriangulationMode">
            <summary>
                Gets the value of the triangulation mode
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.Points">
            <summary>
                Gets the value of the points
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.Triangles">
            <summary>
                Gets the value of the triangles
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.AddTriangle(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Adds the triangle using the specified t
            </summary>
            <param name="t">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.AddTriangles(System.Collections.Generic.IEnumerable{Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle})">
            <summary>
                Adds the triangles using the specified list
            </summary>
            <param name="list">The list</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.ClearTriangles">
            <summary>
                Clears the triangles
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.PrepareTriangulation(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext)">
            <summary>Creates constraints and populates the context with points</summary>
            <param name="tcx">The context</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.AddSteinerPoint(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Adds the steiner point using the specified point
            </summary>
            <param name="point">The point</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.AddSteinerPoints(System.Collections.Generic.List{Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint})">
            <summary>
                Adds the steiner points using the specified points
            </summary>
            <param name="points">The points</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.ClearSteinerPoints">
            <summary>
                Clears the steiner points
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.AddHole(Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon)">
            <summary>Add a hole to the polygon.</summary>
            <param name="poly">A subtraction polygon fully contained inside this polygon.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.InsertPointAfter(Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonPoint)">
            <summary>Inserts newPoint after point.</summary>
            <param name="point">The point to insert after in the polygon</param>
            <param name="newPoint">The point to insert into the polygon</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.AddPoints(System.Collections.Generic.IEnumerable{Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonPoint})">
            <summary>Inserts list (after last point in polygon?)</summary>
            <param name="list"></param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.AddPoint(Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonPoint)">
            <summary>Adds a point after the last in the polygon.</summary>
            <param name="p">The point to add</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon.RemovePoint(Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonPoint)">
            <summary>Removes a point from the polygon.</summary>
            <param name="p"></param>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonPoint">
            <summary>
                The polygon point class
            </summary>
            <seealso cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint" />
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonPoint.#ctor(System.Double,System.Double)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonPoint" /> class
            </summary>
            <param name="x">The </param>
            <param name="y">The </param>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonPoint.Next">
            <summary>
                Gets or sets the value of the next
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonPoint.Previous">
            <summary>
                Gets or sets the value of the previous
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonSet">
            <summary>
                The polygon set class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonSet.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonSet" /> class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonSet.#ctor(Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonSet" /> class
            </summary>
            <param name="poly">The poly</param>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonSet.PolygonsList">
            <summary>
                The polygon
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonSet.Polygons">
            <summary>
                Gets the value of the polygons
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.PolygonSet.Add(Alis.Core.Physic.Tools.Triangulation.Delaunay.Polygon.Polygon)">
            <summary>
                Adds the p
            </summary>
            <param name="p">The </param>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.ConstrainedPointSet">
            <summary>
                The constrained point set class
            </summary>
            <seealso cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.PointSet" />
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.ConstrainedPointSet.constrainedPointList">
            <summary>
                The constrained point list
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.ConstrainedPointSet.#ctor(System.Collections.Generic.List{Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint},System.Int32[])">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.ConstrainedPointSet" /> class
            </summary>
            <param name="points">The points</param>
            <param name="index">The index</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.ConstrainedPointSet.#ctor(System.Collections.Generic.List{Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint},System.Collections.Generic.IEnumerable{Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint})">
            @param points - A list of all points in PointSet
            @param constraints - Pairs of two points defining a constraint, all points
            <b>must</b>
            be part of given PointSet!
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.ConstrainedPointSet.EdgeIndex">
            <summary>
                Gets or sets the value of the edge index
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.ConstrainedPointSet.TriangulationMode">
            <summary>
                Gets the value of the triangulation mode
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.ConstrainedPointSet.PrepareTriangulation(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext)">
            <summary>
                Prepares the triangulation using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.PointSet">
            <summary>
                The point set class
            </summary>
            <seealso cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.ITriangulatable" />
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.PointSet.#ctor(System.Collections.Generic.List{Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint})">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.PointSet" /> class
            </summary>
            <param name="points">The points</param>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.PointSet.Points">
            <summary>
                Gets or sets the value of the points
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.PointSet.Triangles">
            <summary>
                Gets or sets the value of the triangles
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.PointSet.TriangulationMode">
            <summary>
                Gets the value of the triangulation mode
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.PointSet.AddTriangle(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Adds the triangle using the specified t
            </summary>
            <param name="t">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.PointSet.AddTriangles(System.Collections.Generic.IEnumerable{Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle})">
            <summary>
                Adds the triangles using the specified list
            </summary>
            <param name="list">The list</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.PointSet.ClearTriangles">
            <summary>
                Clears the triangles
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Sets.PointSet.PrepareTriangulation(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext)">
            <summary>
                Prepares the triangulation using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.ITriangulatable">
            <summary>
                The triangulatable interface
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.ITriangulatable.Points">
            <summary>
                Gets the value of the points
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.ITriangulatable.Triangles">
            <summary>
                Gets the value of the triangles
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.ITriangulatable.TriangulationMode">
            <summary>
                Gets the value of the triangulation mode
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.ITriangulatable.PrepareTriangulation(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext)">
            <summary>
                Prepares the triangulation using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.ITriangulatable.AddTriangle(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Adds the triangle using the specified t
            </summary>
            <param name="t">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.ITriangulatable.AddTriangles(System.Collections.Generic.IEnumerable{Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle})">
            <summary>
                Adds the triangles using the specified list
            </summary>
            <param name="list">The list</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.ITriangulatable.ClearTriangles">
            <summary>
                Clears the triangles
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationConstraint">
            <summary>
                The triangulation constraint class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationConstraint.P">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationConstraint.Q">
            <summary>
                The
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext">
            <summary>
                The triangulation context class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext.Points">
            <summary>
                The triangulation point
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext.Triangles">
            <summary>
                The delaunay triangle
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext" /> class
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext.TriangulationMode">
            <summary>
                Gets or sets the value of the triangulation mode
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext.Triangulatable">
            <summary>
                Gets or sets the value of the triangulatable
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext.Terminated">
            <summary>
                Gets or sets the value of the terminated
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext.StepCount">
            <summary>
                Gets or sets the value of the step count
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext.IsDebugEnabled">
            <summary>
                Gets or sets the value of the is debug enabled
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext.Done">
            <summary>
                Dones this instance
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext.PrepareTriangulation(Alis.Core.Physic.Tools.Triangulation.Delaunay.ITriangulatable)">
            <summary>
                Prepares the triangulation using the specified t
            </summary>
            <param name="t">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext.NewConstraint(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                News the constraint using the specified a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <returns>The triangulation constraint</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext.Update(System.String)">
            <summary>
                Updates the message
            </summary>
            <param name="message">The message</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationContext.Clear">
            <summary>
                Clears this instance
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationMode">
            <summary>
                The triangulation mode enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationMode.Unconstrained">
            <summary>
                The unconstrained triangulation mode
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationMode.Constrained">
            <summary>
                The constrained triangulation mode
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationMode.Polygon">
            <summary>
                The polygon triangulation mode
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint">
            <summary>
                The triangulation point class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint.X">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint.Y">
            <summary>
                The
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint.#ctor(System.Double,System.Double)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint" /> class
            </summary>
            <param name="x">The </param>
            <param name="y">The </param>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint.Edges">
            <summary>
                Gets or sets the value of the edges
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint.Xf">
            <summary>
                Gets or sets the value of the xf
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint.Yf">
            <summary>
                Gets or sets the value of the yf
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint.HasEdges">
            <summary>
                Gets the value of the has edges
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint.ToString">
            <summary>
                Returns the string
            </summary>
            <returns>The string</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint.AddEdge(Alis.Core.Physic.Tools.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint)">
            <summary>
                Adds the edge using the specified e
            </summary>
            <param name="e">The </param>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationUtil">
            @author Thomas Åhlén, thahlen@gmail.com
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationUtil.Epsilon">
            <summary>
                The epsilon
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationUtil.SmartIncircle(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Requirements:
                1. a,b and c form a triangle.
                2. a and d is know to be on opposite side of bc
                <code>
                           a
                           +
                          / \
                         /   \
                       b/     \c
                       +-------+ 
                      /    B    \  
                     /           \ 
            </code>
                Facts:
                d has to be in area B to have a chance to be inside the circle formed by a,b and c
                d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW
                This preknowledge gives us a way to optimize the incircle test
            </summary>
            <param name="pa">triangle point, opposite d</param>
            <param name="pb">triangle point</param>
            <param name="pc">triangle point</param>
            <param name="pd">point opposite a</param>
            <returns>true if d is inside circle, false if on circle edge</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationUtil.InScanArea(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether in scan area
            </summary>
            <param name="pa">The pa</param>
            <param name="pb">The pb</param>
            <param name="pc">The pc</param>
            <param name="pd">The pd</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint,Alis.Core.Physic.Tools.Triangulation.Delaunay.TriangulationPoint)">
            Forumla to calculate signed area
            Positive if CCW
            Negative if CW
            0 if collinear
            A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
            =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Util.PointGenerator">
            <summary>
                The point generator class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Util.PointGenerator.Rng">
            <summary>
                The random
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Util.PointGenerator.UniformDistribution(System.Int32,System.Double)">
            <summary>
                Uniforms the distribution using the specified n
            </summary>
            <param name="n">The </param>
            <param name="scale">The scale</param>
            <returns>The points</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Util.PointGenerator.UniformGrid(System.Int32,System.Double)">
            <summary>
                Uniforms the grid using the specified n
            </summary>
            <param name="n">The </param>
            <param name="scale">The scale</param>
            <returns>The points</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Delaunay.Util.PolygonGenerator">
            <summary>
                The polygon generator class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Delaunay.Util.PolygonGenerator.Rng">
            <summary>
                The random
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Util.PolygonGenerator.RandomCircleSweep(System.Double,System.Int32)">
            <summary>
                Randoms the circle sweep using the specified scale
            </summary>
            <param name="scale">The scale</param>
            <param name="vertexCount">The vertex count</param>
            <returns>The polygon polygon</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Delaunay.Util.PolygonGenerator.RandomCircleSweep2(System.Double,System.Int32)">
            <summary>
                Randoms the circle sweep 2 using the specified scale
            </summary>
            <param name="scale">The scale</param>
            <param name="vertexCount">The vertex count</param>
            <returns>The polygon polygon</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Earclip.EarclipDecomposer">
            <summary>
                Convex decomposition algorithm using ear clipping
                Properties:
                - Only works on simple polygons.
                - Does not support holes.
                - Running time is O(n^2), n = number of vertices.
                Source: http://www.ewjordan.com/earClip/
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Earclip.EarclipDecomposer.ConvexPartition(Alis.Core.Physic.Shared.Vertices,System.Single)">
            <summary>
                Decompose the polygon into several smaller non-concave polygon. Each resulting polygon will have no more than
                Settings.MaxPolygonVertices vertices.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="tolerance">The tolerance.</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Earclip.EarclipDecomposer.TriangulatePolygon(Alis.Core.Physic.Shared.Vertices,System.Single)">
            <summary>
                Triangulates a polygon using simple ear-clipping algorithm. Returns size of Triangle array unless the polygon
                can't be triangulated. This should only happen if the polygon self-intersects, though it will not _always_ return
                null
                for a bad polygon - it is the caller's responsibility to check for self-intersection, and if it doesn't, it should
                at
                least check that the return value is non-null before using. You're warned! Triangles may be degenerate, especially
                if
                you have identical points in the input to the algorithm.  Check this before you use them. This is totally
                unoptimized,
                so for large polygons it should not be part of the simulation loop.
            </summary>
            <remarks>Only works on simple polygons.</remarks>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Earclip.EarclipDecomposer.ResolvePinchPoint(Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Shared.Vertices@,Alis.Core.Physic.Shared.Vertices@,System.Single)">
            <summary>
                Finds and fixes "pinch points," points where two polygon vertices are at the same point. If a pinch point is
                found, pin is broken up into poutA and poutB and true is returned; otherwise, returns false. Mostly for internal
                use.
                O(N^2) time, which sucks...
            </summary>
            <param name="pin">The pin.</param>
            <param name="poutA">The pout A.</param>
            <param name="poutB">The pout B.</param>
            <param name="tolerance"></param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Earclip.EarclipDecomposer.Remainder(System.Int32,System.Int32)">
            <summary>Fix for obnoxious behavior for the % operator for negative numbers...</summary>
            <param name="x">The x.</param>
            <param name="modulus">The modulus.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Earclip.EarclipDecomposer.IsEar(System.Int32,System.Single[],System.Single[],System.Int32)">
            <summary>Checks if vertex i is the tip of an ear in polygon defined by xv[] and  yv[].</summary>
            <param name="i">The i.</param>
            <param name="xv">The xv.</param>
            <param name="yv">The yv.</param>
            <param name="xvLength">Length of the xv.</param>
            <remarks>Assumes clockwise orientation of polygon.</remarks>
            <returns><c>true</c> if the specified i is ear; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Earclip.Triangle">
            <summary>
                The triangle class
            </summary>
            <seealso cref="T:Alis.Core.Physic.Shared.Vertices" />
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Earclip.Triangle.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Earclip.Triangle" /> class
            </summary>
            <param name="x1">The </param>
            <param name="y1">The </param>
            <param name="x2">The </param>
            <param name="y2">The </param>
            <param name="x3">The </param>
            <param name="y3">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Earclip.Triangle.IsInside(System.Single,System.Single)">
            <summary>
                Describes whether this instance is inside
            </summary>
            <param name="x">The </param>
            <param name="y">The </param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.FlipCode.FlipcodeDecomposer">
            <summary>
                Convex decomposition algorithm created by unknown
                Properties:
                - No support for holes
                - Very fast
                - Only works on simple polygons
                - Only works on counter clockwise polygons
                More information: http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.FlipCode.FlipcodeDecomposer._tmpA">
            <summary>
                The tmp
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.FlipCode.FlipcodeDecomposer._tmpB">
            <summary>
                The tmp
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.FlipCode.FlipcodeDecomposer._tmpC">
            <summary>
                The tmp
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.FlipCode.FlipcodeDecomposer.ConvexPartition(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Decompose the polygon into triangles.
                Properties:
                - Only works on counter clockwise polygons
            </summary>
            <param name="vertices">The list of points describing the polygon</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.FlipCode.FlipcodeDecomposer.InsideTriangle(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Check if the point Position is inside the triangle defined by the points A, B, C</summary>
            <param name="a">The A point.</param>
            <param name="b">The B point.</param>
            <param name="c">The C point.</param>
            <param name="p">The point to be tested.</param>
            <returns>True if the point is inside the triangle</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.FlipCode.FlipcodeDecomposer.Snip(Alis.Core.Physic.Shared.Vertices,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[])">
            <summary>Cut a the contour and add a triangle into V to describe the location of the cut</summary>
            <param name="contour">The list of points defining the polygon</param>
            <param name="u">The index of the first point</param>
            <param name="v">The index of the second point</param>
            <param name="w">The index of the third point</param>
            <param name="n">The number of elements in the array.</param>
            <param name="vv">The array to populate with indicies of triangles.</param>
            <returns>True if a triangle was found</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Seidel.Edge">
            <summary>
                The edge class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Edge.Above">
            <summary>
                The above
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Edge.B">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Edge.Below">
            <summary>
                The below
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Edge.MPoints">
            <summary>
                The points
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Edge.P">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Edge.Q">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Edge.Slope">
            <summary>
                The slope
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Edge.#ctor(Alis.Core.Physic.Tools.Triangulation.Seidel.Point,Alis.Core.Physic.Tools.Triangulation.Seidel.Point)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Seidel.Edge" /> class
            </summary>
            <param name="p">The </param>
            <param name="q">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Edge.IsAbove(Alis.Core.Physic.Tools.Triangulation.Seidel.Point)">
            <summary>
                Describes whether this instance is above
            </summary>
            <param name="point">The point</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Edge.IsBelow(Alis.Core.Physic.Tools.Triangulation.Seidel.Point)">
            <summary>
                Describes whether this instance is below
            </summary>
            <param name="point">The point</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Edge.AddMpoint(Alis.Core.Physic.Tools.Triangulation.Seidel.Point)">
            <summary>
                Adds the mpoint using the specified point
            </summary>
            <param name="point">The point</param>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain">
            <summary>
                The monotone mountain class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.convexPoints">
            <summary>
                The convex points
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.monoPoly">
            <summary>
                The mono poly
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.head">
            <summary>
                The head
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.positive">
            <summary>
                The positive
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.size">
            <summary>
                The size
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.tail">
            <summary>
                The tail
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.Triangles">
            <summary>
                The triangles
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain" /> class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.PiSlop">
            <summary>
                The pi slop
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.Add(Alis.Core.Physic.Tools.Triangulation.Seidel.Point)">
            <summary>
                Adds the point
            </summary>
            <param name="point">The point</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.Remove(Alis.Core.Physic.Tools.Triangulation.Seidel.Point)">
            <summary>
                Removes the point
            </summary>
            <param name="point">The point</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.Process">
            <summary>
                Processes this instance
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.Triangulate">
            <summary>
                Triangulates this instance
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.Valid(Alis.Core.Physic.Tools.Triangulation.Seidel.Point)">
            <summary>
                Describes whether this instance valid
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.GenMonoPoly">
            <summary>
                Gens the mono poly
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.Angle(Alis.Core.Physic.Tools.Triangulation.Seidel.Point)">
            <summary>
                Angles the p
            </summary>
            <param name="p">The </param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.AngleSign">
            <summary>
                Describes whether this instance angle sign
            </summary>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.MonotoneMountain.IsConvex(Alis.Core.Physic.Tools.Triangulation.Seidel.Point)">
            <summary>
                Describes whether this instance is convex
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Seidel.Node">
            <summary>
                The node class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Node.LeftChild">
            <summary>
                The left child
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Node.ParentList">
            <summary>
                The parent list
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Node.RightChild">
            <summary>
                The right child
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Node.#ctor(Alis.Core.Physic.Tools.Triangulation.Seidel.Node,Alis.Core.Physic.Tools.Triangulation.Seidel.Node)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Seidel.Node" /> class
            </summary>
            <param name="left">The left</param>
            <param name="right">The right</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Node.Locate(Alis.Core.Physic.Tools.Triangulation.Seidel.Edge)">
            <summary>
                Locates the s
            </summary>
            <param name="s">The </param>
            <returns>The sink</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Node.Replace(Alis.Core.Physic.Tools.Triangulation.Seidel.Node)">
            <summary>
                Replaces the node
            </summary>
            <param name="node">The node</param>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Seidel.Point">
            <summary>
                The point class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Point.Next">
            <summary>
                The prev
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Point.Prev">
            <summary>
                The prev
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Point.X">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Point.Y">
            <summary>
                The
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Point.#ctor(System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Seidel.Point" /> class
            </summary>
            <param name="x">The </param>
            <param name="y">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Point.Cross(Alis.Core.Physic.Tools.Triangulation.Seidel.Point)">
            <summary>
                Crosses the p
            </summary>
            <param name="p">The </param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Point.Dot(Alis.Core.Physic.Tools.Triangulation.Seidel.Point)">
            <summary>
                Dots the p
            </summary>
            <param name="p">The </param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Point.Neq(Alis.Core.Physic.Tools.Triangulation.Seidel.Point)">
            <summary>
                Describes whether this instance neq
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Point.Orient2D(Alis.Core.Physic.Tools.Triangulation.Seidel.Point,Alis.Core.Physic.Tools.Triangulation.Seidel.Point)">
            <summary>
                Orients the 2 d using the specified pb
            </summary>
            <param name="pb">The pb</param>
            <param name="pc">The pc</param>
            <returns>The float</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Seidel.QueryGraph">
            <summary>
                The query graph class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.QueryGraph.head">
            <summary>
                The head
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.QueryGraph.#ctor(Alis.Core.Physic.Tools.Triangulation.Seidel.Node)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Seidel.QueryGraph" /> class
            </summary>
            <param name="head">The head</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.QueryGraph.Locate(Alis.Core.Physic.Tools.Triangulation.Seidel.Edge)">
            <summary>
                Locates the edge
            </summary>
            <param name="edge">The edge</param>
            <returns>The trapezoid</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.QueryGraph.FollowEdge(Alis.Core.Physic.Tools.Triangulation.Seidel.Edge)">
            <summary>
                Follows the edge using the specified edge
            </summary>
            <param name="edge">The edge</param>
            <returns>The trapezoids</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.QueryGraph.Replace(Alis.Core.Physic.Tools.Triangulation.Seidel.Sink,Alis.Core.Physic.Tools.Triangulation.Seidel.Node)">
            <summary>
                Replaces the sink
            </summary>
            <param name="sink">The sink</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.QueryGraph.Case1(Alis.Core.Physic.Tools.Triangulation.Seidel.Sink,Alis.Core.Physic.Tools.Triangulation.Seidel.Edge,Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid[])">
            <summary>
                Cases the 1 using the specified sink
            </summary>
            <param name="sink">The sink</param>
            <param name="edge">The edge</param>
            <param name="tList">The list</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.QueryGraph.Case2(Alis.Core.Physic.Tools.Triangulation.Seidel.Sink,Alis.Core.Physic.Tools.Triangulation.Seidel.Edge,Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid[])">
            <summary>
                Cases the 2 using the specified sink
            </summary>
            <param name="sink">The sink</param>
            <param name="edge">The edge</param>
            <param name="tList">The list</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.QueryGraph.Case3(Alis.Core.Physic.Tools.Triangulation.Seidel.Sink,Alis.Core.Physic.Tools.Triangulation.Seidel.Edge,Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid[])">
            <summary>
                Cases the 3 using the specified sink
            </summary>
            <param name="sink">The sink</param>
            <param name="edge">The edge</param>
            <param name="tList">The list</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.QueryGraph.Case4(Alis.Core.Physic.Tools.Triangulation.Seidel.Sink,Alis.Core.Physic.Tools.Triangulation.Seidel.Edge,Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid[])">
            <summary>
                Cases the 4 using the specified sink
            </summary>
            <param name="sink">The sink</param>
            <param name="edge">The edge</param>
            <param name="tList">The list</param>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Seidel.SeidelDecomposer">
            <summary>
                Convex decomposition algorithm created by Raimund Seidel
                Properties:
                - Decompose the polygon into trapezoids, then triangulate.
                - To use the trapezoid data, use ConvexPartitionTrapezoid()
                - Generate a lot of garbage due to incapsulation of the Poly2Tri library.
                - Running time is O(n log n), n = number of vertices.
                - Running time is almost linear for most simple polygons.
                - Does not care about winding order.
                For more information, see Raimund Seidel's paper "A simple and fast incremental randomized
                algorithm for computing trapezoidal decompositions and for triangulating polygons"
                See also: "Computational Geometry", 3rd edition, by Mark de Berg et al, Chapter 6.2
                "Computational Geometry in C", 2nd edition, by Joseph O'Rourke
                Original code from the Poly2Tri project by Mason Green.
                http://code.google.com/p/poly2tri/source/browse?repo=archive#hg/scala/src/org/poly2tri/seidel
                This implementation is from Dec 14, 2010
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.SeidelDecomposer.ConvexPartition(Alis.Core.Physic.Shared.Vertices,System.Single)">
            <summary>Decompose the polygon into several smaller non-concave polygons.</summary>
            <param name="vertices">The polygon to decompose.</param>
            <param name="sheer">The sheer to use if you get bad results, try using a higher value.</param>
            <returns>A list of triangles</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.SeidelDecomposer.ConvexPartitionTrapezoid(Alis.Core.Physic.Shared.Vertices,System.Single)">
            <summary>Decompose the polygon into several smaller non-concave polygons.</summary>
            <param name="vertices">The polygon to decompose.</param>
            <param name="sheer">The sheer to use if you get bad results, try using a higher value.</param>
            <returns>A list of trapezoids</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Seidel.Sink">
            <summary>
                The sink class
            </summary>
            <seealso cref="T:Alis.Core.Physic.Tools.Triangulation.Seidel.Node" />
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Sink.Trapezoid">
            <summary>
                The trapezoid
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Sink.#ctor(Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Seidel.Sink" /> class
            </summary>
            <param name="trapezoid">The trapezoid</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Sink.Isink(Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid)">
            <summary>
                Isinks the trapezoid
            </summary>
            <param name="trapezoid">The trapezoid</param>
            <returns>The sink</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Sink.Locate(Alis.Core.Physic.Tools.Triangulation.Seidel.Edge)">
            <summary>
                Locates the edge
            </summary>
            <param name="edge">The edge</param>
            <returns>The sink</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid">
            <summary>
                The trapezoid class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.Bottom">
            <summary>
                The bottom
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.Inside">
            <summary>
                The inside
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.LeftPoint">
            <summary>
                The left point
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.LowerLeft">
            <summary>
                The lower left
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.LowerRight">
            <summary>
                The lower right
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.RightPoint">
            <summary>
                The right point
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.Sink">
            <summary>
                The sink
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.Top">
            <summary>
                The top
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.UpperLeft">
            <summary>
                The upper left
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.UpperRight">
            <summary>
                The upper right
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.#ctor(Alis.Core.Physic.Tools.Triangulation.Seidel.Point,Alis.Core.Physic.Tools.Triangulation.Seidel.Point,Alis.Core.Physic.Tools.Triangulation.Seidel.Edge,Alis.Core.Physic.Tools.Triangulation.Seidel.Edge)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid" /> class
            </summary>
            <param name="leftPoint">The left point</param>
            <param name="rightPoint">The right point</param>
            <param name="top">The top</param>
            <param name="bottom">The bottom</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.UpdateLeft(Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid,Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid)">
            <summary>
                Updates the left using the specified ul
            </summary>
            <param name="ul">The ul</param>
            <param name="ll">The ll</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.UpdateRight(Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid,Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid)">
            <summary>
                Updates the right using the specified ur
            </summary>
            <param name="ur">The ur</param>
            <param name="lr">The lr</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.UpdateLeftRight(Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid,Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid,Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid,Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid)">
            <summary>
                Updates the left right using the specified ul
            </summary>
            <param name="ul">The ul</param>
            <param name="ll">The ll</param>
            <param name="ur">The ur</param>
            <param name="lr">The lr</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.TrimNeighbors">
            <summary>
                Trims the neighbors
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.Contains(Alis.Core.Physic.Tools.Triangulation.Seidel.Point)">
            <summary>
                Describes whether this instance contains
            </summary>
            <param name="point">The point</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.GetVertices">
            <summary>
                Gets the vertices
            </summary>
            <returns>The verts</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.LineIntersect(Alis.Core.Physic.Tools.Triangulation.Seidel.Edge,System.Single)">
            <summary>
                Lines the intersect using the specified edge
            </summary>
            <param name="edge">The edge</param>
            <param name="x">The </param>
            <returns>The point</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid.AddPoints">
            <summary>
                Adds the points
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Seidel.TrapezoidalMap">
            <summary>
                The trapezoidal map class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.TrapezoidalMap.margin">
            <summary>
                The margin
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.TrapezoidalMap.bCross">
            <summary>
                The cross
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.TrapezoidalMap.cross">
            <summary>
                The cross
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.TrapezoidalMap.Map">
            <summary>
                The map
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.TrapezoidalMap.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Seidel.TrapezoidalMap" /> class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.TrapezoidalMap.Clear">
            <summary>
                Clears this instance
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.TrapezoidalMap.Case1(Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid,Alis.Core.Physic.Tools.Triangulation.Seidel.Edge)">
            <summary>
                Cases the 1 using the specified t
            </summary>
            <param name="t">The </param>
            <param name="e">The </param>
            <returns>The trapezoids</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.TrapezoidalMap.Case2(Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid,Alis.Core.Physic.Tools.Triangulation.Seidel.Edge)">
            <summary>
                Cases the 2 using the specified t
            </summary>
            <param name="t">The </param>
            <param name="e">The </param>
            <returns>The trapezoids</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.TrapezoidalMap.Case3(Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid,Alis.Core.Physic.Tools.Triangulation.Seidel.Edge)">
            <summary>
                Cases the 3 using the specified t
            </summary>
            <param name="t">The </param>
            <param name="e">The </param>
            <returns>The trapezoids</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.TrapezoidalMap.Case4(Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid,Alis.Core.Physic.Tools.Triangulation.Seidel.Edge)">
            <summary>
                Cases the 4 using the specified t
            </summary>
            <param name="t">The </param>
            <param name="e">The </param>
            <returns>The trapezoids</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.TrapezoidalMap.BoundingBox(System.Collections.Generic.List{Alis.Core.Physic.Tools.Triangulation.Seidel.Edge})">
            <summary>
                Boundings the box using the specified edges
            </summary>
            <param name="edges">The edges</param>
            <returns>The trapezoid</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator">
            <summary>
                The triangulator class
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.boundingBox">
            <summary>
                The bounding box
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.edgeList">
            <summary>
                The edge list
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.queryGraph">
            <summary>
                The query graph
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.sheer">
            <summary>
                The sheer
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.trapezoidalMap">
            <summary>
                The trapezoidal map
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.xMonoPoly">
            <summary>
                The mono poly
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.Trapezoids">
            <summary>
                The trapezoids
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.Triangles">
            <summary>
                The triangles
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.#ctor(System.Collections.Generic.List{Alis.Core.Physic.Tools.Triangulation.Seidel.Point},System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator" /> class
            </summary>
            <param name="polyLine">The poly line</param>
            <param name="sheer">The sheer</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.Process">
            <summary>
                Processes this instance
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.CreateMountains">
            <summary>
                Creates the mountains
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.MarkOutside(Alis.Core.Physic.Tools.Triangulation.Seidel.Trapezoid)">
            <summary>
                Marks the outside using the specified t
            </summary>
            <param name="t">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.InitEdges(System.Collections.Generic.List{Alis.Core.Physic.Tools.Triangulation.Seidel.Point})">
            <summary>
                Inits the edges using the specified points
            </summary>
            <param name="points">The points</param>
            <returns>A list of edge</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.OrderSegments(System.Collections.Generic.List{Alis.Core.Physic.Tools.Triangulation.Seidel.Edge})">
            <summary>
                Orders the segments using the specified edge input
            </summary>
            <param name="edgeInput">The edge input</param>
            <returns>The edges</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.Shuffle``1(System.Collections.Generic.IList{``0})">
            <summary>
                Shuffles the list
            </summary>
            <typeparam name="T">The </typeparam>
            <param name="list">The list</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.Triangulator.ShearTransform(Alis.Core.Physic.Tools.Triangulation.Seidel.Point)">
            <summary>
                Shears the transform using the specified point
            </summary>
            <param name="point">The point</param>
            <returns>The point</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Seidel.XNode">
            <summary>
                The node class
            </summary>
            <seealso cref="T:Alis.Core.Physic.Tools.Triangulation.Seidel.Node" />
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.XNode.point">
            <summary>
                The point
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.XNode.#ctor(Alis.Core.Physic.Tools.Triangulation.Seidel.Point,Alis.Core.Physic.Tools.Triangulation.Seidel.Node,Alis.Core.Physic.Tools.Triangulation.Seidel.Node)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Seidel.XNode" /> class
            </summary>
            <param name="point">The point</param>
            <param name="lChild">The child</param>
            <param name="rChild">The child</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.XNode.Locate(Alis.Core.Physic.Tools.Triangulation.Seidel.Edge)">
            <summary>
                Locates the edge
            </summary>
            <param name="edge">The edge</param>
            <returns>The sink</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.Seidel.YNode">
            <summary>
                The node class
            </summary>
            <seealso cref="T:Alis.Core.Physic.Tools.Triangulation.Seidel.Node" />
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.Seidel.YNode.edge">
            <summary>
                The edge
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.YNode.#ctor(Alis.Core.Physic.Tools.Triangulation.Seidel.Edge,Alis.Core.Physic.Tools.Triangulation.Seidel.Node,Alis.Core.Physic.Tools.Triangulation.Seidel.Node)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Core.Physic.Tools.Triangulation.Seidel.YNode" /> class
            </summary>
            <param name="edge">The edge</param>
            <param name="lChild">The child</param>
            <param name="rChild">The child</param>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.Seidel.YNode.Locate(Alis.Core.Physic.Tools.Triangulation.Seidel.Edge)">
            <summary>
                Locates the edge
            </summary>
            <param name="edge">The edge</param>
            <returns>The sink</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.TriangulationBase.Triangulate">
            <summary>
                The triangulate class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.TriangulationBase.Triangulate.ConvexPartition(Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm,System.Boolean,System.Single)">
            <summary>
                Convexes the partition using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <param name="algorithm">The algorithm</param>
            <param name="discardAndFixInvalid">The discard and fix invalid</param>
            <param name="tolerance">The tolerance</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <returns>The results</returns>
        </member>
        <member name="M:Alis.Core.Physic.Tools.Triangulation.TriangulationBase.Triangulate.ValidatePolygon(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Describes whether validate polygon
            </summary>
            <param name="polygon">The polygon</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Core.Physic.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm">
            <summary>
                The triangulation algorithm enum
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Earclip">
            <summary>
                Convex decomposition algorithm using ear clipping
                Properties:
                - Only works on simple polygons.
                - Does not support holes.
                - Running time is O(n^2), n = number of vertices.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Bayazit">
            <summary>
                Convex decomposition algorithm created by Mark Bayazit (http://mnbayazit.com/)
                Properties:
                - Tries to decompose using polygons instead of triangles.
                - Tends to produce optimal results with low processing time.
                - Running time is O(nr), n = number of vertices, r = reflex vertices.
                - Does not support holes.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Flipcode">
            <summary>
                Convex decomposition algorithm created by unknown
                Properties:
                - No support for holes
                - Very fast
                - Only works on simple polygons
                - Only works on counter clockwise polygons
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Seidel">
            <summary>
                Convex decomposition algorithm created by Raimund Seidel
                Properties:
                - Decompose the polygon into trapezoids, then triangulate.
                - To use the trapezoid data, use ConvexPartitionTrapezoid()
                - Generate a lot of garbage due to incapsulation of the Poly2Tri library.
                - Running time is O(n log n), n = number of vertices.
                - Running time is almost linear for most simple polygons.
                - Does not care about winding order.
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.SeidelTrapezoids">
            <summary>
                The seidel trapezoids triangulation algorithm
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Delauny">
            <summary>
                2D constrained Delaunay triangulation algorithm.
                Based on the paper "Sweep-line algorithm for constrained Delaunay triangulation" by V. Domiter and and B. Zalik
                Properties:
                - Creates triangles with a large interior angle.
                - Supports holes
                - Generate a lot of garbage due to incapsulation of the Poly2Tri library.
                - Running time is O(n^2), n = number of vertices.
                - Does not care about winding order.
            </summary>
        </member>
        <member name="T:Alis.Core.Physic.Utilities.Line">
            <summary>
                Collection of helper methods for misc collisions. Does float tolerance and line collisions with lines and
                AABBs.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Line.DistanceBetweenPointAndLineSegment(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Distances the between point and line segment using the specified point
            </summary>
            <param name="point">The point</param>
            <param name="start">The start</param>
            <param name="end">The end</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Line.LineIntersect2(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Check if the lines a0->a1 and b0->b1 cross. If they do, intersectionPoint will be filled with the point of
                crossing. Grazing lines should not return true.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Line.LineIntersect(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Lines the intersect using the specified p 1
            </summary>
            <param name="p1">The </param>
            <param name="p2">The </param>
            <param name="q1">The </param>
            <param name="q2">The </param>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Line.LineIntersect(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,System.Boolean,System.Boolean,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                This method detects if two line segments (or lines) intersect, and, if so, the point of intersection. Use the
                <paramref name="firstIsSegment" /> and <paramref name="secondIsSegment" /> parameters to set whether the
                intersection
                point must be on the first and second line segments. Setting these both to true means you are doing a line-segment
                to
                line-segment intersection. Setting one of them to true means you are doing a line to line-segment intersection
                test,
                and so on. Note: If two line segments are coincident, then no intersection is detected (there are actually infinite
                intersection points). Author: Jeremy Bell
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="point">This is set to the intersection point if an intersection is detected.</param>
            <param name="firstIsSegment">Set this to true to require that the intersection point be on the first line segment.</param>
            <param name="secondIsSegment">Set this to true to require that the intersection point be on the second line segment.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Line.LineIntersect(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,System.Boolean,System.Boolean,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                This method detects if two line segments (or lines) intersect, and, if so, the point of intersection. Use the
                <paramref name="firstIsSegment" /> and <paramref name="secondIsSegment" /> parameters to set whether the
                intersection
                point must be on the first and second line segments. Setting these both to true means you are doing a line-segment
                to
                line-segment intersection. Setting one of them to true means you are doing a line to line-segment intersection
                test,
                and so on. Note: If two line segments are coincident, then no intersection is detected (there are actually infinite
                intersection points). Author: Jeremy Bell
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="intersectionPoint">This is set to the intersection point if an intersection is detected.</param>
            <param name="firstIsSegment">Set this to true to require that the intersection point be on the first line segment.</param>
            <param name="secondIsSegment">Set this to true to require that the intersection point be on the second line segment.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Line.LineIntersect(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                This method detects if two line segments intersect, and, if so, the point of intersection. Note: If two line
                segments are coincident, then no intersection is detected (there are actually infinite intersection points).
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="intersectionPoint">This is set to the intersection point if an intersection is detected.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Line.LineIntersect(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                This method detects if two line segments intersect, and, if so, the point of intersection. Note: If two line
                segments are coincident, then no intersection is detected (there are actually infinite intersection points).
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="intersectionPoint">This is set to the intersection point if an intersection is detected.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Line.LineSegmentVerticesIntersect(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Get all intersections between a line segment and a list of vertices representing a polygon. The vertices reuse
                adjacent points, so for example edges one and two are between the first and second vertices and between the second
                and
                third vertices. The last edge is between vertex vertices.Count - 1 and verts0. (ie, vertices from a Geometry or
                AABB)
            </summary>
            <param name="point1">The first point of the line segment to test</param>
            <param name="point2">The second point of the line segment to test.</param>
            <param name="vertices">The vertices, as described above</param>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Line.LineSegmentAabbIntersect(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Physic.Shared.Aabb)">
            <summary>Get all intersections between a line segment and an AABB.</summary>
            <param name="point1">The first point of the line segment to test</param>
            <param name="point2">The second point of the line segment to test.</param>
            <param name="aabb">The AABB that is used for testing intersection.</param>
        </member>
        <member name="T:Alis.Core.Physic.Utilities.MathUtils">
            <summary>
                The math utils class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Cross(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Perform the cross product on two vectors.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Cross(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Perform the cross product on two vectors.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Cross(Alis.Core.Aspect.Math.Vector.Vector3F,Alis.Core.Aspect.Math.Vector.Vector3F)">
            <summary>Perform the cross product on two vectors.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Cross(Alis.Core.Aspect.Math.Vector.Vector2F,System.Single)">
            <summary>Perform the cross product on two vectors.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Cross(System.Single,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Perform the cross product on two vectors.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Abs(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Abses the v
            </summary>
            <param name="v">The </param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Abs(System.Single)">
            <summary>
                Abses the value
            </summary>
            <param name="value">The value</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Mul(Alis.Core.Aspect.Math.Matrix.Matrix2X2F@,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Muls the a
            </summary>
            <param name="a">The </param>
            <param name="v">The </param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Mul(Alis.Core.Aspect.Math.Matrix.Matrix2X2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Muls the a
            </summary>
            <param name="a">The </param>
            <param name="v">The </param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Mul(Alis.Core.Aspect.Math.Transform@,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Muls the t
            </summary>
            <param name="T">The </param>
            <param name="v">The </param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Mul(Alis.Core.Aspect.Math.Transform@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Muls the t
            </summary>
            <param name="T">The </param>
            <param name="v">The </param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.MulT(Alis.Core.Aspect.Math.Matrix.Matrix2X2F@,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Muls the t using the specified a
            </summary>
            <param name="a">The </param>
            <param name="v">The </param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.MulT(Alis.Core.Aspect.Math.Matrix.Matrix2X2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Muls the t using the specified a
            </summary>
            <param name="a">The </param>
            <param name="v">The </param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.MulT(Alis.Core.Aspect.Math.Transform@,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Muls the t using the specified t
            </summary>
            <param name="T">The </param>
            <param name="v">The </param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.MulT(Alis.Core.Aspect.Math.Transform@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Muls the t using the specified t
            </summary>
            <param name="T">The </param>
            <param name="v">The </param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.MulT(Alis.Core.Aspect.Math.Matrix.Matrix2X2F@,Alis.Core.Aspect.Math.Matrix.Matrix2X2F@,Alis.Core.Aspect.Math.Matrix.Matrix2X2F@)">
            <summary>
                Muls the t using the specified a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <param name="c">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Mul(Alis.Core.Aspect.Math.Matrix.Matrix3X3F,Alis.Core.Aspect.Math.Vector.Vector3F)">
            <summary>Multiply a matrix times a vector.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Mul(Alis.Core.Aspect.Math.Transform,Alis.Core.Aspect.Math.Transform)">
            <summary>
                Muls the a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.MulT(Alis.Core.Aspect.Math.Transform@,Alis.Core.Aspect.Math.Transform@,Alis.Core.Aspect.Math.Transform@)">
            <summary>
                Muls the t using the specified a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <param name="c">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Swap``1(``0@,``0@)">
            <summary>
                Swaps the a
            </summary>
            <typeparam name="T">The </typeparam>
            <param name="a">The </param>
            <param name="b">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Mul22(Alis.Core.Aspect.Math.Matrix.Matrix3X3F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Multiply a matrix times a vector.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Mul(Alis.Core.Aspect.Math.Rotation,Alis.Core.Aspect.Math.Rotation)">
            <summary>Multiply two rotations: q * r</summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.MulT(Alis.Core.Aspect.Math.Transform,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Muls the t using the specified t
            </summary>
            <param name="T">The </param>
            <param name="v">The </param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.MulT(Alis.Core.Aspect.Math.Rotation,Alis.Core.Aspect.Math.Rotation)">
            <summary>Transpose multiply two rotations: qT * r</summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.MulT(Alis.Core.Aspect.Math.Transform,Alis.Core.Aspect.Math.Transform)">
            <summary>
                Muls the t using the specified a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Mul(Alis.Core.Aspect.Math.Rotation,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Rotate a vector</summary>
            <param name="q">The rotation matrix</param>
            <param name="v">The value</param>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.MulT(Alis.Core.Aspect.Math.Rotation,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Inverse rotate a vector</summary>
            <param name="q">The rotation matrix</param>
            <param name="v">The value</param>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Skew(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Get the skew vector such that dot(skew_vec, other) == cross(vec, other)</summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.IsValid(System.Single)">
            <summary>This function is used to ensure that a floating point number is not a NaN or infinity.</summary>
            <param name="x">The x.</param>
            <returns><c>true</c> if the specified x is valid; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.IsValid(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Describes whether is valid
            </summary>
            <param name="x">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
                Clamps the a
            </summary>
            <param name="a">The </param>
            <param name="low">The low</param>
            <param name="high">The high</param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Clamp(System.Single,System.Single,System.Single)">
            <summary>
                Clamps the a
            </summary>
            <param name="a">The </param>
            <param name="low">The low</param>
            <param name="high">The high</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Clamp(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Clamps the a
            </summary>
            <param name="a">The </param>
            <param name="low">The low</param>
            <param name="high">The high</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Cross(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,System.Single@)">
            <summary>
                Crosses the a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <param name="c">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.VectorAngle(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Return the angle between two vectors on a plane The angle is from vector 1 to vector 2, positive anticlockwise
                The result is between -pi -> pi
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Dot(Alis.Core.Aspect.Math.Vector.Vector3F,Alis.Core.Aspect.Math.Vector.Vector3F)">
            <summary>Perform the dot product on two vectors.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Dot(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Perform the dot product on two vectors.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Dot(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Perform the dot product on two vectors.</summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.VectorAngle(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Vectors the angle using the specified p 1
            </summary>
            <param name="p1">The </param>
            <param name="p2">The </param>
            <returns>The double</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Area(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Returns a positive number if c is to the left of the line going from a to b.</summary>
            <returns>Positive number if point is left, negative if point is right, and 0 if points are collinear.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Area(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>Returns a positive number if c is to the left of the line going from a to b.</summary>
            <returns>Positive number if point is left, negative if point is right, and 0 if points are collinear.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.IsCollinear(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@,System.Single)">
            <summary>Determines if three vertices are collinear (ie. on a straight line)</summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Cross(System.Single,Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Crosses the s
            </summary>
            <param name="s">The </param>
            <param name="a">The </param>
            <param name="b">The </param>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.FloatEquals(System.Single,System.Single)">
            <summary>
                Describes whether float equals
            </summary>
            <param name="value1">The value</param>
            <param name="value2">The value</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.FloatEquals(System.Single,System.Single,System.Single)">
            <summary>Checks if a floating point Value is equal to another, within a certain tolerance.</summary>
            <returns>True if the values are "equal", false otherwise.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.FloatInRange(System.Single,System.Single,System.Single)">
            <summary>Checks if a floating point Value is within a specified range of values (inclusive).</summary>
            <param name="value">The Value to check.</param>
            <param name="min">The minimum Value.</param>
            <param name="max">The maximum Value.</param>
            <returns>True if the Value is within the range specified, false otherwise.</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Mul(Alis.Core.Aspect.Math.Rotation@,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Muls the rot
            </summary>
            <param name="rotation">The rot</param>
            <param name="axis">The axis</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.MulT(Alis.Core.Aspect.Math.Rotation@,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Muls the t using the specified rot
            </summary>
            <param name="rotation">The rot</param>
            <param name="axis">The axis</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Distance(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
                Distances the a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Distance(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Distances the a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.DistanceSquared(Alis.Core.Aspect.Math.Vector.Vector2F@,Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Distances the squared using the specified a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Max(System.Single,System.Single)">
            <summary>
                Maxes the value a
            </summary>
            <param name="valueA">The value</param>
            <param name="valueB">The value</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Max(System.Int32,System.Int32)">
            <summary>
                Maxes the value a
            </summary>
            <param name="valueA">The value</param>
            <param name="valueB">The value</param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Min(System.Single,System.Single)">
            <summary>
                Mins the value a
            </summary>
            <param name="valueA">The value</param>
            <param name="valueB">The value</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Min(System.Int32,System.Int32)">
            <summary>
                Mins the value a
            </summary>
            <param name="valueA">The value</param>
            <param name="valueB">The value</param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Sign(System.Single)">
            <summary>
                Signs the value
            </summary>
            <param name="value">The value</param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Normalize(Alis.Core.Aspect.Math.Vector.Vector2F@)">
            <summary>
                Convert this vector into a unit vector. Returns the length.
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Sqrt(System.Single)">
            <summary>
                Sqrts the value
            </summary>
            <param name="value">The value</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Cosf(System.Single)">
            <summary>
                Cosfs the value
            </summary>
            <param name="value">The value</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Sinf(System.Single)">
            <summary>
                Sinfs the value
            </summary>
            <param name="value">The value</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Ceil(System.Single)">
            <summary>
                Ceils the log
            </summary>
            <param name="log">The log</param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.MathUtils.Log(System.Single)">
            <summary>
                Logs the log
            </summary>
            <param name="log">The log</param>
            <returns>The float</returns>
        </member>
        <member name="T:Alis.Core.Physic.Utilities.Polygon">
            <summary>
                The polygon utils class
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Polygon.CreateRectangle(System.Single,System.Single)">
            <summary>Build vertices to represent an axis-aligned box.</summary>
            <param name="hx">the half-width.</param>
            <param name="hy">the half-height.</param>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Polygon.CreateRectangle(System.Single,System.Single,Alis.Core.Aspect.Math.Vector.Vector2F,System.Single)">
            <summary>Build vertices to represent an oriented box.</summary>
            <param name="hx">the half-width.</param>
            <param name="hy">the half-height.</param>
            <param name="center">the center of the box in local coordinates.</param>
            <param name="angle">the rotation of the box in local coordinates.</param>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Polygon.CreateRoundedRectangle(System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>Creates a rounded rectangle with the specified width and height.</summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="xRadius">The rounding X radius.</param>
            <param name="yRadius">The rounding Y radius.</param>
            <param name="segments">The number of segments to subdivide the edges.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Polygon.CreateLine(Alis.Core.Aspect.Math.Vector.Vector2F,Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>Set this as a single edge.</summary>
            <param name="start">The first point.</param>
            <param name="end">The second point.</param>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Polygon.CreateCircle(System.Single,System.Int32)">
            <summary>Creates a circle with the specified radius and number of edges.</summary>
            <param name="radius">The radius.</param>
            <param name="numberOfEdges">The number of edges. The more edges, the more it resembles a circle</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Polygon.CreateEllipse(System.Single,System.Single,System.Int32)">
            <summary>Creates a ellipse with the specified width, height and number of edges.</summary>
            <param name="xRadius">Width of the ellipse.</param>
            <param name="yRadius">Height of the ellipse.</param>
            <param name="numberOfEdges">The number of edges. The more edges, the more it resembles an ellipse</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Polygon.CreateArc(System.Single,System.Int32,System.Single)">
            <summary>
                Creates the arc using the specified radians
            </summary>
            <param name="radians">The radians</param>
            <param name="sides">The sides</param>
            <param name="radius">The radius</param>
            <returns>The vertices</returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Polygon.CreateCapsule(System.Single,System.Single,System.Int32)">
            <summary>
                Creates an capsule with the specified height, radius and number of edges. A capsule has the same form as a
                pill capsule.
            </summary>
            <param name="height">Height (inner height + 2 * radius) of the capsule.</param>
            <param name="endRadius">Radius of the capsule ends.</param>
            <param name="edges">The number of edges of the capsule ends. The more edges, the more it resembles an capsule</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Polygon.CreateCapsule(System.Single,System.Single,System.Int32,System.Single,System.Int32)">
            <summary>
                Creates an capsule with the specified  height, radius and number of edges. A capsule has the same form as a
                pill capsule.
            </summary>
            <param name="height">Height (inner height + radii) of the capsule.</param>
            <param name="topRadius">Radius of the top.</param>
            <param name="topEdges">The number of edges of the top. The more edges, the more it resembles an capsule</param>
            <param name="bottomRadius">Radius of bottom.</param>
            <param name="bottomEdges">The number of edges of the bottom. The more edges, the more it resembles an capsule</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Polygon.CreateGear(System.Single,System.Int32,System.Single,System.Single)">
            <summary>Creates a gear shape with the specified radius and number of teeth.</summary>
            <param name="radius">The radius.</param>
            <param name="numberOfTeeth">The number of teeth.</param>
            <param name="tipPercentage">The tip percentage.</param>
            <param name="toothHeight">Height of the tooth.</param>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Polygon.CreatePolygon(System.UInt32[],System.Int32)">
            <summary>Detects the vertices by analyzing the texture data.</summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Polygon.CreatePolygon(System.UInt32[],System.Int32,System.Boolean)">
            <summary>Detects the vertices by analyzing the texture data.</summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Core.Physic.Utilities.Polygon.CreatePolygon(System.UInt32[],System.Int32,System.Single,System.Byte,System.Boolean,System.Boolean)">
            <summary>Detects the vertices by analyzing the texture data.</summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <param name="hullTolerance">The hull tolerance.</param>
            <param name="alphaTolerance">The alpha tolerance.</param>
            <param name="multiPartDetection">if set to <c>true</c> it will perform multi part detection.</param>
            <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
            <returns></returns>
        </member>
        <member name="T:Alis.Core.Physic.World">
            <summary>The world class manages all physics entities, dynamic simulation, and asynchronous queries.</summary>
        </member>
        <member name="M:Alis.Core.Physic.World.#ctor(Alis.Core.Aspect.Math.Vector.Vector2F)">
            <summary>
            Initializes a new instance of the <see cref="T:Alis.Core.Physic.World"/> class
            </summary>
            <param name="gravity">The gravity</param>
        </member>
        <member name="P:Alis.Core.Physic.World.Gravity">
            <summary>
            Gets the value of the gravity
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.World.Bodies">
            <summary>
            Gets or sets the value of the bodys
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.World.BreakableBodies">
            <summary>
            The breakable body
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.World.Joints">
            <summary>
            Gets or sets the value of the joints
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.World.Controllers">
            <summary>
            Gets the value of the controllers
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.World.ContactManager">
            <summary>
            Gets or sets the value of the contact manager
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.World.TimeStep">
            <summary>
            Gets or sets the value of the step
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.World.Island">
            <summary>
            The island
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.World.ContactPool">
            <summary>
            The contact
            </summary>
        </member>
        <member name="P:Alis.Core.Physic.World.BodiesStack">
            <summary>
            Gets or sets the value of the bodies stack
            </summary>
        </member>
        <member name="F:Alis.Core.Physic.World.Current">
            <summary>
            The current
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.World.AddBody(Alis.Core.Physic.Dynamics.Body)">
            <summary>
            Adds the body using the specified body
            </summary>
            <param name="body">The body</param>
        </member>
        <member name="M:Alis.Core.Physic.World.RemoveBody(Alis.Core.Physic.Dynamics.Body)">
            <summary>
            Removes the body using the specified body
            </summary>
            <param name="body">The body</param>
        </member>
        <member name="M:Alis.Core.Physic.World.AddBreakableBody(Alis.Core.Physic.Dynamics.BreakableBody)">
            <summary>
            Adds the breakable body using the specified breakable body
            </summary>
            <param name="breakableBody">The breakable body</param>
        </member>
        <member name="M:Alis.Core.Physic.World.RemoveBreakableBody(Alis.Core.Physic.Dynamics.BreakableBody)">
            <summary>
            Removes the breakable body using the specified breakable body
            </summary>
            <param name="breakableBody">The breakable body</param>
        </member>
        <member name="M:Alis.Core.Physic.World.AddJoint(Alis.Core.Physic.Dynamics.Joints.Joint)">
            <summary>
            Adds the joint using the specified joint
            </summary>
            <param name="joint">The joint</param>
        </member>
        <member name="M:Alis.Core.Physic.World.RemoveJoint(Alis.Core.Physic.Dynamics.Joints.Joint)">
            <summary>
            Removes the joint using the specified joint
            </summary>
            <param name="joint">The joint</param>
        </member>
        <member name="M:Alis.Core.Physic.World.AddController(Alis.Core.Physic.Extensions.Controllers.ControllerBase.Controller)">
            <summary>
            Adds the controller using the specified controller
            </summary>
            <param name="controller">The controller</param>
        </member>
        <member name="M:Alis.Core.Physic.World.RemoveController(Alis.Core.Physic.Extensions.Controllers.ControllerBase.Controller)">
            <summary>
            Removes the controller using the specified controller
            </summary>
            <param name="controller">The controller</param>
        </member>
        <member name="M:Alis.Core.Physic.World.Step(System.Single,System.Int32,System.Int32)">
            <summary>
            Steps the dt
            </summary>
            <param name="dt">The dt</param>
            <param name="velocityIterations">The velocity iterations</param>
            <param name="positionIterations">The position iterations</param>
        </member>
        <member name="M:Alis.Core.Physic.World.FindNewContacts">
            <summary>
            Finds the new contacts
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.World.UpdateTimeStep(System.Single,System.Int32,System.Int32)">
            <summary>
            Updates the time step using the specified dt
            </summary>
            <param name="dt">The dt</param>
            <param name="velocityIterations">The velocity iterations</param>
            <param name="positionIterations">The position iterations</param>
        </member>
        <member name="M:Alis.Core.Physic.World.UpdateControllers(System.Single)">
            <summary>
            Updates the controllers using the specified dt
            </summary>
            <param name="dt">The dt</param>
        </member>
        <member name="M:Alis.Core.Physic.World.CollideContacts">
            <summary>
            Collides the contacts
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.World.UpdateInvertedDeltaTime(System.Single)">
            <summary>
            Updates the inverted delta time using the specified dt
            </summary>
            <param name="dt">The dt</param>
        </member>
        <member name="M:Alis.Core.Physic.World.UpdateBreakableBodies">
            <summary>
            Updates the breakable bodies
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.World.Solve">
            <summary>
            Solves the step
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.World.SolveToi">
            <summary>
            Solves the toi
            </summary>
        </member>
        <member name="M:Alis.Core.Physic.World.ClearForces">
            <summary>
            Clear all forces
            </summary>
        </member>
        <member name="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve">
            <summary>
                Contains a collection of <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" /> points in 2D space and provides methods for evaluating
                features of the curve they define.
            </summary>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve.#ctor">
            <summary>Constructs a curve.</summary>
        </member>
        <member name="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve.IsConstant">
            <summary>Returns <c>true</c> if this curve is constant (has zero or one points); <c>false</c> otherwise.</summary>
        </member>
        <member name="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve.PreLoop">
            <summary>Defines how to handle weighting values that are less than the first control point in the curve.</summary>
        </member>
        <member name="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve.PostLoop">
            <summary>Defines how to handle weighting values that are greater than the last control point in the curve.</summary>
        </member>
        <member name="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve.Keys">
            <summary>The collection of curve keys.</summary>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve.Clone">
            <summary>Creates a copy of this curve.</summary>
            <returns>A copy of this curve.</returns>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve.Evaluate(System.Single)">
            <summary>Evaluate the value at a position of this <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve" />.</summary>
            <param name="position">The position on this <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve" />.</param>
            <returns>Value at the position on this <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve" />.</returns>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve.ComputeTangents(Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveTangent)">
            <summary>Computes tangents for all keys in the collection.</summary>
            <param name="tangentType">The tangent type for both in and out.</param>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve.ComputeTangents(Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveTangent,Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveTangent)">
            <summary>Computes tangents for all keys in the collection.</summary>
            <param name="tangentInType">The tangent in-type. <see cref="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.TangentIn" /> for more details.</param>
            <param name="tangentOutType">The tangent out-type. <see cref="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.TangentOut" /> for more details.</param>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve.ComputeTangent(System.Int32,Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveTangent)">
            <summary>Computes tangent for the specific key in the collection.</summary>
            <param name="keyIndex">The index of a key in the collection.</param>
            <param name="tangentType">The tangent type for both in and out.</param>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve.ComputeTangent(System.Int32,Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveTangent,Alis.Core.Physic.Extensions.Controllers.Wind.Curve.CurveTangent)">
            <summary>Computes tangent for the specific key in the collection.</summary>
            <param name="keyIndex">The index of key in the collection.</param>
            <param name="tangentInType">The tangent in-type. <see cref="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.TangentIn" /> for more details.</param>
            <param name="tangentOutType">The tangent out-type. <see cref="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.TangentOut" /> for more details.</param>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve.GetNumberOfCycle(System.Single)">
            <summary>
                Gets the number of cycle using the specified position
            </summary>
            <param name="position">The position</param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve.GetCurvePosition(System.Single)">
            <summary>
                Gets the curve position using the specified position
            </summary>
            <param name="position">The position</param>
            <returns>The float</returns>
        </member>
        <member name="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveContinuity">
            <summary>Defines the continuity of keys on a <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve" />.</summary>
        </member>
        <member name="F:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveContinuity.Smooth">
            <summary>Interpolation can be used between this key and the next.</summary>
        </member>
        <member name="F:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveContinuity.Step">
            <summary>Interpolation cannot be used. A position between the two points returns this point.</summary>
        </member>
        <member name="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey">
            <summary>Key point on the <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve" />.</summary>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.#ctor">
            <summary>Creates a new instance of <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" /> class with position: 0 and value: 0.</summary>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.#ctor(System.Single,System.Single)">
            <summary>Creates a new instance of <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" /> class.</summary>
            <param name="position">Position on the curve.</param>
            <param name="value">Value of the control point.</param>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>Creates a new instance of <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" /> class.</summary>
            <param name="position">Position on the curve.</param>
            <param name="value">Value of the control point.</param>
            <param name="tangentIn">Tangent approaching point from the previous point on the curve.</param>
            <param name="tangentOut">Tangent leaving point toward next point on the curve.</param>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.#ctor(System.Single,System.Single,System.Single,System.Single,Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveContinuity)">
            <summary>Creates a new instance of <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" /> class.</summary>
            <param name="position">Position on the curve.</param>
            <param name="value">Value of the control point.</param>
            <param name="tangentIn">Tangent approaching point from the previous point on the curve.</param>
            <param name="tangentOut">Tangent leaving point toward next point on the curve.</param>
            <param name="continuity">Indicates whether the curve is discrete or continuous.</param>
        </member>
        <member name="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.Continuity">
            <summary>
                Gets or sets the indicator whether the segment between this point and the next point on the curve is discrete
                or continuous.
            </summary>
        </member>
        <member name="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.Position">
            <summary>Gets a position of the key on the curve.</summary>
        </member>
        <member name="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.TangentIn">
            <summary>Gets or sets a tangent when approaching this point from the previous point on the curve.</summary>
        </member>
        <member name="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.TangentOut">
            <summary>Gets or sets a tangent when leaving this point to the next point on the curve.</summary>
        </member>
        <member name="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.Value">
            <summary>Gets a value of this point.</summary>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.CompareTo(Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey)">
            <summary>
                Compares the to using the specified other
            </summary>
            <param name="other">The other</param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.Equals(Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey)">
            <summary>
                Describes whether this instance equals
            </summary>
            <param name="other">The other</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.op_Inequality(Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey,Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey)">
            <summary>Compares whether two <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" /> instances are not equal.</summary>
            <param name="value1"><see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" /> instance on the left of the not equal sign.</param>
            <param name="value2"><see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" /> instance on the right of the not equal sign.</param>
            <returns><c>true</c> if the instances are not equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.op_Equality(Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey,Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey)">
            <summary>Compares whether two <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" /> instances are equal.</summary>
            <param name="value1"><see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" /> instance on the left of the equal sign.</param>
            <param name="value2"><see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" /> instance on the right of the equal sign.</param>
            <returns><c>true</c> if the instances are equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.Clone">
            <summary>Creates a copy of this key.</summary>
            <returns>A copy of this key.</returns>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.Equals(System.Object)">
            <summary>
                Describes whether this instance equals
            </summary>
            <param name="obj">The obj</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey.GetHashCode">
            <summary>
                Gets the hash code
            </summary>
            <returns>The int</returns>
        </member>
        <member name="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection">
            <summary>The collection of the <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" /> elements and a part of the <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.Curve" /> class.</summary>
        </member>
        <member name="F:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection.keys">
            <summary>
                The keys
            </summary>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection.#ctor">
            <summary>Creates a new instance of <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection" /> class.</summary>
        </member>
        <member name="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection.Item(System.Int32)">
            <summary>Indexer.</summary>
            <param name="index">The index of key in this collection.</param>
            <returns><see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey" /> at <paramref name="index" /> position.</returns>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Gets the enumerator
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection.Add(Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey)">
            <summary>Adds a key to this collection.</summary>
            <param name="item">New key for the collection.</param>
            <exception cref="T:System.ArgumentNullException">Throws if <paramref name="item" /> is null.</exception>
            <remarks>The new key would be added respectively to a position of that key and the position of other keys.</remarks>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection.Clear">
            <summary>Removes all keys from this collection.</summary>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection.Contains(Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey)">
            <summary>Determines whether this collection contains a specific key.</summary>
            <param name="item">The key to locate in this collection.</param>
            <returns><c>true</c> if the key is found; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection.CopyTo(Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey[],System.Int32)">
            <summary>Copies the keys of this collection to an array, starting at the array index provided.</summary>
            <param name="array">Destination array where elements will be copied.</param>
            <param name="arrayIndex">The zero-based index in the array to start copying from.</param>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>An enumerator for the <see cref="T:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection" />.</returns>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection.Remove(Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey)">
            <summary>Removes specific element.</summary>
            <param name="item">The element</param>
            <returns>
                <c>true</c> if item is successfully removed; <c>false</c> otherwise. This method also returns <c>false</c> if
                item was not found.
            </returns>
        </member>
        <member name="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection.Count">
            <summary>Returns the count of keys in this collection.</summary>
        </member>
        <member name="P:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection.IsReadOnly">
            <summary>Returns false because it is not a read-only collection.</summary>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection.Clone">
            <summary>Creates a copy of this collection.</summary>
            <returns>A copy of this collection.</returns>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection.IndexOf(Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKey)">
            <summary>Finds element in the collection and returns its index.</summary>
            <param name="item">Element for the search.</param>
            <returns>Index of the element; or -1 if item is not found.</returns>
        </member>
        <member name="M:Alis.Core.Systems.Physics2D.Config.Extensions.Controllers.Wind.Curve.CurveKeyCollection.RemoveAt(System.Int32)">
            <summary>Removes element at the specified index.</summary>
            <param name="index">The index which element will be removed.</param>
        </member>
    </members>
</doc>
