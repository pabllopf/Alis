### YamlMime:ApiPage
title: Namespace Alis.Core.Physic.Dynamics.Joints
body:
- api1: Namespace Alis.Core.Physic.Dynamics.Joints
  id: Alis_Core_Physic_Dynamics_Joints
  metadata:
    uid: Alis.Core.Physic.Dynamics.Joints
    commentId: N:Alis.Core.Physic.Dynamics.Joints
- h3: Classes
- parameters:
  - type:
      text: AngleJoint
      url: Alis.Core.Physic.Dynamics.Joints.AngleJoint.html
    description: Maintains a fixed angle between two bodies
  - type:
      text: DistanceJoint
      url: Alis.Core.Physic.Dynamics.Joints.DistanceJoint.html
    description: >-
      A distance joint constrains two points on two bodies to remain at a fixed distance from each other. You can

      view this as a massless, rigid rod.

      1-D constrained system

      m (v2 - v1) = lambda

      v2 + (beta/h) * x1 + gamma * lambda = 0, gamma has units of inverse mass.

      x2 = x1 + h * v2

      1-D mass-damper-spring system

      m (v2 - v1) + h * d * v2 + h * k *

      C = norm(p2 - p1) - L

      u = (p2 - p1) / norm(p2 - p1)

      dot = dot(u, v2 + cross(w2, r2) - v1 - cross(w1, r1))

      J = [-u -cross(r1, u) u cross(r2, u)]

      K = J * invM * JT

      = invMass1 + invI1 * cross(r1, u)^2 + invMass2 + invI2 * cross(r2, u)^2
  - type:
      text: FixedMouseJoint
      url: Alis.Core.Physic.Dynamics.Joints.FixedMouseJoint.html
    description: >-
      A mouse joint is used to make a point on a body track a specified world point. This a soft constraint with a

      maximum force. This allows the constraint to stretch and without applying huge forces. NOTE: this joint is not

      documented in the manual because it was developed to be used in the testbed. If you want to learn how to use the

      mouse

      joint, look at the testbed.

      p = attached point, m = mouse point

      C = p - m

      cDot = v

      = v + cross(w, r)

      J = [I r_skew]

      Identity used:

      w k % (rx i + ry j) = w * (-ry i + rx j)
  - type:
      text: FrictionJoint
      url: Alis.Core.Physic.Dynamics.Joints.FrictionJoint.html
    description: >-
      Friction joint. This is used for top-down friction. It provides 2D translational friction and angular

      friction.

      Point-to-point constraint

      cDot = v2 - v1

      = v2 + cross(w2, r2) - v1 - cross(w1, r1)

      J = [-I -r1_skew I r2_skew ]

      Identity used:

      w k % (rx i + ry j) = w * (-ry i + rx j)

      Angle constraint

      cDot = w2 - w1

      J = [0 0 -1 0 0 1]

      K = invI1 + invI2
  - type:
      text: GearJoint
      url: Alis.Core.Physic.Dynamics.Joints.GearJoint.html
    description: >-
      A gear joint is used to connect two joints together. Either joint can be a revolute or prismatic joint. You specify

      a

      gear ratio to bind the motions together:

      coordinate1 + ratio * coordinate2 = ant

      The ratio can be negative or positive. If one joint is a revolute joint and the other joint is a prismatic joint,

      then

      the ratio will have units of length or units of 1/length. Warning: You have to manually destroy the gear joint if

      jointA or jointB is destroyed.

      Gear Joint:

      C0 = (coordinate1 + ratio * coordinate2)_initial

      C = (coordinate1 + ratio * coordinate2) - C0 = 0

      J = [J1 ratio * J2]

      K = J * invM * JT

      = J1 * invM1 * J1T + ratio * ratio * J2 * invM2 * J2T

      Revolute:

      coordinate = rotation

      Cdo = angularVelocity

      J = [0 0 1]

      K = J * invM * JT = invI

      Prismatic:

      coordinate = dot(p - pg, ug)

      Cdo = dot(v + cross(w, r), ug)

      J = [ug cross(r, ug)]

      K = J * invM * JT = invMass + invI * cross(r, ug)^2
  - type:
      text: Joint
      url: Alis.Core.Physic.Dynamics.Joints.Joint.html
    description: The joint class
  - type:
      text: JointEdge
      url: Alis.Core.Physic.Dynamics.Joints.JointEdge.html
    description: >-
      A joint edge is used to connect bodies and joints together in a joint graph where each body is a node and each

      joint is an edge. A joint edge belongs to a doubly linked list maintained in each attached body. Each joint has two

      joint nodes, one for each attached body.
  - type:
      text: MotorJoint
      url: Alis.Core.Physic.Dynamics.Joints.MotorJoint.html
    description: >-
      A motor joint is used to control the relative motion between two bodies. A typical usage is to control the

      movement of a dynamic body with respect to the ground.
  - type:
      text: PrismaticJoint
      url: Alis.Core.Physic.Dynamics.Joints.PrismaticJoint.html
    description: >-
      A prismatic joint. This joint provides one degree of freedom: translation along an axis fixed in bodyA.

      Relative rotation is prevented. You can use a joint limit to restrict the range of motion and a joint motor to

      drive

      the motion or to model joint friction.

      Linear constraint (point-to-line)

      d = p2 - p1 = x2 + r2 - x1 - r1

      C = dot(perp, d)

      Cdo = dot(d, cross(w1, perp)) + dot(perp, v2 + cross(w2, r2) - v1 - cross(w1, r1))

      = -dot(perp, v1) - dot(cross(d + r1, perp), w1) + dot(perp, v2) + dot(cross(r2, perp), v2)

      J = [-perp, -cross(d + r1, perp), perp, cross(r2,perp)]

      Angular constraint

      C = a2 - a1 + a_initial

      Cdo = w2 - w1

      J = [0 0 -1 0 0 1]

      K = J * invM * JT

      J = [-a -s1 a s2]

      [0  -1  0  1]

      a = perp

      s1 = cross(d + r1, a) = cross(p2 - x1, a)

      s2 = cross(r2, a) = cross(p2 - x2, a)

      Motor/Limit linear constraint

      C = dot(ax1, d)

      Cdo = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) + dot(cross(r2, ax1), v2)

      J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]

      Predictive limit is applied even when the limit is not active.

      Prevents a constraint speed that can lead to a constraint error in one time step.

      Want C2 = C1 + h * Cdo &gt;= 0

      Or:

      Cdo + C1/h &gt;= 0

      I do not apply a negative constraint error because that is handled in position correction.

      So:

      Cdo + max(C1, 0)/h &gt;= 0

      Block Solver

      We develop a block solver that includes the angular and linear constraints. This makes the limit stiffer.

      The Jacobin has 2 rows:

      J = [-uT -s1 uT s2] /// linear

      [0   -1   0  1] /// angular

      u = perp

      s1 = cross(d + r1, u), s2 = cross(r2, u)

      a1 = cross(d + r1, v), a2 = cross(r2, v)
  - type:
      text: PulleyJoint
      url: Alis.Core.Physic.Dynamics.Joints.PulleyJoint.html
    description: >-
      The pulley joint is connected to two bodies and two fixed world points. The pulley supports a ratio such that:

      length1 + ratio * length2 &lt;= constant

      Yes, the force transmitted is scaled by the ratio. Warning: the pulley joint can get a bit squirrelly by itself.

      They

      often work better when combined with prismatic joints. You should also cover the the anchor points with static

      shapes

      to prevent one side from going to zero length.

      Pulley:

      length1 = norm(p1 - s1)

      length2 = norm(p2 - s2)

      C0 = (length1 + ratio * length2)_initial

      C = C0 - (length1 + ratio * length2)

      u1 = (p1 - s1) / norm(p1 - s1)

      u2 = (p2 - s2) / norm(p2 - s2)

      cDot = -dot(u1, v1 + cross(w1, r1)) - ratio * dot(u2, v2 + cross(w2, r2))

      J = -[u1 cross(r1, u1) ratio * u2  ratio * cross(r2, u2)]

      K = J * invM * JT

      = invMass1 + invI1 * cross(r1, u1)^2 + ratio^2 * (invMass2 + invI2 * cross(r2, u2)^2)
  - type:
      text: RevoluteJoint
      url: Alis.Core.Physic.Dynamics.Joints.RevoluteJoint.html
    description: >-
      A revolute joint constrains to bodies to share a common point while they are free to rotate about the point.

      The relative rotation about the shared point is the joint angle. You can limit the relative rotation with a joint

      limit

      that specifies a lower and upper angle. You can use a motor to drive the relative rotation about the shared point.

      A

      maximum motor torque is provided so that infinite forces are not generated.

      Point-to-point constraint

      C = p2 - p1

      dot = v2 - v1

      = v2 + cross(w2, r2) - v1 - cross(w1, r1)

      J = [-I -r1_skew I r2_skew ]

      Identity used:

      w k % (rx i + ry j) = w * (-ry i + rx j)

      Motor constraint

      dot = w2 - w1

      J = [0 0 -1 0 0 1]

      K = invI1 + invI2
  - type:
      text: WeldJoint
      url: Alis.Core.Physic.Dynamics.Joints.WeldJoint.html
    description: >-
      A weld joint essentially glues two bodies together. A weld joint may distort somewhat because the island

      constraint solver is approximate. The joint is soft constraint based, which means the two bodies will move relative

      to

      each other, when a force is applied. To combine two bodies in a rigid fashion, combine the fixtures to a single

      body

      instead.
  - type:
      text: WheelJoint
      url: Alis.Core.Physic.Dynamics.Joints.WheelJoint.html
    description: >-
      A wheel joint. This joint provides two degrees of freedom: translation along an axis fixed in bodyA and

      rotation in the plane. In other words, it is a point to line constraint with a rotational motor and a linear

      spring/damper. The spring/damper is initialized upon creation. This joint is designed for vehicle suspensions.

      Linear constraint (point-to-line)

      d = pB - pA = xB + rB - xA - rA

      C = dot(ay, d)

      Cdo = dot(d, cross(wA, ay)) + dot(ay, vB + cross(wB, rB) - vA - cross(wA, rA))

      = -dot(ay, vA) - dot(cross(d + rA, ay), wA) + dot(ay, vB) + dot(cross(rB, ay), vB)

      J = [-ay, -cross(d + rA, ay), ay, cross(rB, ay)]

      Spring linear constraint

      C = dot(ax, d)

      Cdo = = -dot(ax, vA) - dot(cross(d + rA, ax), wA) + dot(ax, vB) + dot(cross(rB, ax), vB)

      J = [-ax -cross(d+rA, ax) ax cross(rB, ax)]

      Motor rotational constraint

      Cdo = wB - wA

      J = [0 0 -1 0 0 1]
- h3: Enums
- parameters:
  - type:
      text: JointType
      url: Alis.Core.Physic.Dynamics.Joints.JointType.html
    description: The joint type enum
  - type:
      text: LimitState
      url: Alis.Core.Physic.Dynamics.Joints.LimitState.html
    description: The limit state enum
languageId: csharp
