<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Alis.Extension.Math.PathGenerator</name>
    </assembly>
    <members>
        <member name="T:Alis.Extension.Math.PathGenerator.ConvexHull.GiftWrap">
            <summary>
                The gift wrap class
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.ConvexHull.GiftWrap.GetConvexHull(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Gets the convex hull using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <returns>The vertices</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.ConvexHull.GiftWrap.FindRightmostPoint(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Finds the rightmost point using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.ConvexHull.GiftWrap.CalculateConvexHull(Alis.Core.Physic.Shared.Vertices,System.Int32,System.Int32[])">
            <summary>
                Calculates the convex hull using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <param name="i0">The </param>
            <param name="hull">The hull</param>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.ConvexHull.GiftWrap.CreateResultVertices(Alis.Core.Physic.Shared.Vertices,System.Int32[],System.Int32)">
            <summary>
                Creates the result vertices using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <param name="hull">The hull</param>
            <param name="m">The </param>
            <returns>The result</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Path">
            <summary>
                Path: Very similar to Vertices, but this class contains vectors describing control points on a Catmull-Rom
                curve.
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Path.controlPoints">
            <summary>All the points that makes up the curve</summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Path.deltaT">
            <summary>
                The delta
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Path" /> class.</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.#ctor(Alis.Core.Aspect.Math.Vector.Vector2[])">
            <summary>Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Path" /> class.</summary>
            <param name="vertices">The vertices to created the path from.</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.#ctor(System.Collections.Generic.IList{Alis.Core.Aspect.Math.Vector.Vector2})">
            <summary>Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Path" /> class.</summary>
            <param name="vertices">The vertices to created the path from.</param>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Path.Closed">
            <summary>True if the curve is closed.</summary>
            <value><c>true</c> if closed; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.NextIndex(System.Int32)">
            <summary>Gets the next index of a controlpoint</summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.PreviousIndex(System.Int32)">
            <summary>Gets the previous index of a controlpoint</summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.Translate(Alis.Core.Aspect.Math.Vector.Vector2@)">
            <summary>Translates the control points by the specified vector.</summary>
            <param name="vector">The vector.</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.Scale(Alis.Core.Aspect.Math.Vector.Vector2@)">
            <summary>Scales the control points by the specified vector.</summary>
            <param name="value">The Value.</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.Rotate(System.Single)">
            <summary>Rotate the control points by the defined value in radians.</summary>
            <param name="value">The amount to rotate by in radians.</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.ToString">
            <summary>
                Returns the string
            </summary>
            <returns>The string</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.GetVertices(System.Int32)">
            <summary>Returns a set of points defining the curve with the specifed number of divisions between each control point.</summary>
            <param name="divisions">Number of divisions between each control point.</param>
            <returns></returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.GetPosition(System.Single)">
            <summary>
                Gets the position using the specified time
            </summary>
            <param name="time">The time</param>
            <exception cref="T:System.Exception">You need at least 2 control points to calculate a position.</exception>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.CalculatePositionWhenClosed(System.Int32,System.Single)">
            <summary>
                Calculates the position when closed using the specified p
            </summary>
            <param name="p">The </param>
            <param name="time">The time</param>
            <returns>The temp</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.CalculatePositionWhenNotClosed(System.Int32,System.Single)">
            <summary>
                Calculates the position when not closed using the specified p
            </summary>
            <param name="p">The </param>
            <param name="time">The time</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.CalculatePosition(System.Int32,System.Single)">
            <summary>
                Calculates the position using the specified p
            </summary>
            <param name="p">The </param>
            <param name="time">The time</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.AdjustIndex(System.Int32)">
            <summary>
                Adjusts the index using the specified index
            </summary>
            <param name="index">The index</param>
            <returns>The index</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.CatmullRom(Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2,System.Single)">
            <summary>
                Catmulls the rom using the specified value 1
            </summary>
            <param name="value1">The value</param>
            <param name="value2">The value</param>
            <param name="value3">The value</param>
            <param name="value4">The value</param>
            <param name="amount">The amount</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.GetPositionNormal(System.Single)">
            <summary>Gets the normal for the given time.</summary>
            <param name="time">The time</param>
            <returns>The normal.</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.Add(Alis.Core.Aspect.Math.Vector.Vector2)">
            <summary>
                Adds the point
            </summary>
            <param name="point">The point</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.Remove(Alis.Core.Aspect.Math.Vector.Vector2)">
            <summary>
                Removes the point
            </summary>
            <param name="point">The point</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.RemoveAt(System.Int32)">
            <summary>
                Removes the at using the specified index
            </summary>
            <param name="index">The index</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.GetLength">
            <summary>
                Gets the length
            </summary>
            <returns>The length</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Path.SubdivideEvenly(System.Int32)">
            <summary>
                Subdivides the evenly using the specified divisions
            </summary>
            <param name="divisions">The divisions</param>
            <returns>The verts</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.PathManager">
            <summary>An easy to use manager for creating paths.</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.PathManager.ConvertPathToEdges(Alis.Extension.Math.PathGenerator.Path,Alis.Core.Physic.Dynamics.Body,System.Int32)">
            <summary>Convert a path into a set of edges and attaches them to the specified body. Note: use only for static edges.</summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="subdivisions">The subdivisions.</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.PathManager.ConvertPathToPolygon(Alis.Extension.Math.PathGenerator.Path,Alis.Core.Physic.Dynamics.Body,System.Single,System.Int32)">
            <summary>Convert a closed path into a polygon. Convex decomposition is automatically performed.</summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="density">The density.</param>
            <param name="subdivisions">The subdivisions.</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.PathManager.EvenlyDistributeShapesAlongPath(Alis.Core.Physic.World,Alis.Extension.Math.PathGenerator.Path,System.Collections.Generic.IEnumerable{Alis.Core.Physic.Collision.Shapes.AShape},Alis.Core.Physic.Dynamics.BodyType,System.Int32,System.Object)">
            <summary>Duplicates the given Body along the given path for approximately the given copies.</summary>
            <param name="world">The world.</param>
            <param name="path">The path.</param>
            <param name="shapes">The shapes.</param>
            <param name="type">The type.</param>
            <param name="copies">The copies.</param>
            <param name="userData"></param>
            <returns></returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.PathManager.EvenlyDistributeShapesAlongPath(Alis.Core.Physic.World,Alis.Extension.Math.PathGenerator.Path,Alis.Core.Physic.Collision.Shapes.AShape,Alis.Core.Physic.Dynamics.BodyType,System.Int32,System.Object)">
            <summary>Duplicates the given Body along the given path for approximately the given copies.</summary>
            <param name="world">The world.</param>
            <param name="path">The path.</param>
            <param name="shape">The shape.</param>
            <param name="type">The type.</param>
            <param name="copies">The copies.</param>
            <param name="userData">The user data.</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.PathManager.MoveBodyOnPath(Alis.Extension.Math.PathGenerator.Path,Alis.Core.Physic.Dynamics.Body,System.Single,System.Single,System.Single)">
            <summary>Moves the given body along the defined path.</summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="time">The time.</param>
            <param name="strength">The strength.</param>
            <param name="timeStep">The time step.</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.PathManager.AttachBodiesWithRevoluteJoint(Alis.Core.Physic.World,System.Collections.Generic.List{Alis.Core.Physic.Dynamics.Body},Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2,System.Boolean,System.Boolean)">
            <summary>Attaches the bodies with revolute joints.</summary>
            <param name="world">The world.</param>
            <param name="bodies">The bodies.</param>
            <param name="localAnchorA">The local anchor A.</param>
            <param name="localAnchorB">The local anchor B.</param>
            <param name="connectFirstAndLast">if set to <c>true</c> [connect first and last].</param>
            <param name="collideConnected">if set to <c>true</c> [collide connected].</param>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.TextureTools.DataSizeException">
            <summary>
                The data size exception class
            </summary>
            <seealso cref="T:System.Exception" />
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.DataSizeException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.TextureTools.DataSizeException" /> class
            </summary>
            <param name="message">The message</param>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter">
            <summary>
                The texture converter class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.ClosePixelsLength">
            <summary>
                The close pixels length
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.ClosePixels">
            <summary>
                The close pixels
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.alphaTolerance">
            <summary>
                The alpha tolerance
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.data">
            <summary>
                The data
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.dataLength">
            <summary>
                The data length
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.height">
            <summary>
                The height
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.holeDetection">
            <summary>
                The hole detection
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.hullTolerance">
            <summary>
                The hull tolerance
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.multipartDetection">
            <summary>
                The multipart detection
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.polygonDetectionType">
            <summary>
                The polygon detection type
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.tempIsSolidX">
            <summary>
                The temp is solid
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.tempIsSolidY">
            <summary>
                The temp is solid
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.transform">
            <summary>
                The identity
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.width">
            <summary>
                The width
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter" /> class
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.#ctor(System.Nullable{System.Byte},System.Nullable{System.Single},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{Alis.Core.Aspect.Math.Matrix.Matrix4X4})">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter" /> class
            </summary>
            <param name="alphaTolerance">The alpha tolerance</param>
            <param name="hullTolerance">The hull tolerance</param>
            <param name="holeDetection">The hole detection</param>
            <param name="multipartDetection">The multipart detection</param>
            <param name="transform">The transform</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.#ctor(System.UInt32[],System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter" /> class
            </summary>
            <param name="data">The data</param>
            <param name="width">The width</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.#ctor(System.UInt32[],System.Int32,System.Nullable{System.Byte},System.Nullable{System.Single},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{Alis.Core.Aspect.Math.Matrix.Matrix4X4})">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter" /> class
            </summary>
            <param name="data">The data</param>
            <param name="width">The width</param>
            <param name="alphaTolerance">The alpha tolerance</param>
            <param name="hullTolerance">The hull tolerance</param>
            <param name="holeDetection">The hole detection</param>
            <param name="multipartDetection">The multipart detection</param>
            <param name="transform">The transform</param>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.PolygonDetectionType">
            <summary>
                Gets or sets the value of the polygon detection type
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.HoleDetection">
            <summary>
                Gets or sets the value of the hole detection
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.MultipartDetection">
            <summary>
                Gets or sets the value of the multipart detection
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.Transform">
            <summary>
                Gets or sets the value of the transform
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.AlphaTolerance">
            <summary>
                Gets or sets the value of the alpha tolerance
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.HullTolerance">
            <summary>
                Gets or sets the value of the hull tolerance
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.Initialize(System.UInt32[],System.Nullable{System.Int32},System.Nullable{System.Byte},System.Nullable{System.Single},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{Alis.Core.Aspect.Math.Matrix.Matrix4X4})">
            <summary>
                Initializes the data local
            </summary>
            <param name="dataLocal">The data local</param>
            <param name="widthLocal">The width local</param>
            <param name="alphaToleranceLocal">The alpha tolerance local</param>
            <param name="hullToleranceLocal">The hull tolerance local</param>
            <param name="holeDetectionLocal">The hole detection local</param>
            <param name="multipartDetectionLocal">The multipart detection local</param>
            <param name="transformLocal">The transform local</param>
            <exception cref="T:System.ArgumentNullException">'data' can't be null if 'width' is set.</exception>
            <exception cref="T:System.ArgumentNullException">'width' can't be null if 'data' is set.</exception>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.SetTextureData(System.UInt32[],System.Int32)">
            <summary>
                Sets the texture data using the specified data local
            </summary>
            <param name="dataLocal">The data local</param>
            <param name="widthLocal">The width local</param>
            <exception cref="T:System.ArgumentNullException">'data' can't be null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                'data' length can't be less then 4. Your texture must be at least 2 x 2
                pixels in size.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                'width' can't be less then 2. Your texture must be at least 2 x 2 pixels
                in size.
            </exception>
            <exception cref="T:System.ArgumentException">'width' has an invalid value.</exception>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.DetectVertices(System.UInt32[],System.Int32)">
            <summary>
                Detects the vertices using the specified data
            </summary>
            <param name="data">The data</param>
            <param name="width">The width</param>
            <returns>The vertices</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.DetectVertices(System.UInt32[],System.Int32,System.Boolean)">
            <summary>
                Detects the vertices using the specified data
            </summary>
            <param name="data">The data</param>
            <param name="width">The width</param>
            <param name="holeDetection">The hole detection</param>
            <returns>The vertices</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.DetectVertices(System.UInt32[],System.Int32,System.Single,System.Byte,System.Boolean,System.Boolean)">
            <summary>
                Detects the vertices using the specified data
            </summary>
            <param name="data">The data</param>
            <param name="width">The width</param>
            <param name="hullTolerance">The hull tolerance</param>
            <param name="alphaTolerance">The alpha tolerance</param>
            <param name="multiPartDetection">The multi part detection</param>
            <param name="holeDetection">The hole detection</param>
            <returns>The result</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.DetectVertices">
            <summary>
                Detects the vertices
            </summary>
            <exception cref="T:System.Exception">Couldn't detect any vertices.</exception>
            <returns>The detected polygons</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.CreatePolygon(System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices},System.Nullable{Alis.Core.Aspect.Math.Vector.Vector2}@)">
            <summary>
                Creates the polygon using the specified detected polygons
            </summary>
            <param name="detectedPolygons">The detected polygons</param>
            <param name="polygonEntrance">The polygon entrance</param>
            <returns>The vertices</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.ProcessHoleDetection(Alis.Core.Physic.Shared.Vertices,System.Nullable{Alis.Core.Aspect.Math.Vector.Vector2}@,System.Collections.Generic.List{Alis.Core.Aspect.Math.Vector.Vector2})">
            <summary>
                Processes the hole detection using the specified polygon
            </summary>
            <param name="polygon">The polygon</param>
            <param name="holeEntrance">The hole entrance</param>
            <param name="blackList">The black list</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.AddPolygonToList(System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices},Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Adds the polygon to list using the specified detected polygons
            </summary>
            <param name="detectedPolygons">The detected polygons</param>
            <param name="polygon">The polygon</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.CreateInitialPolygon(System.Nullable{Alis.Core.Aspect.Math.Vector.Vector2}@)">
            <summary>
                Creates the initial polygon using the specified polygon entrance
            </summary>
            <param name="polygonEntrance">The polygon entrance</param>
            <returns>The polygon</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.CreateNextPolygon(Alis.Core.Aspect.Math.Vector.Vector2)">
            <summary>
                Creates the next polygon using the specified entrance
            </summary>
            <param name="entrance">The entrance</param>
            <returns>The vertices</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.ProcessHolePolygon(Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Processes the hole polygon using the specified polygon
            </summary>
            <param name="polygon">The polygon</param>
            <param name="holeEntrance">The hole entrance</param>
            <param name="holePolygon">The hole polygon</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.PostProcessPolygons(System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices}@)">
            <summary>
                Posts the process polygons using the specified detected polygons
            </summary>
            <param name="detectedPolygons">The detected polygons</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.ValidateInput">
            <summary>
                Validates the input
            </summary>
            <exception cref="T:Alis.Extension.Math.PathGenerator.TextureTools.DataSizeException">
                'data' can't be null. You have to use SetTextureData(uint[] data, int width) before
                calling this method.
            </exception>
            <exception cref="T:Alis.Extension.Math.PathGenerator.TextureTools.DataSizeException">
                'data' length can't be less than 4. Your texture must be at least 2 x 2 pixels in
                size. You have to use SetTextureData(uint[] data, int width) before calling this method.
            </exception>
            <exception cref="T:Alis.Extension.Math.PathGenerator.TextureTools.DataSizeException">
                'width' can't be less than 2. Your texture must be at least 2 x 2 pixels in size.
                You have to use SetTextureData(uint[] data, int width) before calling this method.
            </exception>
            <exception cref="T:Alis.Extension.Math.PathGenerator.TextureTools.DataSizeException">
                'width' has an invalid value. You have to use SetTextureData(uint[] data, int
                width) before calling this method.
            </exception>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.ApplyTriangulationCompatibleWinding(System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices}@)">
            <summary>
                Applies the triangulation compatible winding using the specified detected polygons
            </summary>
            <param name="detectedPolygons">The detected polygons</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.ApplyTransform(System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices}@)">
            <summary>
                Applies the transform using the specified detected polygons
            </summary>
            <param name="detectedPolygons">The detected polygons</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.SearchHoleEntrance(Alis.Core.Physic.Shared.Vertices,System.Nullable{Alis.Core.Aspect.Math.Vector.Vector2})">
            <summary>
                Searches the hole entrance using the specified polygon
            </summary>
            <param name="polygon">The polygon</param>
            <param name="lastHoleEntrance">The last hole entrance</param>
            <exception cref="T:System.ArgumentException">'polygon.MainPolygon.Count' can't be less then 3.</exception>
            <exception cref="T:System.ArgumentNullException">polygon</exception>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.DetermineStartAndEndY(Alis.Core.Physic.Shared.Vertices,System.Nullable{Alis.Core.Aspect.Math.Vector.Vector2},System.Int32@,System.Int32@)">
            <summary>
                Determines the start and end y using the specified polygon
            </summary>
            <param name="polygon">The polygon</param>
            <param name="lastHoleEntrance">The last hole entrance</param>
            <param name="startY">The start</param>
            <param name="endY">The end</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.ProcessXCoordinates(System.Collections.Generic.List{System.Single},System.Int32)">
            <summary>
                Processes the x coordinates using the specified x coords
            </summary>
            <param name="xCoords">The coords</param>
            <param name="y">The </param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.DistanceToHullAcceptableHoles(Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Vector.Vector2,System.Boolean)">
            <summary>
                Describes whether this instance distance to hull acceptable holes
            </summary>
            <param name="polygon">The polygon</param>
            <param name="point">The point</param>
            <param name="higherDetail">The higher detail</param>
            <exception cref="T:System.ArgumentNullException">'polygon' can't be null.</exception>
            <exception cref="T:System.ArgumentException">'polygon.MainPolygon.Count' can't be less then 3.</exception>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.DistanceToHullAcceptable(Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Vector.Vector2,System.Boolean)">
            <summary>
                Describes whether this instance distance to hull acceptable
            </summary>
            <param name="polygon">The polygon</param>
            <param name="point">The point</param>
            <param name="higherDetail">The higher detail</param>
            <exception cref="T:System.ArgumentNullException">'polygon' can't be null.</exception>
            <exception cref="T:System.ArgumentException">'polygon.Count' can't be less then 3.</exception>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.InPolygon(Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Vector.Vector2)">
            <summary>
                Describes whether this instance in polygon
            </summary>
            <param name="polygon">The polygon</param>
            <param name="point">The point</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.GetTopMostVertex(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Gets the top most vertex using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <returns>The top most</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.GetTopMostCoordinate(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Gets the top most coordinate using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <returns>The return value</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.GetBottomMostCoordinate(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Gets the bottom most coordinate using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <returns>The return value</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.SearchCrossingEdgesHoles(Alis.Core.Physic.Shared.Vertices,System.Int32)">
            <summary>
                Searches the crossing edges holes using the specified polygon
            </summary>
            <param name="polygon">The polygon</param>
            <param name="y">The </param>
            <exception cref="T:System.ArgumentNullException">'polygon' can't be null.</exception>
            <exception cref="T:System.ArgumentException">'polygon.MainPolygon.Count' can't be less then 3.</exception>
            <returns>The result</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.SearchEdges(Alis.Core.Physic.Shared.Vertices,System.Int32)">
            <summary>
                Searches the edges using the specified polygon
            </summary>
            <param name="polygon">The polygon</param>
            <param name="y">The </param>
            <returns>The edges</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.IterateSearchEdges(Alis.Core.Physic.Shared.Vertices,System.Int32,System.Collections.Generic.List{System.Single})">
            <summary>
                Iterates the search edges using the specified polygon
            </summary>
            <param name="polygon">The polygon</param>
            <param name="y">The </param>
            <param name="edges">The edges</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.Find(Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Physic.Shared.Vertices,System.Int32,System.Int32)">
            <summary>
                Describes whether this instance find
            </summary>
            <param name="vertex1">The vertex</param>
            <param name="vertex2">The vertex</param>
            <param name="polygon">The polygon</param>
            <param name="index">The index</param>
            <param name="y">The </param>
            <returns>The add find</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.SplitPolygonEdge(Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Vector.Vector2,System.Int32@)">
            <summary>
                Describes whether this instance split polygon edge
            </summary>
            <param name="polygon">The polygon</param>
            <param name="coordinateInsideThePolygon">The coordinate inside the polygon</param>
            <param name="vertex2Index">The vertex index</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.FindEdgeCoordinate(System.Collections.Generic.List{System.Single},Alis.Core.Aspect.Math.Vector.Vector2)">
            <summary>
                Finds the edge coordinate using the specified x coords
            </summary>
            <param name="xCoords">The coords</param>
            <param name="coordinateInsideThePolygon">The coordinate inside the polygon</param>
            <returns>The found edge coordinate</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.FindNearestEdgeVertices(Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Vector.Vector2)">
            <summary>
                Finds the nearest edge vertices using the specified polygon
            </summary>
            <param name="polygon">The polygon</param>
            <param name="foundEdgeCoordinate">The found edge coordinate</param>
            <returns>The int array</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.InsertNewVertices(Alis.Core.Physic.Shared.Vertices,System.Int32[],Alis.Core.Aspect.Math.Vector.Vector2)">
            <summary>
                Inserts the new vertices using the specified polygon
            </summary>
            <param name="polygon">The polygon</param>
            <param name="nearestEdgeVertices">The nearest edge vertices</param>
            <param name="foundEdgeCoordinate">The found edge coordinate</param>
            <returns>The vertex index</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.CreateSimplePolygon(Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2)">
            <summary>
                Creates the simple polygon using the specified entrance
            </summary>
            <param name="entrance">The entrance</param>
            <param name="last">The last</param>
            <returns>The polygon</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.GetEntrancePoint(Alis.Core.Aspect.Math.Vector.Vector2@,Alis.Core.Aspect.Math.Vector.Vector2@,Alis.Core.Aspect.Math.Vector.Vector2@)">
            <summary>
                Describes whether this instance get entrance point
            </summary>
            <param name="entrance">The entrance</param>
            <param name="last">The last</param>
            <param name="current">The current</param>
            <returns>The entrance found</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.ProcessOutstandingVertex(System.Boolean@,Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Processes the outstanding vertex using the specified end of hull
            </summary>
            <param name="endOfHull">The end of hull</param>
            <param name="hullArea">The hull area</param>
            <param name="endOfHullArea">The end of hull area</param>
            <param name="polygon">The polygon</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.SearchNearPixels(System.Boolean,Alis.Core.Aspect.Math.Vector.Vector2@,Alis.Core.Aspect.Math.Vector.Vector2@)">
            <summary>
                Describes whether this instance search near pixels
            </summary>
            <param name="searchingForSolidPixel">The searching for solid pixel</param>
            <param name="current">The current</param>
            <param name="foundPixel">The found pixel</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.IsNearPixel(Alis.Core.Aspect.Math.Vector.Vector2@,Alis.Core.Aspect.Math.Vector.Vector2@)">
            <summary>
                Describes whether this instance is near pixel
            </summary>
            <param name="current">The current</param>
            <param name="near">The near</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.SearchHullEntrance(Alis.Core.Aspect.Math.Vector.Vector2@)">
            <summary>
                Describes whether this instance search hull entrance
            </summary>
            <param name="entrance">The entrance</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.SearchNextHullEntrance(System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices},Alis.Core.Aspect.Math.Vector.Vector2,System.Nullable{Alis.Core.Aspect.Math.Vector.Vector2}@)">
            <summary>
                Describes whether this instance search next hull entrance
            </summary>
            <param name="detectedPolygons">The detected polygons</param>
            <param name="start">The start</param>
            <param name="entrance">The entrance</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.CalculateStartIndex(Alis.Core.Aspect.Math.Vector.Vector2)">
            <summary>
                Calculates the start index using the specified start
            </summary>
            <param name="start">The start</param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.CalculateEntrance(System.Int32)">
            <summary>
                Calculates the entrance using the specified i
            </summary>
            <param name="i">The </param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.IsInPolygon(System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices},Alis.Core.Aspect.Math.Vector.Vector2)">
            <summary>
                Describes whether this instance is in polygon
            </summary>
            <param name="detectedPolygons">The detected polygons</param>
            <param name="entrance">The entrance</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.GetNextHullPoint(Alis.Core.Aspect.Math.Vector.Vector2@,Alis.Core.Aspect.Math.Vector.Vector2@,Alis.Core.Aspect.Math.Vector.Vector2@)">
            <summary>
                Describes whether this instance get next hull point
            </summary>
            <param name="last">The last</param>
            <param name="current">The current</param>
            <param name="next">The next</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.SearchForOutstandingVertex(Alis.Core.Physic.Shared.Vertices,Alis.Core.Aspect.Math.Vector.Vector2@)">
            <summary>
                Describes whether this instance search for outstanding vertex
            </summary>
            <param name="hullArea">The hull area</param>
            <param name="outstanding">The outstanding</param>
            <returns>The found</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.GetIndexOfFirstPixelToCheck(Alis.Core.Aspect.Math.Vector.Vector2@,Alis.Core.Aspect.Math.Vector.Vector2@)">
            <summary>
                Gets the index of first pixel to check using the specified last
            </summary>
            <param name="last">The last</param>
            <param name="current">The current</param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.IsSolid(Alis.Core.Aspect.Math.Vector.Vector2@)">
            <summary>
                Describes whether this instance is solid
            </summary>
            <param name="v">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.IsSolid(System.Int32@,System.Int32@)">
            <summary>
                Describes whether this instance is solid
            </summary>
            <param name="x">The </param>
            <param name="y">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.IsSolid(System.Int32@)">
            <summary>
                Describes whether this instance is solid
            </summary>
            <param name="index">The index</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.TextureTools.TextureConverter.InBounds(Alis.Core.Aspect.Math.Vector.Vector2@)">
            <summary>
                Describes whether this instance in bounds
            </summary>
            <param name="coordinate">The coordinate</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.TextureTools.VerticesDetectionType">
            <summary>The detection type affects the resulting polygon data.</summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.VerticesDetectionType.Integrated">
            <summary>Holes are integrated into the main polygon.</summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.TextureTools.VerticesDetectionType.Separated">
            <summary>The data of the main polygon and hole polygons is returned separately.</summary>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer">
            <summary>
                The baya zit decomposer class
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.ConvexPartition(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Decompose the polygon into several smaller non-concave polygon. If the polygon is already convex, it will
                return the original polygon, unless it is over Settings.MaxPolygonVertices.
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.TriangulatePolygon(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Triangulates the polygon using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <returns>The list</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.ProcessEdgeIntersection(System.Int32,System.Int32,Alis.Core.Physic.Shared.Vertices,System.Single@,Alis.Core.Aspect.Math.Vector.Vector2@,System.Int32@)">
            <summary>
                Processes the edge intersection using the specified i
            </summary>
            <param name="i">The </param>
            <param name="j">The </param>
            <param name="vertices">The vertices</param>
            <param name="dist">The dist</param>
            <param name="intersection">The intersection</param>
            <param name="index">The index</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.HandleNoVerticesToConnect(System.Int32,System.Int32,System.Int32,Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Physic.Shared.Vertices,System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices})">
            <summary>
                Handles the no vertices to connect using the specified i
            </summary>
            <param name="i">The </param>
            <param name="lowerIndex">The lower index</param>
            <param name="upperIndex">The upper index</param>
            <param name="lowerInt">The lower int</param>
            <param name="upperInt">The upper int</param>
            <param name="vertices">The vertices</param>
            <param name="list">The list</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.HandleVerticesToConnect(System.Int32,System.Int32,System.Int32,Alis.Core.Physic.Shared.Vertices,System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices})">
            <summary>
                Handles the vertices to connect using the specified i
            </summary>
            <param name="i">The </param>
            <param name="lowerIndex">The lower index</param>
            <param name="upperIndex">The upper index</param>
            <param name="vertices">The vertices</param>
            <param name="list">The list</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.AdjustUpperIndex(System.Int32@,System.Int32,System.Int32)">
            <summary>
                Adjusts the upper index using the specified upper index
            </summary>
            <param name="upperIndex">The upper index</param>
            <param name="lowerIndex">The lower index</param>
            <param name="verticesCount">The vertices count</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.FindBestIndex(System.Int32,System.Int32,System.Int32,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Finds the best index using the specified i
            </summary>
            <param name="i">The </param>
            <param name="lowerIndex">The lower index</param>
            <param name="upperIndex">The upper index</param>
            <param name="vertices">The vertices</param>
            <returns>The best index</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.ComputeScore(System.Int32,System.Int32,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Computes the score using the specified i
            </summary>
            <param name="i">The </param>
            <param name="j">The </param>
            <param name="vertices">The vertices</param>
            <returns>The score</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.DecomposeIntoPolygons(System.Int32,System.Int32,Alis.Core.Physic.Shared.Vertices,System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices})">
            <summary>
                Decomposes the into polygons using the specified i
            </summary>
            <param name="i">The </param>
            <param name="bestIndex">The best index</param>
            <param name="vertices">The vertices</param>
            <param name="list">The list</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.HandleConvexPolygon(Alis.Core.Physic.Shared.Vertices,System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices})">
            <summary>
                Handles the convex polygon using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <param name="list">The list</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.At(System.Int32,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Ats the i
            </summary>
            <param name="i">The </param>
            <param name="vertices">The vertices</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.Copy(System.Int32,System.Int32,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Copies the i
            </summary>
            <param name="i">The </param>
            <param name="j">The </param>
            <param name="vertices">The vertices</param>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.CanSee(System.Int32,System.Int32,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Describes whether can see
            </summary>
            <param name="i">The </param>
            <param name="j">The </param>
            <param name="vertices">The vertices</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.IsValidVisibility(System.Int32,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Describes whether is valid visibility
            </summary>
            <param name="index">The index</param>
            <param name="vertices">The vertices</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.HasIntersectingLines(System.Int32,System.Int32,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Describes whether has intersecting lines
            </summary>
            <param name="i">The </param>
            <param name="j">The </param>
            <param name="vertices">The vertices</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.Reflex(System.Int32,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Describes whether reflex
            </summary>
            <param name="i">The </param>
            <param name="vertices">The vertices</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.Right(System.Int32,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Describes whether right
            </summary>
            <param name="i">The </param>
            <param name="vertices">The vertices</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.Left(Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2)">
            <summary>
                Describes whether left
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <param name="c">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.LeftOn(Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2)">
            <summary>
                Describes whether left on
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <param name="c">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.Right(Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2)">
            <summary>
                Describes whether right
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <param name="c">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.RightOn(Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2)">
            <summary>
                Describes whether right on
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <param name="c">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.BayaZit.BayaZitDecomposer.SquareDist(Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2)">
            <summary>
                Squares the dist using the specified a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <returns>The float</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.CdtDecomposer">
            <summary>
                2D constrained Delaunay triangulation algorithm.
                Based on the paper "Sweep-line algorithm for constrained Delaunay triangulation" by V. Domiter and and B. Zalik
                Properties:
                - Creates triangles with a large interior angle.
                - Supports holes
                - Generate a lot of garbage due to incapsulation of the Poly2Tri library.
                - Running time is O(n^2), n = number of vertices.
                - Does not care about winding order.
                Source: http://code.google.com/p/poly2tri/
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.CdtDecomposer.ConvexPartition(Alis.Core.Physic.Shared.Vertices)">
            <summary>Decompose the polygon into several smaller non-concave polygon.</summary>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle">
            <summary>
                The delaunay triangle class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.EdgeIsConstrained">
            <summary>Neighbor pointers. Flags to determine if an edge is a edge</summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.EdgeIsDelaunay">
            <summary>Flags to determine if an edge is a Constrained edge</summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Neighbors">
            <summary>
                The neighbors
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Points">
            <summary>Has this triangle been marked as an interior triangle?</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.#ctor(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle" /> class
            </summary>
            <param name="p1">The </param>
            <param name="p2">The </param>
            <param name="p3">The </param>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.IsInterior">
            <summary>
                Gets or sets the value of the is interior
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.IndexOf(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Indexes the of using the specified p
            </summary>
            <param name="p">The </param>
            <exception cref="T:System.Exception">Calling index with a point that doesn't exist in triangle</exception>
            <returns>The </returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.IndexCw(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Indexes the cw using the specified p
            </summary>
            <param name="p">The </param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.IndexCcw(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Indexes the ccw using the specified p
            </summary>
            <param name="p">The </param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Contains(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance contains
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Contains(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint)">
            <summary>
                Describes whether this instance contains
            </summary>
            <param name="e">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Contains(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance contains
            </summary>
            <param name="p">The </param>
            <param name="q">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkNeighbor(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>Update neighbor pointers</summary>
            <param name="p1">Point 1 of the shared edge</param>
            <param name="p2">Point 2 of the shared edge</param>
            <param name="t">This triangle's new neighbor</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkNeighbor(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>Exhaustive search to update neighbor pointers</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.ClearNeighbors">
            <summary>
                Clears the neighbors
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.ClearNeighbor(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Clears the neighbor using the specified triangle
            </summary>
            <param name="triangle">The triangle</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Clear">
            <summary>Clears all references to all other triangles and points</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.OppositePoint(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <param name="t">Opposite triangle</param>
            <param name="p">The point in t that isn't shared between the triangles</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.NeighborCw(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Neighbors the cw using the specified point
            </summary>
            <param name="point">The point</param>
            <returns>The delaunay triangle</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.NeighborCcw(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Neighbors the ccw using the specified point
            </summary>
            <param name="point">The point</param>
            <returns>The delaunay triangle</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.NeighborAcross(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Neighbors the across using the specified point
            </summary>
            <param name="point">The point</param>
            <returns>The delaunay triangle</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.PointCcw(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Points the ccw using the specified point
            </summary>
            <param name="point">The point</param>
            <returns>The triangulation point</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.PointCw(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Points the cw using the specified point
            </summary>
            <param name="point">The point</param>
            <returns>The triangulation point</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.RotateCw">
            <summary>
                Rotates the cw
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Legalize(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>Legalize triangle by rotating clockwise around oPoint</summary>
            <param name="oPoint">The origin point to rotate around</param>
            <param name="nPoint">???</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.ToString">
            <summary>
                Returns the string
            </summary>
            <returns>The string</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkNeighborEdges">
            <summary>Finalize edge marking</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkEdge(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Marks the edge using the specified triangle
            </summary>
            <param name="triangle">The triangle</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkEdge(System.Collections.Generic.List{Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle})">
            <summary>
                Marks the edge using the specified t list
            </summary>
            <param name="tList">The list</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkConstrainedEdge(System.Int32)">
            <summary>
                Marks the constrained edge using the specified index
            </summary>
            <param name="index">The index</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkConstrainedEdge(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint)">
            <summary>
                Marks the constrained edge using the specified edge
            </summary>
            <param name="edge">The edge</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.MarkConstrainedEdge(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>Mark edge as constrained</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Area">
            <summary>
                Areas this instance
            </summary>
            <returns>The double</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.Centroid">
            <summary>
                Centroids this instance
            </summary>
            <returns>The triangulation point</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.EdgeIndex(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>Get the index of the neighbor that shares this edge (or -1 if it isn't shared)</summary>
            <returns>index of the shared edge or -1 if edge isn't shared</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.GetConstrainedEdgeCcw(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance get constrained edge ccw
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.GetConstrainedEdgeCw(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance get constrained edge cw
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.GetConstrainedEdgeAcross(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance get constrained edge across
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.SetConstrainedEdgeCcw(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,System.Boolean)">
            <summary>
                Sets the constrained edge ccw using the specified p
            </summary>
            <param name="p">The </param>
            <param name="ce">The ce</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.SetConstrainedEdgeCw(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,System.Boolean)">
            <summary>
                Sets the constrained edge cw using the specified p
            </summary>
            <param name="p">The </param>
            <param name="ce">The ce</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.SetConstrainedEdgeAcross(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,System.Boolean)">
            <summary>
                Sets the constrained edge across using the specified p
            </summary>
            <param name="p">The </param>
            <param name="ce">The ce</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.GetDelaunayEdgeCcw(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance get delaunay edge ccw
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.GetDelaunayEdgeCw(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance get delaunay edge cw
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.GetDelaunayEdgeAcross(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether this instance get delaunay edge across
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.SetDelaunayEdgeCcw(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,System.Boolean)">
            <summary>
                Sets the delaunay edge ccw using the specified p
            </summary>
            <param name="p">The </param>
            <param name="ce">The ce</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.SetDelaunayEdgeCw(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,System.Boolean)">
            <summary>
                Sets the delaunay edge cw using the specified p
            </summary>
            <param name="p">The </param>
            <param name="ce">The ce</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle.SetDelaunayEdgeAcross(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,System.Boolean)">
            <summary>
                Sets the delaunay edge across using the specified p
            </summary>
            <param name="p">The </param>
            <param name="ce">The ce</param>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront">
            <summary>
                The advancing front class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.Search">
            <summary>
                The search
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.#ctor(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront" /> class
            </summary>
            <param name="head">The head</param>
            <param name="tail">The tail</param>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.Head">
            <summary>
                The head
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.Tail">
            <summary>
                The tail
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.AddNode(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Adds the node using the specified node
            </summary>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.RemoveNode(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Removes the node using the specified node
            </summary>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.ToString">
            <summary>
                Returns the string
            </summary>
            <returns>The string</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.FindSearchNode(System.Double)">
            <summary>
                MM:  This seems to be used by LocateNode to guess a position in the implicit linked list of
                AdvancingFrontNodes near x Removed an overload that depended on this being exact
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.LocateNode(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>We use a balancing tree to locate a node smaller or equal to given key value</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.LocateNode(System.Double)">
            <summary>
                Locates the node using the specified x
            </summary>
            <param name="x">The </param>
            <returns>The advancing front node</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.LocatePoint(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Locates the point using the specified point
            </summary>
            <param name="point">The point</param>
            <returns>The node</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.HandlePointEqualsNode(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Handles the point equals node using the specified point
            </summary>
            <param name="point">The point</param>
            <param name="node">The node</param>
            <exception cref="T:System.Exception">Failed to find Node for given afront point</exception>
            <returns>The node</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.SearchNodeInPreviousNodes(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Searches the node in previous nodes using the specified point
            </summary>
            <param name="point">The point</param>
            <param name="node">The node</param>
            <returns>The node</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront.SearchNodeInNextNodes(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Searches the node in next nodes using the specified point
            </summary>
            <param name="point">The point</param>
            <param name="node">The node</param>
            <returns>The node</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode">
            <summary>
                The advancing front node class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.Point">
            <summary>
                The point
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.Value">
            <summary>
                The value
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.#ctor(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode" /> class
            </summary>
            <param name="point">The point</param>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.Next">
            <summary>
                The next
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.Prev">
            <summary>
                The prev
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.Triangle">
            <summary>
                The triangle
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.HasNext">
            <summary>
                Gets the value of the has next
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode.HasPrev">
            <summary>
                Gets the value of the has prev
            </summary>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep">
            <summary>
                The dt sweep class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.PiDiv2">
            <summary>
                The pi
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.Pi3Div4">
            <summary>
                The pi
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.Triangulate(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext)">
            <summary>Triangulate simple polygon with holes</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.Sweep(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext)">
            <summary>Start sweeping the Y-sorted point set from bottom to top</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FinalizationConvexHull(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext)">
            <summary>If this is a Delaunay Triangulation of a point set we need to fill so the triangle mesh gets a ConvexHull</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.TurnAdvancingFrontConvex(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>We will traverse the entire advancing front and fill it to form a convex hull.</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FinalizationPolygon(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext)">
            <summary>
                Finalization the polygon using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.PointEvent(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Find closes node to the left of the new point and create a new triangle. If needed new holes and basins will
                be filled to.
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.NewFrontTriangle(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>Creates a new front triangle and legalize it</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.EdgeEvent(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Edges the event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillEdgeEvent(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillRightConcaveEdgeEvent(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the right concave edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillRightConvexEdgeEvent(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the right convex edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillRightBelowEdgeEvent(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the right below edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillRightAboveEdgeEvent(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the right above edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillLeftConvexEdgeEvent(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the left convex edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillLeftConcaveEdgeEvent(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the left concave edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillLeftBelowEdgeEvent(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the left below edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillLeftAboveEdgeEvent(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills the left above edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="edge">The edge</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.IsEdgeSideOfTriangle(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether is edge side of triangle
            </summary>
            <param name="triangle">The triangle</param>
            <param name="ep">The ep</param>
            <param name="eq">The eq</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.EdgeEvent(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Edges the event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="ep">The ep</param>
            <param name="eq">The eq</param>
            <param name="triangle">The triangle</param>
            <param name="point">The point</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.HandleCollinearOrientation(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Handles the collinear orientation using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="triangle">The triangle</param>
            <param name="ep">The ep</param>
            <param name="eq">The eq</param>
            <param name="p">The </param>
            <param name="point">The point</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.HandleSameOrientation(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Orientation)">
            <summary>
                Handles the same orientation using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="ep">The ep</param>
            <param name="eq">The eq</param>
            <param name="triangle">The triangle</param>
            <param name="point">The point</param>
            <param name="o">The </param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FlipEdgeEvent(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Flips the edge event using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="ep">The ep</param>
            <param name="eq">The eq</param>
            <param name="t">The </param>
            <param name="p">The </param>
            <exception cref="T:System.Exception">Intersecting Constraints</exception>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.RotateSharedEdge(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Rotates the shared edge using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
            <param name="t">The </param>
            <param name="p">The </param>
            <param name="ot">The ot</param>
            <param name="op">The op</param>
            <param name="ep">The ep</param>
            <param name="eq">The eq</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.NextFlipPoint(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                When we need to traverse from one triangle to the next we need the point in current triangle that is the
                opposite point to the next triangle.
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.NextFlipTriangle(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Orientation,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                After a flip we have two triangles and know that only one will still be intersecting the edge. So decide which
                to continue with and legalize the other
            </summary>
            <param name="tcx"></param>
            <param name="o">should be the result of an TriangulationUtil.orient2d( eq, op, ep )</param>
            <param name="t">triangle 1</param>
            <param name="ot">triangle 2</param>
            <param name="p">a point shared by both triangles</param>
            <param name="op">another point shared by both triangles</param>
            <returns>returns the triangle still intersecting the edge</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FlipScanEdgeEvent(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Scan part of the FlipScan algorithm When a triangle pair isn't flippable we will scan for the next point that
                is inside the flip triangle scan area. When found we generate a new flipEdgeEvent
            </summary>
            <param name="tcx"></param>
            <param name="ep">last point on the edge we are traversing</param>
            <param name="eq">first point on the edge we are traversing</param>
            <param name="flipTriangle">the current triangle sharing the point eq with edge</param>
            <param name="t"></param>
            <param name="p"></param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillAdvancingFront(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>Fills holes in the Advancing Front</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.LargeHole_DontFill(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Describes whether large hole dont fill
            </summary>
            <param name="node">The node</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.AngleExceeds90Degrees(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether angle exceeds 90 degrees
            </summary>
            <param name="origin">The origin</param>
            <param name="pa">The pa</param>
            <param name="pb">The pb</param>
            <returns>The exceeds 90 degrees</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.AngleExceedsPlus90DegreesOrIsNegative(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether angle exceeds plus 90 degrees or is negative
            </summary>
            <param name="origin">The origin</param>
            <param name="pa">The pa</param>
            <param name="pb">The pb</param>
            <returns>The exceeds plus 90 degrees or is negative</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.Angle(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Angles the origin
            </summary>
            <param name="origin">The origin</param>
            <param name="pa">The pa</param>
            <param name="pb">The pb</param>
            <returns>The angle</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillBasin(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Fills a basin that has formed on the Advancing Front to the right of given node. First we decide a left,bottom
                and right node that forms the boundaries of the basin. Then we do a fill.
            </summary>
            <param name="tcx"></param>
            <param name="node">starting node, this or next node will be left node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.FillBasinReq(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>Recursive algorithm to fill a Basin with triangles</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.IsShallow(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Describes whether is shallow
            </summary>
            <param name="tcx">The tcx</param>
            <param name="node">The node</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.HoleAngle(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>???</summary>
            <param name="node">middle node</param>
            <returns>the angle between 3 front nodes</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.BasinAngle(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>The basin angle is decided against the horizontal line [1,0]</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.Fill(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>Adds a triangle to the advancing front to fill a hole.</summary>
            <param name="tcx"></param>
            <param name="node">middle node, that is the bottom of the hole</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.Legalize(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Determines if a triangle is legalized and legalizes it if needed.
            </summary>
            <param name="tcx">The sweep context.</param>
            <param name="t">The triangle to check and legalize.</param>
            <returns>True if the triangle was legalized, false otherwise.</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.HandleEdgeIsConstrained(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,System.Int32,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,System.Int32)">
            <summary>
                Handles the edge is constrained using the specified t
            </summary>
            <param name="t">The </param>
            <param name="edgeIndex">The edge index</param>
            <param name="ot">The ot</param>
            <param name="oppositeIndex">The opposite index</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.TryLegalizeTriangle(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether try legalize triangle
            </summary>
            <param name="tcx">The tcx</param>
            <param name="t">The </param>
            <param name="ot">The ot</param>
            <param name="p">The </param>
            <param name="op">The op</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.ShouldNotLegalize(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,System.Int32)">
            <summary>
                Checks if an edge should not be legalized.
            </summary>
            <param name="ot">The neighboring triangle.</param>
            <param name="oi">The index of the opposite point.</param>
            <returns>True if the edge should not be legalized, false otherwise.</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.IsInsideCirCircle(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Checks if a point is inside the cir circle of a triangle.
            </summary>
            <param name="p">The point to check.</param>
            <param name="a">The first triangle vertex.</param>
            <param name="b">The second triangle vertex.</param>
            <param name="c">The third triangle vertex.</param>
            <returns>True if the point is inside the cir circle, false otherwise.</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweep.RotateTrianglePair(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Rotates a triangle pair one vertex CW
                n2                    n2
                Position +-----+             Position +-----+
                | t  /|               |\  t |
                |   / |               | \   |
                n1|  /  |n3           n1|  \  |n3
                | /   |    after CW   |   \ |
                |/ oT |               | oT \|
                +-----+ oP            +-----+
                n4                    n4
            </summary>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint">
            <summary>
                The dt sweep constraint class
            </summary>
            <seealso cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationConstraint" />
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint.#ctor(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>Give two points in any order. Will always be ordered so that q.y > p.y and q.x > p.x if same y value</summary>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext">
            <summary>
                The dt sweep context class
            </summary>
            <seealso cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext" />
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.Alpha">
            <summary>
                The alpha
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.Basin">
            <summary>
                The dt sweep basin
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.comparator">
            <summary>
                The dt sweep point comparator
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.EdgeEvent">
            <summary>
                The dt sweep edge event
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext" /> class
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.AFront">
            <summary>
                The front
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.Head">
            <summary>
                Gets or sets the value of the head
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.Tail">
            <summary>
                Gets or sets the value of the tail
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.RemoveFromList(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Removes the from list using the specified triangle
            </summary>
            <param name="triangle">The triangle</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.MeshClean(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Meshes the clean using the specified triangle
            </summary>
            <param name="triangle">The triangle</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.MeshCleanReq(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Meshes the clean req using the specified triangle
            </summary>
            <param name="triangle">The triangle</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.Clear">
            <summary>
                Clears this instance
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.AddNode(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Adds the node using the specified node
            </summary>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.RemoveNode(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
                Removes the node using the specified node
            </summary>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.LocateNode(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Locates the node using the specified point
            </summary>
            <param name="point">The point</param>
            <returns>The advancing front node</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.CreateAdvancingFront">
            <summary>
                Creates the advancing front
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.MapTriangleToNodes(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>Try to map a node to all sides of this triangle that don't have a neighbor.</summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.PrepareTriangulation(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.ITriangulatable)">
            <summary>
                Prepares the triangulation using the specified t
            </summary>
            <param name="t">The </param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.FinalizeTriangulation">
            <summary>
                Finalizes the triangulation
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.NewConstraint(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                News the constraint using the specified a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <returns>The triangulation constraint</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepBasin">
            <summary>
                The dt sweep basin class
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepBasin.BottomNode">
            <summary>
                The bottom node
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepBasin.LeftHighest">
            <summary>
                The left highest
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepBasin.LeftNode">
            <summary>
                The left node
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepBasin.RightNode">
            <summary>
                The right node
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepBasin.Width">
            <summary>
                The width
            </summary>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepEdgeEvent">
            <summary>
                The dt sweep edge event class
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepEdgeEvent.ConstrainedEdge">
            <summary>
                The constrained edge
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepContext.DtSweepEdgeEvent.Right">
            <summary>
                The right
            </summary>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepPointComparator">
            <summary>
                The dt sweep point comparator class
            </summary>
            <seealso cref="T:System.Collections.Generic.IComparer`1" />
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepPointComparator.Compare(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Compares the p 1
            </summary>
            <param name="p1">The </param>
            <param name="p2">The </param>
            <returns>The int</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.ITriangulatable">
            <summary>
                The triangulatable interface
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.ITriangulatable.Points">
            <summary>
                Gets the value of the points
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.ITriangulatable.Triangles">
            <summary>
                Gets the value of the triangles
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.ITriangulatable.TriangulationMode">
            <summary>
                Gets the value of the triangulation mode
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.ITriangulatable.PrepareTriangulation(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext)">
            <summary>
                Prepares the triangulation using the specified tcx
            </summary>
            <param name="tcx">The tcx</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.ITriangulatable.AddTriangle(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Adds the triangle using the specified t
            </summary>
            <param name="t">The </param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.ITriangulatable.AddTriangles(System.Collections.Generic.IEnumerable{Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle})">
            <summary>
                Adds the triangles using the specified list
            </summary>
            <param name="list">The list</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.ITriangulatable.ClearTriangles">
            <summary>
                Clears the triangles
            </summary>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Orientation">
            <summary>
                The orientation enum
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Orientation.Cw">
            <summary>
                The cw orientation
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Orientation.Ccw">
            <summary>
                The ccw orientation
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Orientation.Collinear">
            <summary>
                The collinear orientation
            </summary>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon">
            <summary>
                The polygon class
            </summary>
            <seealso cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.ITriangulatable" />
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.pointsPrivate">
            <summary>
                The triangulation point
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.holesPrivate">
            <summary>
                The holes
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.lastPrivate">
            <summary>
                The last
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.steinerPointsPrivate">
            <summary>
                The steiner points
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.trianglesPrivate">
            <summary>
                The triangles
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.#ctor(System.Collections.Generic.IList{Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.PolygonPoint})">
            <summary>Create a polygon from a list of at least 3 points with no duplicates.</summary>
            <param name="points">A list of unique points</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.#ctor(System.Collections.Generic.IEnumerable{Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.PolygonPoint})">
            <summary>Create a polygon from a list of at least 3 points with no duplicates.</summary>
            <param name="points">A list of unique points.</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon" /> class
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.Holes">
            <summary>
                Gets the value of the holes
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.TriangulationMode">
            <summary>
                Gets the value of the triangulation mode
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.Points">
            <summary>
                Gets the value of the points
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.Triangles">
            <summary>
                Gets the value of the triangles
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.AddTriangle(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle)">
            <summary>
                Adds the triangle using the specified t
            </summary>
            <param name="t">The </param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.AddTriangles(System.Collections.Generic.IEnumerable{Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.DelaunayTriangle})">
            <summary>
                Adds the triangles using the specified list
            </summary>
            <param name="list">The list</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.ClearTriangles">
            <summary>
                Clears the triangles
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.PrepareTriangulation(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext)">
            <summary>Creates constraints and populates the context with points</summary>
            <param name="tcx">The context</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.AddSteinerPoint(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Adds the steiner point using the specified point
            </summary>
            <param name="point">The point</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.AddSteinerPoints(System.Collections.Generic.List{Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint})">
            <summary>
                Adds the steiner points using the specified points
            </summary>
            <param name="points">The points</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.ClearSteinerPoints">
            <summary>
                Clears the steiner points
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.AddHole(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon)">
            <summary>Add a hole to the polygon.</summary>
            <param name="poly">A subtraction polygon fully contained inside this polygon.</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.InsertPointAfter(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.PolygonPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.PolygonPoint)">
            <summary>Inserts newPoint after point.</summary>
            <param name="point">The point to insert after in the polygon</param>
            <param name="newPoint">The point to insert into the polygon</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.AddPoints(System.Collections.Generic.IEnumerable{Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.PolygonPoint})">
            <summary>Inserts list (after last point in polygon?)</summary>
            <param name="list"></param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.AddPoint(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.PolygonPoint)">
            <summary>Adds a point after the last in the polygon.</summary>
            <param name="p">The point to add</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.Polygon.RemovePoint(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.PolygonPoint)">
            <summary>Removes a point from the polygon.</summary>
            <param name="p"></param>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.PolygonPoint">
            <summary>
                The polygon point class
            </summary>
            <seealso cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint" />
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.PolygonPoint.#ctor(System.Double,System.Double)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.PolygonPoint" /> class
            </summary>
            <param name="x">The </param>
            <param name="y">The </param>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.PolygonPoint.Next">
            <summary>
                Gets or sets the value of the next
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Polygon.PolygonPoint.Previous">
            <summary>
                Gets or sets the value of the previous
            </summary>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationConstraint">
            <summary>
                The triangulation constraint class
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationConstraint.P">
            <summary>
                The
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationConstraint.Q">
            <summary>
                The
            </summary>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext">
            <summary>
                The triangulation context class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext.Points">
            <summary>
                The triangulation point
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext.Triangles">
            <summary>
                The delaunay triangle
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext" /> class
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext.TriangulationMode">
            <summary>
                Gets or sets the value of the triangulation mode
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext.Triangulatable">
            <summary>
                Gets or sets the value of the triangulatable
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext.Terminated">
            <summary>
                Gets or sets the value of the terminated
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext.StepCount">
            <summary>
                Gets or sets the value of the step count
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext.IsDebugEnabled">
            <summary>
                Gets or sets the value of the is debug enabled
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext.Done">
            <summary>
                Dones this instance
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext.PrepareTriangulation(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.ITriangulatable)">
            <summary>
                Prepares the triangulation using the specified t
            </summary>
            <param name="t">The </param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext.NewConstraint(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                News the constraint using the specified a
            </summary>
            <param name="a">The </param>
            <param name="b">The </param>
            <returns>The triangulation constraint</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext.Update(System.String)">
            <summary>
                Updates the message
            </summary>
            <param name="message">The message</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationContext.Clear">
            <summary>
                Clears this instance
            </summary>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationMode">
            <summary>
                The triangulation mode enum
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationMode.Unconstrained">
            <summary>
                The unconstrained triangulation mode
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationMode.Constrained">
            <summary>
                The constrained triangulation mode
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationMode.Polygon">
            <summary>
                The polygon triangulation mode
            </summary>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint">
            <summary>
                The triangulation point class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint.X">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint.Y">
            <summary>
                The
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint.#ctor(System.Double,System.Double)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint" /> class
            </summary>
            <param name="x">The </param>
            <param name="y">The </param>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint.Edges">
            <summary>
                Gets or sets the value of the edges
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint.Xf">
            <summary>
                Gets or sets the value of the xf
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint.Yf">
            <summary>
                Gets or sets the value of the yf
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint.HasEdges">
            <summary>
                Gets the value of the has edges
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint.ToString">
            <summary>
                Returns the string
            </summary>
            <returns>The string</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint.AddEdge(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Delaunay.Sweep.DtSweepConstraint)">
            <summary>
                Adds the edge using the specified e
            </summary>
            <param name="e">The </param>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationUtil">
            <summary>
                The triangulation util class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationUtil.Epsilon">
            <summary>
                The epsilon
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationUtil.SmartInCircle(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether smart in circle
            </summary>
            <param name="pa">The pa</param>
            <param name="pb">The pb</param>
            <param name="pc">The pc</param>
            <param name="pd">The pd</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationUtil.InScanArea(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Describes whether in scan area
            </summary>
            <param name="pa">The pa</param>
            <param name="pb">The pb</param>
            <param name="pc">The pc</param>
            <param name="pd">The pd</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationUtil.Orient2d(Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint,Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.TriangulationPoint)">
            <summary>
                Orients the 2d using the specified pa
            </summary>
            <param name="pa">The pa</param>
            <param name="pb">The pb</param>
            <param name="pc">The pc</param>
            <returns>The orientation</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Util.PolygonGenerator">
            <summary>
                The polygon generator class
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Util.PolygonGenerator.RandomCircleSweep(System.Double,System.Int32)">
            <summary>
                Randoms the circle sweep using the specified scale
            </summary>
            <param name="scale">The scale</param>
            <param name="vertexCount">The vertex count</param>
            <returns>The polygon polygon</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Delaunay.Util.PolygonGenerator.RandomCircleSweep2(System.Double,System.Int32)">
            <summary>
                Randoms the circle sweep 2 using the specified scale
            </summary>
            <param name="scale">The scale</param>
            <param name="vertexCount">The vertex count</param>
            <returns>The polygon polygon</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.EarClipDecomposer">
            <summary>
                Convex decomposition algorithm using ear clipping
                Properties:
                - Only works on simple polygons.
                - Does not support holes.
                - Running time is O(n^2), n = number of vertices.
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.EarClipDecomposer.ConvexPartition(Alis.Core.Physic.Shared.Vertices,System.Single)">
            <summary>
                Decompose the polygon into several smaller non-concave polygon. Each resulting polygon will have no more than
                Settings.MaxPolygonVertices vertices.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="tolerance">The tolerance.</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.EarClipDecomposer.TriangulatePolygon(Alis.Core.Physic.Shared.Vertices,System.Single)">
            <summary>
                Triangulates a polygon using the ear-clipping algorithm.
                Returns a list of triangles.
            </summary>
            <remarks>Only works on simple polygons.</remarks>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.EarClipDecomposer.TriangulatePinchedPolygon(Alis.Core.Physic.Shared.Vertices,System.Single)">
            <summary>
                Triangulates the pinched polygon using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <param name="tolerance">The tolerance</param>
            <exception cref="T:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.TriangulateException">Can't triangulate your polygon.</exception>
            <returns>A list of vertices</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.EarClipDecomposer.TriangulateRegularPolygon(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Triangulates the regular polygon using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <returns>The results</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.EarClipDecomposer.FindEar(System.Single[],System.Single[],System.Int32)">
            <summary>
                Finds the ear using the specified x rem
            </summary>
            <param name="xRem">The rem</param>
            <param name="yRem">The rem</param>
            <param name="vNum">The num</param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.EarClipDecomposer.ClipEar(System.Int32,System.Single[]@,System.Single[]@,System.Int32,System.Collections.Generic.List{Alis.Core.Physic.Shared.Vertices})">
            <summary>
                Clips the ear using the specified ear index
            </summary>
            <param name="earIndex">The ear index</param>
            <param name="xRem">The rem</param>
            <param name="yRem">The rem</param>
            <param name="vNum">The num</param>
            <param name="results">The results</param>
            <returns>The int</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.EarClipDecomposer.GenerateTrianglesFromBuffer(System.Single[],System.Single[],System.Int32)">
            <summary>
                Generates the triangles from buffer using the specified x rem
            </summary>
            <param name="xRem">The rem</param>
            <param name="yRem">The rem</param>
            <param name="vNum">The num</param>
            <returns>The triangles</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.EarClipDecomposer.ResolvePinchPoint(Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Shared.Vertices@,Alis.Core.Physic.Shared.Vertices@,System.Single)">
            <summary>
                Finds and fixes "pinch points," points where two polygon vertices are at the same point.
            </summary>
            <param name="pin">The pin.</param>
            <param name="poutA">The pout A.</param>
            <param name="poutB">The pout B.</param>
            <param name="tolerance">The tolerance for point comparison.</param>
            <returns>True if a pinch point is found and resolved, false otherwise.</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.EarClipDecomposer.FindPinchPoint(Alis.Core.Physic.Shared.Vertices,System.Single,System.Int32@,System.Int32@)">
            <summary>
                Finds a pinch point in the vertices.
            </summary>
            <param name="vertices">The vertices to search.</param>
            <param name="tolerance">The tolerance for point comparison.</param>
            <param name="pinchIndexA">The index of the first vertex in the pinch point.</param>
            <param name="pinchIndexB">The index of the second vertex in the pinch point.</param>
            <returns>True if a pinch point is found, false otherwise.</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.EarClipDecomposer.IsPinchPoint(Alis.Core.Aspect.Math.Vector.Vector2,Alis.Core.Aspect.Math.Vector.Vector2,System.Single)">
            <summary>
                Determines if two vertices form a pinch point within the given tolerance.
            </summary>
            <param name="vertexA">The first vertex.</param>
            <param name="vertexB">The second vertex.</param>
            <param name="tolerance">The tolerance for point comparison.</param>
            <returns>True if the vertices form a pinch point, false otherwise.</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.EarClipDecomposer.SplitVertices(Alis.Core.Physic.Shared.Vertices,System.Int32,System.Int32,Alis.Core.Physic.Shared.Vertices,Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Splits the vertices at the pinch point.
            </summary>
            <param name="pin">The vertices to split.</param>
            <param name="pinchIndexA">The index of the first vertex in the pinch point.</param>
            <param name="pinchIndexB">The index of the second vertex in the pinch point.</param>
            <param name="poutA">The output vertices A.</param>
            <param name="poutB">The output vertices B.</param>
            <returns>True if the vertices are split successfully, false otherwise.</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.EarClipDecomposer.RemainderLocal(System.Int32,System.Int32)">
            <summary>
                Calculates the remainder of division, handling negative values correctly.
            </summary>
            <param name="dividend">The dividend.</param>
            <param name="divisor">The divisor.</param>
            <returns>The remainder of the division.</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.EarClipDecomposer.IsEar(System.Int32,System.Single[],System.Single[],System.Int32)">
            <summary>Checks if vertex i is the tip of an ear in polygon defined by xv[] and  yv[].</summary>
            <param name="i">The i.</param>
            <param name="xv">The xv.</param>
            <param name="yv">The yv.</param>
            <param name="xvLength">Length of the xv.</param>
            <remarks>Assumes clockwise orientation of polygon.</remarks>
            <returns><c>true</c> if the specified i is ear; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.Triangle">
            <summary>
                The triangle class
            </summary>
            <seealso cref="T:Alis.Core.Physic.Shared.Vertices" />
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.Triangle.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.Triangle" /> class
            </summary>
            <param name="x1">The </param>
            <param name="y1">The </param>
            <param name="x2">The </param>
            <param name="y2">The </param>
            <param name="x3">The </param>
            <param name="y3">The </param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.Triangle.IsInside(System.Single,System.Single)">
            <summary>
                Describes whether this instance is inside
            </summary>
            <param name="x">The </param>
            <param name="y">The </param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.TriangulateException">
            <summary>
                The triangulate exception class
            </summary>
            <seealso cref="T:System.Exception" />
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.TriangulateException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.EarClip.TriangulateException" /> class
            </summary>
            <param name="message">The message</param>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.FlipCode.FlipCodeDecomposer">
            <summary>
                Convex decomposition algorithm created by unknown
                Properties:
                - No support for holes
                - Very fast
                - Only works on simple polygons
                - Only works on counter clockwise polygons
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.FlipCode.FlipCodeDecomposer._tmpA">
            <summary>
                The tmp
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.FlipCode.FlipCodeDecomposer._tmpB">
            <summary>
                The tmp
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.FlipCode.FlipCodeDecomposer._tmpC">
            <summary>
                The tmp
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.FlipCode.FlipCodeDecomposer.ConvexPartition(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Decompose the polygon into triangles.
                Properties:
                - Only works on counter clockwise polygons
            </summary>
            <param name="vertices">The list of points describing the polygon</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.FlipCode.FlipCodeDecomposer.InsideTriangle(Alis.Core.Aspect.Math.Vector.Vector2@,Alis.Core.Aspect.Math.Vector.Vector2@,Alis.Core.Aspect.Math.Vector.Vector2@,Alis.Core.Aspect.Math.Vector.Vector2@)">
            <summary>Check if the point Position is inside the triangle defined by the points A, B, C</summary>
            <param name="a">The A point.</param>
            <param name="b">The B point.</param>
            <param name="c">The C point.</param>
            <param name="p">The point to be tested.</param>
            <returns>True if the point is inside the triangle</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.FlipCode.FlipCodeDecomposer.Snip(Alis.Core.Physic.Shared.Vertices,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[])">
            <summary>Cut a the contour and add a triangle into V to describe the location of the cut</summary>
            <param name="contour">The list of points defining the polygon</param>
            <param name="u">The index of the first point</param>
            <param name="v">The index of the second point</param>
            <param name="w">The index of the third point</param>
            <param name="n">The number of elements in the array.</param>
            <param name="vv">The array to populate with indices of triangles.</param>
            <returns>True if a triangle was found</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge">
            <summary>
                The edge class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge.B">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge.MPoints">
            <summary>
                The points
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge.P">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge.Q">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge.Slope">
            <summary>
                The slope
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge.#ctor(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge" /> class
            </summary>
            <param name="p">The </param>
            <param name="q">The </param>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge.Above">
            <summary>
                The above
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge.Below">
            <summary>
                The below
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge.IsAbove(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Describes whether this instance is above
            </summary>
            <param name="point">The point</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge.IsBelow(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Describes whether this instance is below
            </summary>
            <param name="point">The point</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge.AddMPoint(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Adds the point using the specified point
            </summary>
            <param name="point">The point</param>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain">
            <summary>
                The monotone mountain class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.PiSlop">
            <summary>
                The pi slop
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.convexPoints">
            <summary>
                The convex points
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.Triangles">
            <summary>
                The triangles
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.head">
            <summary>
                The head
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.positive">
            <summary>
                The positive
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.size">
            <summary>
                The size
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.tail">
            <summary>
                The tail
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain" /> class
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.MonoPoly">
            <summary>
                The mono poly
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.Add(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Adds the point
            </summary>
            <param name="point">The point</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.Remove(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Removes the point
            </summary>
            <param name="point">The point</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.Process">
            <summary>
                Processes this instance
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.Triangulate">
            <summary>
                Triangulates this instance
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.Valid(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Describes whether this instance valid
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.GenMonoPoly">
            <summary>
                Gens the mono poly
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.Angle(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Angles the p
            </summary>
            <param name="p">The </param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.AngleSign">
            <summary>
                Describes whether this instance angle sign
            </summary>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.MonotoneMountain.IsConvex(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Describes whether this instance is convex
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node">
            <summary>
                The node class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node.ParentList">
            <summary>
                The parent list
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node.LeftChild">
            <summary>
                The left child
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node.RightChild">
            <summary>
                The right child
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node.#ctor(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node" /> class
            </summary>
            <param name="left">The left</param>
            <param name="right">The right</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node.Locate(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge)">
            <summary>
                Locates the s
            </summary>
            <param name="edge">The </param>
            <returns>The sink</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node.Replace(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node)">
            <summary>
                Replaces the node
            </summary>
            <param name="node">The node</param>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point">
            <summary>
                The point class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point.X">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point.Y">
            <summary>
                The
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point.Next">
            <summary>
                The prev
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point.Prev">
            <summary>
                The prev
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point.#ctor(System.Single,System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point" /> class
            </summary>
            <param name="x">The </param>
            <param name="y">The </param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point.op_Subtraction(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                operator negation
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point.op_Addition(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                operator positive
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point.op_Subtraction(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point,System.Single)">
            <summary>
                operator negation
            </summary>
            <param name="p1"></param>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point.op_Addition(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point,System.Single)">
            <summary>
                operator positive
            </summary>
            <param name="p1"></param>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point.Cross(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Crosses the p
            </summary>
            <param name="p">The </param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point.Dot(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Dots the p
            </summary>
            <param name="p">The </param>
            <returns>The float</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point.Neq(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Describes whether this instance neq
            </summary>
            <param name="p">The </param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point.Orient2D(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Orients the 2 d using the specified pb
            </summary>
            <param name="pb">The pb</param>
            <param name="pc">The pc</param>
            <returns>The float</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.QueryGraph">
            <summary>
                The query graph class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.QueryGraph.head">
            <summary>
                The head
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.QueryGraph.#ctor(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.QueryGraph" /> class
            </summary>
            <param name="head">The head</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.QueryGraph.Locate(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge)">
            <summary>
                Locates the edge
            </summary>
            <param name="edge">The edge</param>
            <returns>The trapezoid</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.QueryGraph.FollowEdge(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge)">
            <summary>
                Follows the edge using the specified edge
            </summary>
            <param name="edge">The edge</param>
            <returns>The trapezoids</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.QueryGraph.Replace(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Sink,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node)">
            <summary>
                Replaces the sink
            </summary>
            <param name="sink">The sink</param>
            <param name="node">The node</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.QueryGraph.Case1(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Sink,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid[])">
            <summary>
                Cases the 1 using the specified sink
            </summary>
            <param name="sink">The sink</param>
            <param name="edge">The edge</param>
            <param name="tList">The list</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.QueryGraph.Case2(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Sink,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid[])">
            <summary>
                Cases the 2 using the specified sink
            </summary>
            <param name="sink">The sink</param>
            <param name="edge">The edge</param>
            <param name="tList">The list</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.QueryGraph.Case3(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Sink,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid[])">
            <summary>
                Cases the 3 using the specified sink
            </summary>
            <param name="sink">The sink</param>
            <param name="edge">The edge</param>
            <param name="tList">The list</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.QueryGraph.Case4(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Sink,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid[])">
            <summary>
                Cases the 4 using the specified sink
            </summary>
            <param name="sink">The sink</param>
            <param name="edge">The edge</param>
            <param name="tList">The list</param>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.SeidelDecomposer">
            <summary>
                Convex decomposition algorithm created by Raimund Seidel
                Properties:
                - Decompose the polygon into trapezoids, then triangulate.
                - To use the trapezoid data, use ConvexPartitionTrapezoid()
                - Generate a lot of garbage due of the Poly2Tri library.
                - Running time is O(n log n), n = number of vertices.
                - Running time is almost linear for most simple polygons.
                - Does not care about winding order.
                For more information, see Raimund Seidel's paper "A simple and fast incremental randomized
                algorithm for computing trapezoidal decompositions and for triangulating polygons"
                See also: "Computational Geometry", 3rd edition, by Mark de Berg et al, Chapter 6.2
                "Computational Geometry in C", 2nd edition, by Joseph O'Rourke
                Original code from the Poly2Tri project by Mason Green.
                This implementation is from Dec 14, 2010
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.SeidelDecomposer.ConvexPartition(Alis.Core.Physic.Shared.Vertices,System.Single)">
            <summary>Decompose the polygon into several smaller non-concave polygons.</summary>
            <param name="vertices">The polygon to decompose.</param>
            <param name="sheer">The sheer to use if you get bad results, try using a higher value.</param>
            <returns>A list of triangles</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.SeidelDecomposer.ConvexPartitionTrapezoid(Alis.Core.Physic.Shared.Vertices,System.Single)">
            <summary>Decompose the polygon into several smaller non-concave polygons.</summary>
            <param name="vertices">The polygon to decompose.</param>
            <param name="sheer">The sheer to use if you get bad results, try using a higher value.</param>
            <returns>A list of trapezoids</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Sink">
            <summary>
                The sink class
            </summary>
            <seealso cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node" />
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Sink.Trapezoid">
            <summary>
                The trapezoid
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Sink.#ctor(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Sink" /> class
            </summary>
            <param name="trapezoid">The trapezoid</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Sink.IsInk(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid)">
            <summary>
                Is inks the trapezoid
            </summary>
            <param name="trapezoid">The trapezoid</param>
            <returns>The sink</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Sink.Locate(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge)">
            <summary>
                Locates the edge
            </summary>
            <param name="edge">The edge</param>
            <returns>The sink</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid">
            <summary>
                The trapezoid class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.Bottom">
            <summary>
                The bottom
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.LeftPoint">
            <summary>
                The left point
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.Top">
            <summary>
                The top
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.#ctor(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid" /> class
            </summary>
            <param name="leftPoint">The left point</param>
            <param name="rightPoint">The right point</param>
            <param name="top">The top</param>
            <param name="bottom">The bottom</param>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.Inside">
            <summary>
                The inside
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.LowerLeft">
            <summary>
                The lower left
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.LowerRight">
            <summary>
                The lower right
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.RightPoint">
            <summary>
                The right point
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.Sink">
            <summary>
                The sink
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.UpperLeft">
            <summary>
                The upper left
            </summary>
        </member>
        <member name="P:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.UpperRight">
            <summary>
                The upper right
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.UpdateLeft(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid)">
            <summary>
                Updates the left using the specified ul
            </summary>
            <param name="ul">The ul</param>
            <param name="ll">The ll</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.UpdateRight(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid)">
            <summary>
                Updates the right using the specified ur
            </summary>
            <param name="ur">The ur</param>
            <param name="lr">The lr</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.UpdateLeftRight(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid)">
            <summary>
                Updates the left right using the specified ul
            </summary>
            <param name="ul">The ul</param>
            <param name="ll">The ll</param>
            <param name="ur">The ur</param>
            <param name="lr">The lr</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.TrimNeighbors">
            <summary>
                Trims the neighbors
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.Contains(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Describes whether this instance contains
            </summary>
            <param name="point">The point</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.GetVertices">
            <summary>
                Gets the vertices
            </summary>
            <returns>The vert</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.LineIntersect(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge,System.Single)">
            <summary>
                Lines the intersect using the specified edge
            </summary>
            <param name="edge">The edge</param>
            <param name="x">The </param>
            <returns>The point</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid.AddPoints">
            <summary>
                Adds the points
            </summary>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap">
            <summary>
                The trapezoidal map class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap.Map">
            <summary>
                The map
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap.margin">
            <summary>
                The margin
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap.bCross">
            <summary>
                The cross
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap.cross">
            <summary>
                The cross
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap" /> class
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap.Clear">
            <summary>
                Clears this instance
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap.Case1(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge)">
            <summary>
                Cases the 1 using the specified t
            </summary>
            <param name="t">The </param>
            <param name="e">The </param>
            <returns>The trapezoids</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap.Case2(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge)">
            <summary>
                Cases the 2 using the specified t
            </summary>
            <param name="t">The </param>
            <param name="e">The </param>
            <returns>The trapezoids</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap.Case3(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge)">
            <summary>
                Cases the 3 using the specified t
            </summary>
            <param name="t">The </param>
            <param name="e">The </param>
            <returns>The trapezoids</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap.Case4(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge)">
            <summary>
                Cases the 4 using the specified t
            </summary>
            <param name="t">The </param>
            <param name="e">The </param>
            <returns>The trapezoids</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap.BoundingBox(System.Collections.Generic.List{Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge})">
            <summary>
                Bound the box using the specified edges
            </summary>
            <param name="edges">The edges</param>
            <returns>The trapezoid</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap.CalculateMaxPoint(System.Collections.Generic.List{Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge})">
            <summary>
                Calculates the max point using the specified edges
            </summary>
            <param name="edges">The edges</param>
            <returns>The max</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap.CalculateMinPoint(System.Collections.Generic.List{Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge})">
            <summary>
                Calculates the min point using the specified edges
            </summary>
            <param name="edges">The edges</param>
            <returns>The min</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap.UpdateMaxPoint(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Updates the max point using the specified current max
            </summary>
            <param name="currentMax">The current max</param>
            <param name="point">The point</param>
            <returns>The point</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.TrapezoidalMap.UpdateMinPoint(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Updates the min point using the specified current min
            </summary>
            <param name="currentMin">The current min</param>
            <param name="point">The point</param>
            <returns>The point</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate">
            <summary>
                The triangulate class
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.boundingBox">
            <summary>
                The bounding box
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.edgeList">
            <summary>
                The edge list
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.queryGraph">
            <summary>
                The query graph
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.sheer">
            <summary>
                The sheer
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.trapezoidalMap">
            <summary>
                The trapezoidal map
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.Trapezoids">
            <summary>
                The trapezoids
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.Triangles">
            <summary>
                The triangles
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.#ctor(System.Collections.Generic.List{Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point},System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate" /> class
            </summary>
            <param name="polyLine">The poly line</param>
            <param name="sheer">The sheer</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.Process">
            <summary>
                Processes this instance
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.ProcessEdges">
            <summary>
                Processes the edges
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.RemoveTrapezoidFromMap(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid)">
            <summary>
                Removes the trapezoid from map using the specified trapezoid
            </summary>
            <param name="trapezoid">The trapezoid</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.AddNewTrapezoidsToMap(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid[])">
            <summary>
                Adds the new trapezoids to map using the specified new trapezoids
            </summary>
            <param name="newTrapezoids">The new trapezoids</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.MarkOutsideTrapezoids">
            <summary>
                Marks the outside trapezoids
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.CollectInteriorTrapezoids">
            <summary>
                Collects the interior trapezoids
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.CreateMountains">
            <summary>
                Creates the mountains
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.MarkOutside(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Trapezoid)">
            <summary>
                Marks the outside using the specified t
            </summary>
            <param name="t">The </param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.InitEdges(System.Collections.Generic.List{Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point})">
            <summary>
                Inits the edges using the specified points
            </summary>
            <param name="points">The points</param>
            <returns>A list of edge</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.OrderSegments(System.Collections.Generic.List{Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge})">
            <summary>
                Orders the segments using the specified edge input
            </summary>
            <param name="edgeInput">The edge input</param>
            <returns>The edges</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.Shuffle``1(System.Collections.Generic.IList{``0})">
            <summary>
                Shuffles the list
            </summary>
            <typeparam name="T">The </typeparam>
            <param name="list">The list</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Triangulate.ShearTransform(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point)">
            <summary>
                Shears the transform using the specified point
            </summary>
            <param name="point">The point</param>
            <returns>The point</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.XNode">
            <summary>
                The node class
            </summary>
            <seealso cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node" />
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.XNode.point">
            <summary>
                The point
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.XNode.#ctor(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Point,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.XNode" /> class
            </summary>
            <param name="point">The point</param>
            <param name="lChild">The child</param>
            <param name="rChild">The child</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.XNode.Locate(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge)">
            <summary>
                Locates the edge
            </summary>
            <param name="edge">The edge</param>
            <returns>The sink</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.YNode">
            <summary>
                The node class
            </summary>
            <seealso cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node" />
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.YNode.edge">
            <summary>
                The edge
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.YNode.#ctor(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node,Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Node)">
            <summary>
                Initializes a new instance of the <see cref="T:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.YNode" /> class
            </summary>
            <param name="edge">The edge</param>
            <param name="lChild">The child</param>
            <param name="rChild">The child</param>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Seidel.YNode.Locate(Alis.Extension.Math.PathGenerator.Triangulation.Seidel.Edge)">
            <summary>
                Locates the edge
            </summary>
            <param name="edge">The edge</param>
            <returns>The sink</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.Triangulate">
            <summary>
                The triangulate class
            </summary>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Triangulate.ConvexPartition(Alis.Core.Physic.Shared.Vertices,Alis.Extension.Math.PathGenerator.Triangulation.TriangulationAlgorithm,System.Boolean,System.Single)">
            <summary>
                Convexes the partition using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <param name="algorithm">The algorithm</param>
            <param name="discardAndFixInvalid">The discard and fix invalid</param>
            <param name="tolerance">The tolerance</param>
            <returns>The results</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Triangulate.ValidateCounterClockwise(Alis.Core.Physic.Shared.Vertices,Alis.Extension.Math.PathGenerator.Triangulation.TriangulationAlgorithm)">
            <summary>
                Describes whether validate counter clockwise
            </summary>
            <param name="vertices">The vertices</param>
            <param name="algorithm">The algorithm</param>
            <returns>The bool</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Triangulate.GetConvexPartition(Alis.Core.Physic.Shared.Vertices,Alis.Extension.Math.PathGenerator.Triangulation.TriangulationAlgorithm,System.Single)">
            <summary>
                Gets the convex partition using the specified vertices
            </summary>
            <param name="vertices">The vertices</param>
            <param name="algorithm">The algorithm</param>
            <param name="tolerance">The tolerance</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <returns>A list of vertices</returns>
        </member>
        <member name="M:Alis.Extension.Math.PathGenerator.Triangulation.Triangulate.ValidatePolygon(Alis.Core.Physic.Shared.Vertices)">
            <summary>
                Describes whether validate polygon
            </summary>
            <param name="polygon">The polygon</param>
            <returns>The bool</returns>
        </member>
        <member name="T:Alis.Extension.Math.PathGenerator.Triangulation.TriangulationAlgorithm">
            <summary>
                The triangulation algorithm enum
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.TriangulationAlgorithm.EarClip">
            <summary>
                Convex decomposition algorithm using ear clipping
                Properties:
                - Only works on simple polygons.
                - Does not support holes.
                - Running time is O(n^2), n = number of vertices.
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.TriangulationAlgorithm.BayaZit">
            <summary>
                Properties:
                - Tries to decompose using polygons instead of triangles.
                - Tends to produce optimal results with low processing time.
                - Running time is O(nr), n = number of vertices, r = reflex vertices.
                - Does not support holes.
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.TriangulationAlgorithm.FlipCode">
            <summary>
                Convex decomposition algorithm created by unknown
                Properties:
                - No support for holes
                - Very fast
                - Only works on simple polygons
                - Only works on counter clockwise polygons
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.TriangulationAlgorithm.Seidel">
            <summary>
                Convex decomposition algorithm created by Raimund Seidel
                Properties:
                - Decompose the polygon into trapezoids, then triangulate.
                - To use the trapezoid data, use ConvexPartitionTrapezoid()
                - Generate a lot of garbage due of the Poly2Tri library.
                - Running time is O(n log n), n = number of vertices.
                - Running time is almost linear for most simple polygons.
                - Does not care about winding order.
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.TriangulationAlgorithm.SeidelTrapezoids">
            <summary>
                The seidel trapezoids triangulation algorithm
            </summary>
        </member>
        <member name="F:Alis.Extension.Math.PathGenerator.Triangulation.TriangulationAlgorithm.DelaUny">
            <summary>
                2D constrained Delaunay triangulation algorithm.
                Based on the paper "Sweep-line algorithm for constrained Delaunay triangulation" by V.
                Properties:
                - Creates triangles with a large interior angle.
                - Supports holes
                - Running time is O(n^2), n = number of vertices.
                - Does not care about winding order.
            </summary>
        </member>
    </members>
</doc>
