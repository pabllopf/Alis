<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Core-SFML</name>
    </assembly>
    <members>
        <member name="T:Alis.Core.SFML.Animation">
            <summary>Define animation of sprite.</summary>
        </member>
        <member name="F:Alis.Core.SFML.Animation.name">
            <summary>The name</summary>
        </member>
        <member name="F:Alis.Core.SFML.Animation.state">
            <summary>The state</summary>
        </member>
        <member name="F:Alis.Core.SFML.Animation.images">
            <summary>The images</summary>
        </member>
        <member name="F:Alis.Core.SFML.Animation.textures">
            <summary>The textures</summary>
        </member>
        <member name="F:Alis.Core.SFML.Animation.index">
            <summary>The index</summary>
        </member>
        <member name="F:Alis.Core.SFML.Animation.speed">
            <summary>The speed</summary>
        </member>
        <member name="M:Alis.Core.SFML.Animation.#ctor(System.String,System.Int32,System.Single,System.String[])">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.SFML.Animation" /> class.</summary>
            <param name="name">The name.</param>
            <param name="state">The state.</param>
            <param name="speed">The speed.</param>
            <param name="images">The images.</param>
        </member>
        <member name="P:Alis.Core.SFML.Animation.Name">
            <summary>Gets or sets the name.</summary>
            <value>The name.</value>
        </member>
        <member name="P:Alis.Core.SFML.Animation.State">
            <summary>Gets or sets the state.</summary>
            <value>The state.</value>
        </member>
        <member name="P:Alis.Core.SFML.Animation.Speed">
            <summary>Gets or sets the speed.</summary>
            <value>The speed.</value>
        </member>
        <member name="P:Alis.Core.SFML.Animation.Texture">
            <summary>Gets the texture.</summary>
            <value>The texture.</value>
        </member>
        <member name="T:Alis.Core.SFML.Animator">
            <summary>Define a component</summary>
        </member>
        <member name="F:Alis.Core.SFML.Animator.sprite">
            <summary>The sprite</summary>
        </member>
        <member name="F:Alis.Core.SFML.Animator.state">
            <summary>The state</summary>
        </member>
        <member name="F:Alis.Core.SFML.Animator.clock">
            <summary>The clock</summary>
        </member>
        <member name="F:Alis.Core.SFML.Animator.animations">
            <summary>The animations</summary>
        </member>
        <member name="M:Alis.Core.SFML.Animator.#ctor(System.Int32,Alis.Core.SFML.Animation[])">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.SFML.Animator" /> class.</summary>
            <param name="name">The name.</param>
            <param name="state">The state.</param>
            <param name="animations">The animations.</param>
        </member>
        <member name="P:Alis.Core.SFML.Animator.State">
            <summary>Gets or sets the state.</summary>
            <value>The state.</value>
        </member>
        <member name="P:Alis.Core.SFML.Animator.Animations">
            <summary>Gets or sets the animations.</summary>
            <value>The animations.</value>
        </member>
        <member name="M:Alis.Core.SFML.Animator.Start">
            <summary>Starts this instance.</summary>
        </member>
        <member name="M:Alis.Core.SFML.Animator.Update">
            <summary>Updates this instance.</summary>
        </member>
        <member name="T:Alis.Core.SFML.AudioSource">
            <summary>Define a component</summary>
        </member>
        <member name="F:Alis.Core.SFML.AudioSource.audioFile">
            <summary>The file</summary>
        </member>
        <member name="F:Alis.Core.SFML.AudioSource.pathFile">
            <summary>The path file</summary>
        </member>
        <member name="F:Alis.Core.SFML.AudioSource.playOnAwake">
            <summary>The play on awake</summary>
        </member>
        <member name="F:Alis.Core.SFML.AudioSource.loop">
            <summary>The loop</summary>
        </member>
        <member name="F:Alis.Core.SFML.AudioSource.volume">
            <summary>The volume</summary>
        </member>
        <member name="F:Alis.Core.SFML.AudioSource.audio">
            <summary>The audio</summary>
        </member>
        <member name="M:Alis.Core.SFML.AudioSource.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.SFML.AudioSource" /> class.</summary>
            <param name="audioFile">The audio file.</param>
        </member>
        <member name="M:Alis.Core.SFML.AudioSource.#ctor(System.String,System.Boolean,System.Single,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.SFML.AudioSource" /> class.</summary>
            <param name="audioFile">The audio file.</param>
            <param name="playOnAwake">if set to <c>true</c> [play on awake].</param>
            <param name="volume">The volume.</param>
            <param name="loop">define is loop</param>
        </member>
        <member name="E:Alis.Core.SFML.AudioSource.OnPlay">
            <summary>Occurs when [change].</summary>
        </member>
        <member name="E:Alis.Core.SFML.AudioSource.OnStop">
            <summary>Occurs when [change].</summary>
        </member>
        <member name="E:Alis.Core.SFML.AudioSource.OnPause">
            <summary>Occurs when [change].</summary>
        </member>
        <member name="E:Alis.Core.SFML.AudioSource.OnRestart">
            <summary>Occurs when [change].</summary>
        </member>
        <member name="P:Alis.Core.SFML.AudioSource.AudioFile">
            <summary>Gets or sets the audio file.</summary>
            <value>The audio file.</value>
        </member>
        <member name="P:Alis.Core.SFML.AudioSource.PlayOnAwake">
            <summary>Gets or sets a value indicating whether [play on awake].</summary>
            <value>
            <c>true</c> if [play on awake]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Alis.Core.SFML.AudioSource.Volume">
            <summary>Gets or sets the volume.</summary>
            <value>The volume.</value>
        </member>
        <member name="P:Alis.Core.SFML.AudioSource.Loop">
            <summary>Gets or sets a value indicating whether this <see cref="T:Alis.Core.SFML.AudioSource" /> is loop.</summary>
            <value>
            <c>true</c> if loop; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Alis.Core.SFML.AudioSource.Start">
            <summary>Starts this instance.</summary>
        </member>
        <member name="M:Alis.Core.SFML.AudioSource.Update">
            <summary>Updates this instance.</summary>
        </member>
        <member name="M:Alis.Core.SFML.AudioSource.Play">
            <summary>Plays this instance.</summary>
        </member>
        <member name="M:Alis.Core.SFML.AudioSource.Stop">
            <summary>Stops this instance.</summary>
        </member>
        <member name="M:Alis.Core.SFML.AudioSource.Pause">
            <summary>Pauses this instance.</summary>
        </member>
        <member name="M:Alis.Core.SFML.AudioSource.Restart">
            <summary>Restarts this instance.</summary>
        </member>
        <member name="M:Alis.Core.SFML.AudioSource.AudioSource_OnRestart(System.Object,System.Boolean)">
            <summary>Audio the source on restart.</summary>
            <param name="sender">The sender.</param>
            <param name="e">if set to <c>true</c> [e].</param>
        </member>
        <member name="M:Alis.Core.SFML.AudioSource.AudioSource_OnPause(System.Object,System.Boolean)">
            <summary>Audio the source on pause.</summary>
            <param name="sender">The sender.</param>
            <param name="e">if set to <c>true</c> [e].</param>
        </member>
        <member name="M:Alis.Core.SFML.AudioSource.AudioSource_OnStop(System.Object,System.Boolean)">
            <summary>Audio the source on stop.</summary>
            <param name="sender">The sender.</param>
            <param name="e">if set to <c>true</c> [e].</param>
        </member>
        <member name="M:Alis.Core.SFML.AudioSource.AudioSource_OnPlay(System.Object,System.Boolean)">
            <summary>Audio the source on play.</summary>
            <param name="sender">The sender.</param>
            <param name="e">if set to <c>true</c> [e].</param>
        </member>
        <member name="T:Alis.Core.SFML.Camera">
            <summary>Define a component</summary>
        </member>
        <member name="F:Alis.Core.SFML.Camera.transform">
            <summary>The transform</summary>
        </member>
        <member name="F:Alis.Core.SFML.Camera.view">
            <summary>The view</summary>
        </member>
        <member name="F:Alis.Core.SFML.Camera.center">
            <summary>The center</summary>
        </member>
        <member name="F:Alis.Core.SFML.Camera.size">
            <summary>The size</summary>
        </member>
        <member name="M:Alis.Core.SFML.Camera.#ctor(System.Numerics.Vector2,System.Numerics.Vector2)">
            <summary>
            Initializes a new instance of the <see cref="T:Alis.Core.SFML.Camera"/> class.
            </summary>
            <param name="center">The center.</param>
            <param name="size">The size.</param>
        </member>
        <member name="M:Alis.Core.SFML.Camera.#ctor(System.Numerics.Vector2)">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.SFML.Camera" /> class.</summary>
            <param name="size">resolution of camera.</param>
        </member>
        <member name="M:Alis.Core.SFML.Camera.Start">
            <summary>Start this instance.</summary>
        </member>
        <member name="M:Alis.Core.SFML.Camera.Update">
            <summary>Update this instance.</summary>
            TODO Correct the camera to fix the movement of sprites. (probaly is the transform).
        </member>
        <member name="T:Alis.Core.SFML.Collision">
            <summary>Define a component</summary>
        </member>
        <member name="F:Alis.Core.SFML.Collision.isTrigger">
            <summary>The is trigger</summary>
        </member>
        <member name="M:Alis.Core.SFML.Collision.#ctor(System.Numerics.Vector2,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.SFML.Collision" /> class.</summary>
            <param name="border">The border.</param>
            <param name="isTrigger">if set to <c>true</c> [is trigger].</param>
        </member>
        <member name="P:Alis.Core.SFML.Collision.IsTrigger">
            <summary>Gets or sets a value indicating whether this instance is trigger.</summary>
            <value>
            <c>true</c> if this instance is trigger; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Alis.Core.SFML.Collision.Start">
            <summary>Start this instance.</summary>
        </member>
        <member name="M:Alis.Core.SFML.Collision.Update">
            <summary>Update this instance.</summary>
        </member>
        <member name="T:Alis.Core.SFML.Sprite">
            <summary>Define a component</summary>
        </member>
        <member name="F:Alis.Core.SFML.Sprite.image">
            <summary>The image</summary>
        </member>
        <member name="F:Alis.Core.SFML.Sprite.pathImage">
            <summary>The path image</summary>
        </member>
        <member name="F:Alis.Core.SFML.Sprite.depth">
            <summary>The depth</summary>
        </member>
        <member name="F:Alis.Core.SFML.Sprite.sprite">
            <summary>The sprite</summary>
        </member>
        <member name="M:Alis.Core.SFML.Sprite.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.SFML.Sprite" /> class.</summary>
            <param name="image">The image.</param>
        </member>
        <member name="M:Alis.Core.SFML.Sprite.#ctor(System.String,System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.SFML.Sprite" /> class.</summary>
            <param name="image">The image.</param>
            <param name="depth">The depth.</param>
        </member>
        <member name="E:Alis.Core.SFML.Sprite.OnDraw">
            <summary>Occurs when [on draw].</summary>
        </member>
        <member name="P:Alis.Core.SFML.Sprite.Image">
            <summary>Gets or sets the image.</summary>
            <value>The image.</value>
        </member>
        <member name="P:Alis.Core.SFML.Sprite.Depth">
            <summary>Gets or sets the depth.</summary>
            <value>The depth.</value>
        </member>
        <member name="M:Alis.Core.SFML.Sprite.Start">
            <summary>Starts this instance.</summary>
        </member>
        <member name="M:Alis.Core.SFML.Sprite.Update">
            <summary>Updates this instance.</summary>
        </member>
        <member name="M:Alis.Core.SFML.Sprite.GetDraw">
            <summary>Gets the draw.</summary>
            <returns>Return none</returns>
        </member>
        <member name="M:Alis.Core.SFML.Sprite.Sprite_OnDraw(System.Object,System.Boolean)">
            <summary>Sprites the on draw.</summary>
            <param name="sender">The sender.</param>
            <param name="e">if set to <c>true</c> [e].</param>
        </member>
        <member name="T:Alis.Core.SFML.InputSFML">
            <summary>Define the input</summary>
        </member>
        <member name="M:Alis.Core.SFML.InputSFML.#ctor(Alis.Core.Config)">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.SFML.InputSFML" /> class.</summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Alis.Core.SFML.InputSFML.Awake">
            <summary>Awakes this instance.</summary>
            <returns>Return none</returns>
        </member>
        <member name="M:Alis.Core.SFML.InputSFML.Start">
            <summary>Starts this instance.</summary>
            <returns>Return none</returns>
        </member>
        <member name="M:Alis.Core.SFML.InputSFML.Update">
            <summary>Updates this instance.</summary>
            <returns>Return none</returns>
        </member>
        <member name="M:Alis.Core.SFML.InputSFML.FixedUpdate">
            <summary>Fixed the update.</summary>
            <returns>Return none</returns>
        </member>
        <member name="M:Alis.Core.SFML.InputSFML.Stop">
            <summary>Stops this instance.</summary>
            <returns>Return none</returns>
        </member>
        <member name="M:Alis.Core.SFML.InputSFML.Exit">
            <summary>Exits this instance.</summary>
            <returns>Return none</returns>
        </member>
        <member name="M:Alis.Core.SFML.InputSFML.PollEvents">
            <summary>Polls the events.</summary>
        </member>
        <member name="T:Alis.Core.SFML.RenderSFML">
            <summary>Implement the render. </summary>
        </member>
        <member name="F:Alis.Core.SFML.RenderSFML.renderSFML">
            <summary>The render SFML</summary>
        </member>
        <member name="F:Alis.Core.SFML.RenderSFML.config">
            <summary>The configuration</summary>
        </member>
        <member name="F:Alis.Core.SFML.RenderSFML.renderWindow">
            <summary>The render window</summary>
        </member>
        <member name="F:Alis.Core.SFML.RenderSFML.renderTexture">
            <summary>The render texture</summary>
        </member>
        <member name="F:Alis.Core.SFML.RenderSFML.frame">
            <summary>The frame</summary>
        </member>
        <member name="F:Alis.Core.SFML.RenderSFML.videoMode">
            <summary>The video mode</summary>
        </member>
        <member name="F:Alis.Core.SFML.RenderSFML.sprites">
            <summary>The sprites</summary>
        </member>
        <member name="F:Alis.Core.SFML.RenderSFML.collisions">
            <summary>The collisions</summary>
        </member>
        <member name="P:Alis.Core.SFML.RenderSFML.Collisions">
            <summary>Gets or sets the collisions.</summary>
            <value>The collisions.</value>
        </member>
        <member name="P:Alis.Core.SFML.RenderSFML.RenderWindow">
            <summary>Gets the render window.</summary>
            <value>The render window.</value>
        </member>
        <member name="P:Alis.Core.SFML.RenderSFML.RenderTexture">
            <summary>Gets the render texture.</summary>
            <value>The render texture.</value>
        </member>
        <member name="P:Alis.Core.SFML.RenderSFML.CurrentRenderSFML">
            <summary>Gets or sets the render SFML.</summary>
            <value>The render SFML.</value>
        </member>
        <member name="M:Alis.Core.SFML.RenderSFML.#ctor(Alis.Core.Config)">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.SFML.RenderSFML" /> class.</summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Alis.Core.SFML.RenderSFML.Awake">
            <summary>Awakes this instance.</summary>
            <returns>Return none</returns>
        </member>
        <member name="M:Alis.Core.SFML.RenderSFML.Start">
            <summary>Starts this instance.</summary>
            <returns>Return none</returns>
        </member>
        <member name="M:Alis.Core.SFML.RenderSFML.FixedUpdate">
            <summary>Fixed the update.</summary>
        </member>
        <member name="M:Alis.Core.SFML.RenderSFML.Update">
            <summary>Updates this instance.</summary>
            <returns>Return none</returns>
        </member>
        <member name="M:Alis.Core.SFML.RenderSFML.Stop">
            <summary>Stops this instance.</summary>
            <returns>Return none</returns>
        </member>
        <member name="M:Alis.Core.SFML.RenderSFML.Exit">
            <summary>Exits this instance.</summary>
            <returns>Return none</returns>
        </member>
        <member name="M:Alis.Core.SFML.RenderSFML.FrameBytes">
            <summary>Frames the bytes.</summary>
            <returns>Return the frame in bytes.</returns>
        </member>
        <member name="M:Alis.Core.SFML.RenderSFML.AddDraw(Alis.Core.Component)">
            <summary>Adds the draw.</summary>
            <param name="draw">The draw.</param>
        </member>
        <member name="M:Alis.Core.SFML.RenderSFML.Remove(Alis.Core.Component)">
            <summary>Removes the specified draw.</summary>
            <param name="draw">The draw.</param>
        </member>
        <member name="M:Alis.Core.SFML.RenderSFML.GetDraws``1">
            <summary>Gets the draws.</summary>
            <typeparam name="T"></typeparam>
            <returns>Return a list</returns>
        </member>
        <member name="M:Alis.Core.SFML.RenderSFML.RenderWindow_Closed(System.Object,System.EventArgs)">
            <summary>Handles the Closed event of the RenderWindow control.</summary>
            <param name="sender">The source of the event.</param>
            <param name="e">The <see cref="T:System.EventArgs" /> instance containing the event data.</param>
        </member>
        <member name="T:Alis.Core.SFML.VideoGame">
            <summary>Video game</summary>
        </member>
        <member name="M:Alis.Core.SFML.VideoGame.#ctor(Alis.Core.Config,Alis.Core.SceneManager)">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.SFML.VideoGame" /> class.</summary>
            <param name="config">The configuration.</param>
            <param name="sceneManager">The scene manager.</param>
        </member>
        <member name="M:Alis.Core.SFML.VideoGame.#ctor(Alis.Core.Config,Alis.Core.Scene[])">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.SFML.VideoGame" /> class.</summary>
            <param name="config">The configuration.</param>
            <param name="scenes">The scene.</param>
        </member>
        <member name="M:Alis.Core.SFML.VideoGame.Builder">
            <summary>The builder</summary>
        </member>
        <member name="T:Alis.Core.SFML.VideoGame.VideoGameBuilder">
            <summary>Video Game Builder</summary>
        </member>
        <member name="F:Alis.Core.SFML.VideoGame.VideoGameBuilder.current">
            <summary>The current</summary>
        </member>
        <member name="F:Alis.Core.SFML.VideoGame.VideoGameBuilder.config">
            <summary>The configuration</summary>
        </member>
        <member name="F:Alis.Core.SFML.VideoGame.VideoGameBuilder.sceneManager">
            <summary>The scene manager</summary>
        </member>
        <member name="M:Alis.Core.SFML.VideoGame.VideoGameBuilder.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Alis.Core.SFML.VideoGame.VideoGameBuilder" /> class.</summary>
        </member>
        <member name="M:Alis.Core.SFML.VideoGame.VideoGameBuilder.Config(Alis.Core.Config)">
            <summary>Configurations the specified configuration.</summary>
            <param name="config">The configuration.</param>
            <returns>Return the video game builder</returns>
        </member>
        <member name="M:Alis.Core.SFML.VideoGame.VideoGameBuilder.SceneManager(Alis.Core.SceneManager)">
            <summary>Scenes the manager.</summary>
            <param name="sceneManager">The scene manager.</param>
            <returns>Return the scene manager. </returns>
        </member>
        <member name="M:Alis.Core.SFML.VideoGame.VideoGameBuilder.Build">
            <summary>Builds this instance.</summary>
            <returns>Return the build.</returns>
        </member>
        <member name="M:Alis.Core.SFML.VideoGame.VideoGameBuilder.Build(Alis.Core.SFML.VideoGame@)">
            <summary>Builds the specified game.</summary>
            <param name="game">The game.</param>
            <returns>Return the build.</returns>
        </member>
        <member name="M:Alis.Core.SFML.VideoGame.VideoGameBuilder.Run">
            <summary>Runs this instance.</summary>
        </member>
        <member name="T:CoreSFML.Properties.Resources">
            <summary>
              Clase de recurso fuertemente tipado, para buscar cadenas traducidas, etc.
            </summary>
        </member>
        <member name="P:CoreSFML.Properties.Resources.ResourceManager">
            <summary>
              Devuelve la instancia de ResourceManager almacenada en caché utilizada por esta clase.
            </summary>
        </member>
        <member name="P:CoreSFML.Properties.Resources.Culture">
            <summary>
              Reemplaza la propiedad CurrentUICulture del subproceso actual para todas las
              búsquedas de recursos mediante esta clase de recurso fuertemente tipado.
            </summary>
        </member>
        <member name="T:SFML.Audio.Listener">
            <summary>
            The audio listener is the point in the scene
            from where all the sounds are heard
            </summary>
        </member>
        <member name="P:SFML.Audio.Listener.GlobalVolume">
            <summary>
            The volume is a number between 0 and 100; it is combined with
            the individual volume of each sound / music.
            The default value for the volume is 100 (maximum).
            </summary>
        </member>
        <member name="P:SFML.Audio.Listener.Position">
            <summary>
            3D position of the listener (default is (0, 0, 0))
            </summary>
        </member>
        <member name="P:SFML.Audio.Listener.Direction">
            <summary>
            The direction (also called "at vector") is the vector
            pointing forward from the listener's perspective. Together
            with the up vector, it defines the 3D orientation of the
            listener in the scene. The direction vector doesn't
            have to be normalized.
            The default listener's direction is (0, 0, -1).
            </summary>
        </member>
        <member name="P:SFML.Audio.Listener.UpVector">
            <summary>
            The up vector is the vector that points upward from the
            listener's perspective. Together with the direction, it
            defines the 3D orientation of the listener in the scene.
            The up vector doesn't have to be normalized.
            The default listener's up vector is (0, 1, 0). It is usually
            not necessary to change it, especially in 2D scenarios.
            </summary>
        </member>
        <member name="T:SFML.Audio.Music">
            <summary>
            Streamed music played from an audio file
            </summary>
        </member>
        <member name="M:SFML.Audio.Music.#ctor(System.String)">
            <summary>
            Constructs a music from an audio file
            </summary>
            <param name="filename">Path of the music file to open</param>
        </member>
        <member name="M:SFML.Audio.Music.#ctor(System.IO.Stream)">
            <summary>
            Constructs a music from a custom stream
            </summary>
            <param name="stream">Source stream to read from</param>
        </member>
        <member name="M:SFML.Audio.Music.#ctor(System.Byte[])">
            <summary>
            Constructs a music from an audio file in memory
            </summary>
            <param name="bytes">Byte array containing the file contents</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Audio.Music.Play">
             <summary>
             Start or resume playing the audio stream.
            
             This function starts the stream if it was stopped, resumes
             it if it was paused, and restarts it from beginning if it
             was it already playing.
             This function uses its own thread so that it doesn't block
             the rest of the program while the stream is played.
             </summary>
        </member>
        <member name="M:SFML.Audio.Music.Pause">
             <summary>
             Pause the audio stream.
            
             This function pauses the stream if it was playing,
             otherwise (stream already paused or stopped) it has no effect.
             </summary>
        </member>
        <member name="M:SFML.Audio.Music.Stop">
             <summary>
             Stop playing the audio stream.
            
             This function stops the stream if it was playing or paused,
             and does nothing if it was already stopped.
             It also resets the playing position (unlike Pause()).
             </summary>
        </member>
        <member name="P:SFML.Audio.Music.SampleRate">
             <summary>
             Sample rate of the music.
            
             The sample rate is the number of audio samples played per
             second. The higher, the better the quality.
             </summary>
        </member>
        <member name="P:SFML.Audio.Music.ChannelCount">
            <summary>
            Number of channels (1 = mono, 2 = stereo)
            </summary>
        </member>
        <member name="P:SFML.Audio.Music.Status">
            <summary>
            Current status of the music (see SoundStatus enum)
            </summary>
        </member>
        <member name="P:SFML.Audio.Music.Duration">
            <summary>
            Total duration of the music
            </summary>
        </member>
        <member name="P:SFML.Audio.Music.Loop">
             <summary>
             Flag if the music should loop after reaching the end.
            
             If set, the music will restart from beginning after
             reaching the end and so on, until it is stopped or
             Loop = false is set.
             The default looping state for music is false.
             </summary>
        </member>
        <member name="P:SFML.Audio.Music.Pitch">
            <summary>
            Pitch of the music.
            
            The pitch represents the perceived fundamental frequency
            of a sound; thus you can make a sound more acute or grave
            by changing its pitch. A side effect of changing the pitch
            is to modify the playing speed of the sound as well.
            The default value for the pitch is 1.
            </summary>
        </member>
        <member name="P:SFML.Audio.Music.Volume">
            <summary>
            Volume of the music.
            
            The volume is a value between 0 (mute) and 100 (full volume).
            The default value for the volume is 100.
            </summary>
        </member>
        <member name="P:SFML.Audio.Music.Position">
             <summary>
             3D position of the music in the audio scene.
            
             Only sounds with one channel (mono sounds) can be
             spatialized.
             The default position of a sound is (0, 0, 0).
             </summary>
        </member>
        <member name="P:SFML.Audio.Music.RelativeToListener">
             <summary>
             Make the music's position relative to the listener or absolute.
            
             Making a sound relative to the listener will ensure that it will always
             be played the same way regardless the position of the listener.
             This can be useful for non-spatialized sounds, sounds that are
             produced by the listener, or sounds attached to it.
             The default value is false (position is absolute).
             </summary>
        </member>
        <member name="P:SFML.Audio.Music.MinDistance">
             <summary>
             Minimum distance of the music.
            
             The "minimum distance" of a sound is the maximum
             distance at which it is heard at its maximum volume. Further
             than the minimum distance, it will start to fade out according
             to its attenuation factor. A value of 0 ("inside the head
             of the listener") is an invalid value and is forbidden.
             The default value of the minimum distance is 1.
             </summary>
        </member>
        <member name="P:SFML.Audio.Music.Attenuation">
             <summary>
             Attenuation factor of the music.
            
             The attenuation is a multiplicative factor which makes
             the music more or less loud according to its distance
             from the listener. An attenuation of 0 will produce a
             non-attenuated sound, i.e. its volume will always be the same
             whether it is heard from near or from far. On the other hand,
             an attenuation value such as 100 will make the sound fade out
             very quickly as it gets further from the listener.
             The default value of the attenuation is 1.
             </summary>
        </member>
        <member name="P:SFML.Audio.Music.PlayingOffset">
            <summary>
            Current playing position of the music.
            
            The playing position can be changed when the music is
            either paused or playing.
            </summary>
        </member>
        <member name="P:SFML.Audio.Music.LoopPoints">
            <summary>
            Current loop points of the music.
            
            Since setting performs some adjustments on the
            provided values and rounds them to internal samples, getting this
            value later is not guaranteed to return the same times passed
            into it. However, it is guaranteed to return times that will map 
            to the valid internal samples of this Music if they are later
            set again.
            </summary>
        </member>
        <member name="M:SFML.Audio.Music.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Audio.Music.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="T:SFML.Audio.SoundStatus">
            <summary>
            Enumeration of all possible sound states
            </summary>
        </member>
        <member name="F:SFML.Audio.SoundStatus.Stopped">
            <summary>Sound is not playing</summary>
        </member>
        <member name="F:SFML.Audio.SoundStatus.Paused">
            <summary>Sound is paused</summary>
        </member>
        <member name="F:SFML.Audio.SoundStatus.Playing">
            <summary>Sound is playing</summary>
        </member>
        <member name="T:SFML.Audio.Sound">
            <summary>
            Regular sound that can be played in the audio environment
            </summary>
        </member>
        <member name="M:SFML.Audio.Sound.#ctor">
            <summary>
            Default constructor (invalid sound)
            </summary>
        </member>
        <member name="M:SFML.Audio.Sound.#ctor(SFML.Audio.SoundBuffer)">
            <summary>
            Construct the sound with a buffer
            </summary>
            <param name="buffer">Sound buffer containing the audio data to play with the sound</param>
        </member>
        <member name="M:SFML.Audio.Sound.#ctor(SFML.Audio.Sound)">
            <summary>
            Construct the sound from another source
            </summary>
            <param name="copy">Sound to copy</param>
        </member>
        <member name="M:SFML.Audio.Sound.Play">
             <summary>
             Start or resume playing the sound.
            
             This function starts the stream if it was stopped, resumes
             it if it was paused, and restarts it from beginning if it
             was it already playing.
             This function uses its own thread so that it doesn't block
             the rest of the program while the sound is played.
             </summary>
        </member>
        <member name="M:SFML.Audio.Sound.Pause">
             <summary>
             Pause the sound.
            
             This function pauses the sound if it was playing,
             otherwise (sound already paused or stopped) it has no effect.
             </summary>
        </member>
        <member name="M:SFML.Audio.Sound.Stop">
             <summary>
             Stop playing the sound.
            
             This function stops the sound if it was playing or paused,
             and does nothing if it was already stopped.
             It also resets the playing position (unlike pause()).
             </summary>
        </member>
        <member name="P:SFML.Audio.Sound.SoundBuffer">
            <summary>
            Buffer containing the sound data to play through the sound.
            
            It is important to note that the sound buffer is not copied,
            thus the SoundBuffer instance must remain alive as long
            as it is attached to the sound.
            </summary>
        </member>
        <member name="P:SFML.Audio.Sound.Status">
            <summary>
            Current status of the sound (see SoundStatus enum)
            </summary>
        </member>
        <member name="P:SFML.Audio.Sound.Loop">
             <summary>
             Flag if the sound should loop after reaching the end.
            
             If set, the sound will restart from beginning after
             reaching the end and so on, until it is stopped or
             Loop = false is set.
             The default looping state for sounds is false.
             </summary>
        </member>
        <member name="P:SFML.Audio.Sound.Pitch">
            <summary>
            Pitch of the sound.
            
            The pitch represents the perceived fundamental frequency
            of a sound; thus you can make a sound more acute or grave
            by changing its pitch. A side effect of changing the pitch
            is to modify the playing speed of the sound as well.
            The default value for the pitch is 1.
            </summary>
        </member>
        <member name="P:SFML.Audio.Sound.Volume">
            <summary>
            Volume of the sound.
            
            The volume is a value between 0 (mute) and 100 (full volume).
            The default value for the volume is 100.
            </summary>
        </member>
        <member name="P:SFML.Audio.Sound.PlayingOffset">
            <summary>
            Current playing position of the sound.
            
            The playing position can be changed when the sound is
            either paused or playing.
            </summary>
        </member>
        <member name="P:SFML.Audio.Sound.Position">
             <summary>
             3D position of the sound in the audio scene.
            
             Only sounds with one channel (mono sounds) can be
             spatialized.
             The default position of a sound is (0, 0, 0).
             </summary>
        </member>
        <member name="P:SFML.Audio.Sound.RelativeToListener">
             <summary>
             Make the music's position relative to the listener or absolute.
            
             Making a sound relative to the listener will ensure that it will always
             be played the same way regardless the position of the listener.
             This can be useful for non-spatialized sounds, sounds that are
             produced by the listener, or sounds attached to it.
             The default value is false (position is absolute).
             </summary>
        </member>
        <member name="P:SFML.Audio.Sound.MinDistance">
             <summary>
             Minimum distance of the sound.
            
             The "minimum distance" of a sound is the maximum
             distance at which it is heard at its maximum volume. Further
             than the minimum distance, it will start to fade out according
             to its attenuation factor. A value of 0 ("inside the head
             of the listener") is an invalid value and is forbidden.
             The default value of the minimum distance is 1.
             </summary>
        </member>
        <member name="P:SFML.Audio.Sound.Attenuation">
             <summary>
             Attenuation factor of the music.
            
             The attenuation is a multiplicative factor which makes
             the music more or less loud according to its distance
             from the listener. An attenuation of 0 will produce a
             non-attenuated sound, i.e. its volume will always be the same
             whether it is heard from near or from far. On the other hand,
             an attenuation value such as 100 will make the sound fade out
             very quickly as it gets further from the listener.
             The default value of the attenuation is 1.
             </summary>
        </member>
        <member name="M:SFML.Audio.Sound.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Audio.Sound.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="T:SFML.Audio.SoundBuffer">
            <summary>
            Storage for audio samples defining a sound
            </summary>
        </member>
        <member name="M:SFML.Audio.SoundBuffer.#ctor(System.String)">
            <summary>
            Construct a sound buffer from a file
            
            Here is a complete list of all the supported audio formats:
            ogg, wav, flac, aiff, au, raw, paf, svx, nist, voc, ircam,
            w64, mat4, mat5 pvf, htk, sds, avr, sd2, caf, wve, mpc2k, rf64.
            </summary>
            <param name="filename">Path of the sound file to load</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Audio.SoundBuffer.#ctor(System.IO.Stream)">
             <summary>
             Construct a sound buffer from a custom stream.
            
             Here is a complete list of all the supported audio formats:
             ogg, wav, flac, aiff, au, raw, paf, svx, nist, voc, ircam,
             w64, mat4, mat5 pvf, htk, sds, avr, sd2, caf, wve, mpc2k, rf64.
             </summary>
             <param name="stream">Source stream to read from</param>
             <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Audio.SoundBuffer.#ctor(System.Byte[])">
            <summary>
            Construct a sound buffer from a file in memory.
            
            Here is a complete list of all the supported audio formats:
            ogg, wav, flac, aiff, au, raw, paf, svx, nist, voc, ircam,
            w64, mat4, mat5 pvf, htk, sds, avr, sd2, caf, wve, mpc2k, rf64.
            </summary>
            <param name="bytes">Byte array containing the file contents</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Audio.SoundBuffer.#ctor(System.Int16[],System.UInt32,System.UInt32)">
            <summary>
            Construct a sound buffer from an array of samples
            </summary>
            <param name="samples">Array of samples</param>
            <param name="channelCount">Channel count</param>
            <param name="sampleRate">Sample rate</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Audio.SoundBuffer.#ctor(SFML.Audio.SoundBuffer)">
            <summary>
            Construct a sound buffer from another sound buffer
            </summary>
            <param name="copy">Sound buffer to copy</param>
        </member>
        <member name="M:SFML.Audio.SoundBuffer.SaveToFile(System.String)">
             <summary>
             Save the sound buffer to an audio file.
            
             Here is a complete list of all the supported audio formats:
             ogg, wav, flac, aiff, au, raw, paf, svx, nist, voc, ircam,
             w64, mat4, mat5 pvf, htk, sds, avr, sd2, caf, wve, mpc2k, rf64.
             </summary>
             <param name="filename">Path of the sound file to write</param>
             <returns>True if saving has been successful</returns>
        </member>
        <member name="P:SFML.Audio.SoundBuffer.SampleRate">
             <summary>
             Sample rate of the sound buffer.
            
             The sample rate is the number of audio samples played per
             second. The higher, the better the quality.
             </summary>
        </member>
        <member name="P:SFML.Audio.SoundBuffer.ChannelCount">
            <summary>
            Number of channels (1 = mono, 2 = stereo)
            </summary>
        </member>
        <member name="P:SFML.Audio.SoundBuffer.Duration">
            <summary>
            Total duration of the buffer
            </summary>
        </member>
        <member name="P:SFML.Audio.SoundBuffer.Samples">
             <summary>
             Array of audio samples stored in the buffer.
            
             The format of the returned samples is 16 bits signed integer
             (sf::Int16).
             </summary>
        </member>
        <member name="M:SFML.Audio.SoundBuffer.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Audio.SoundBuffer.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="T:SFML.Audio.SoundBufferRecorder">
            <summary>
            Specialized SoundRecorder which saves the captured
            audio data into a sound buffer
            </summary>
        </member>
        <member name="P:SFML.Audio.SoundBufferRecorder.SoundBuffer">
             <summary>
             Sound buffer containing the captured audio data
            
             The sound buffer is valid only after the capture has ended.
             This function provides a reference to the internal
             sound buffer, but you should make a copy of it if you want
             to make any modifications to it.
             </summary>
        </member>
        <member name="M:SFML.Audio.SoundBufferRecorder.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Audio.SoundBufferRecorder.OnStart">
            <summary>
            Called when a new capture starts
            </summary>
            <returns>False to abort recording audio data, true to continue</returns>
        </member>
        <member name="M:SFML.Audio.SoundBufferRecorder.OnProcessSamples(System.Int16[])">
            <summary>
            Process a new chunk of recorded samples
            </summary>
            <param name="samples">Array of samples to process</param>
            <returns>False to stop recording audio data, true to continue</returns>
        </member>
        <member name="M:SFML.Audio.SoundBufferRecorder.OnStop">
            <summary>
            Called when the current capture stops
            </summary>
        </member>
        <member name="T:SFML.Audio.SoundRecorder">
            <summary>
            Base class intended for capturing sound data
            </summary>
        </member>
        <member name="M:SFML.Audio.SoundRecorder.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:SFML.Audio.SoundRecorder.Start">
            <summary>
            Start the capture using the default sample rate (44100 Hz).
            
            Please note that only one capture can happen at the same time.
            </summary>
        </member>
        <member name="M:SFML.Audio.SoundRecorder.Start(System.UInt32)">
             <summary>
             Start the capture.
            
             The sampleRate parameter defines the number of audio samples
             captured per second. The higher, the better the quality
             (for example, 44100 samples/sec is CD quality).
             This function uses its own thread so that it doesn't block
             the rest of the program while the capture runs.
             
             Please note that only one capture can happen at the same time.
             </summary>
             <param name="sampleRate"> Sound frequency; the more samples, the higher the quality (44100 by default = CD quality)</param>
        </member>
        <member name="M:SFML.Audio.SoundRecorder.Stop">
            <summary>
            Stop the capture
            </summary>
        </member>
        <member name="P:SFML.Audio.SoundRecorder.SampleRate">
            <summary>
            Sample rate of the sound recorder.
            </summary>
            
            <remarks>
            The sample rate defines the number of audio samples
            captured per second. The higher, the better the quality
            (for example, 44100 samples/sec is CD quality).
            </remarks>
        </member>
        <member name="P:SFML.Audio.SoundRecorder.ChannelCount">
            <summary>
            Get/Set the channel count of the audio capture device
            </summary>
            
            <remarks>
            This method allows you to specify the number of channels
            used for recording. Currently only 16-bit mono (1) and
            16-bit stereo (2) are supported.
            </remarks>
        </member>
        <member name="P:SFML.Audio.SoundRecorder.IsAvailable">
            <summary>
            Check if the system supports audio capture.
            </summary>
            
            <remarks>
            This function should always be called before using
            the audio capture features. If it returns false, then
            any attempt to use the SoundRecorder or one of its derived
            classes will fail.
            </remarks>
        </member>
        <member name="M:SFML.Audio.SoundRecorder.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Audio.SoundRecorder.OnStart">
             <summary>
             Start capturing audio data.
            
             This virtual function may be overridden by a derived class
             if something has to be done every time a new capture
             starts. If not, this function can be ignored; the default
             implementation does nothing.
             </summary>
             <returns>False to abort recording audio data, true to continue</returns>
        </member>
        <member name="M:SFML.Audio.SoundRecorder.OnProcessSamples(System.Int16[])">
             <summary>
             Process a new chunk of recorded samples.
            
             This virtual function is called every time a new chunk of
             recorded data is available. The derived class can then do
             whatever it wants with it (storing it, playing it, sending
             it over the network, etc.).
             </summary>
             <param name="samples">Array of samples to process</param>
             <returns>False to stop recording audio data, true to continue</returns>
        </member>
        <member name="M:SFML.Audio.SoundRecorder.OnStop">
             <summary>
             Stop capturing audio data.
            
             This virtual function may be overridden by a derived class
             if something has to be done every time the capture
             ends. If not, this function can be ignored; the default
             implementation does nothing.
             </summary>
        </member>
        <member name="M:SFML.Audio.SoundRecorder.SetProcessingInterval(SFML.System.Time)">
             <summary>
             The processing interval controls the period
             between calls to the onProcessSamples function. You may
             want to use a small interval if you want to process the
             recorded data in real time, for example.
            
             Note: this is only a hint, the actual period may vary.
             So don't rely on this parameter to implement precise timing.
            
             The default processing interval is 100 ms.
             </summary>
        </member>
        <member name="P:SFML.Audio.SoundRecorder.AvailableDevices">
            <summary>
            Get the list of the names of all available audio capture devices
            </summary>
        </member>
        <member name="P:SFML.Audio.SoundRecorder.DefaultDevice">
            <summary>
            Get the name of the default audio capture device
            </summary>
        </member>
        <member name="M:SFML.Audio.SoundRecorder.SetDevice(System.String)">
            <summary>
            Set the audio capture device
            </summary>
            <param name="Name">The name of the audio capture device</param>
            <returns>True, if it was able to set the requested device</returns>
        </member>
        <member name="M:SFML.Audio.SoundRecorder.GetDevice">
            <summary>
            Get the name of the current audio capture device
            </summary>
            <returns>The name of the current audio capture device</returns>
        </member>
        <member name="M:SFML.Audio.SoundRecorder.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="M:SFML.Audio.SoundRecorder.ProcessSamples(System.IntPtr,System.UInt32,System.IntPtr)">
            <summary>
            Function called directly by the C library ; convert
            arguments and forward them to the internal virtual function
            </summary>
            <param name="samples">Pointer to the array of samples</param>
            <param name="nbSamples">Number of samples in the array</param>
            <param name="userData">User data -- unused</param>
            <returns>False to stop recording audio data, true to continue</returns>
        </member>
        <member name="T:SFML.Audio.SoundStream">
            <summary>
            Abstract base class for streamed audio sources
            </summary>
        </member>
        <member name="M:SFML.Audio.SoundStream.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:SFML.Audio.SoundStream.Play">
             <summary>
             Start or resume playing the audio stream.
            
             This function starts the stream if it was stopped, resumes
             it if it was paused, and restarts it from beginning if it
             was it already playing.
             This function uses its own thread so that it doesn't block
             the rest of the program while the stream is played.
             </summary>
        </member>
        <member name="M:SFML.Audio.SoundStream.Pause">
             <summary>
             Pause the audio stream.
            
             This function pauses the stream if it was playing,
             otherwise (stream already paused or stopped) it has no effect.
             </summary>
        </member>
        <member name="M:SFML.Audio.SoundStream.Stop">
             <summary>
             Stop playing the audio stream.
            
             This function stops the stream if it was playing or paused,
             and does nothing if it was already stopped.
             It also resets the playing position (unlike pause()).
             </summary>
        </member>
        <member name="P:SFML.Audio.SoundStream.SampleRate">
             <summary>
             Sample rate of the stream
            
             The sample rate is the number of audio samples played per
             second. The higher, the better the quality.
             </summary>
        </member>
        <member name="P:SFML.Audio.SoundStream.ChannelCount">
            <summary>
            Number of channels (1 = mono, 2 = stereo)
            </summary>
        </member>
        <member name="P:SFML.Audio.SoundStream.Status">
            <summary>
            Current status of the sound stream (see SoundStatus enum)
            </summary>
        </member>
        <member name="P:SFML.Audio.SoundStream.Loop">
             <summary>
             Flag if the music should loop after reaching the end.
            
             If set, the music will restart from beginning after
             reaching the end and so on, until it is stopped or
             Loop = false is set.
             The default looping state for music is false.
             </summary>
        </member>
        <member name="P:SFML.Audio.SoundStream.Pitch">
            <summary>
            Pitch of the stream.
            
            The pitch represents the perceived fundamental frequency
            of a sound; thus you can make a sound more acute or grave
            by changing its pitch. A side effect of changing the pitch
            is to modify the playing speed of the sound as well.
            The default value for the pitch is 1.
            </summary>
        </member>
        <member name="P:SFML.Audio.SoundStream.Volume">
            <summary>
            Volume of the stream.
            
            The volume is a value between 0 (mute) and 100 (full volume).
            The default value for the volume is 100.
            </summary>
        </member>
        <member name="P:SFML.Audio.SoundStream.Position">
             <summary>
             3D position of the stream in the audio scene.
            
             Only sounds with one channel (mono sounds) can be
             spatialized.
             The default position of a sound is (0, 0, 0).
             </summary>
        </member>
        <member name="P:SFML.Audio.SoundStream.RelativeToListener">
             <summary>
             Make the stream's position relative to the listener or absolute.
            
             Making a sound relative to the listener will ensure that it will always
             be played the same way regardless the position of the listener.
             This can be useful for non-spatialized sounds, sounds that are
             produced by the listener, or sounds attached to it.
             The default value is false (position is absolute).
             </summary>
        </member>
        <member name="P:SFML.Audio.SoundStream.MinDistance">
             <summary>
             Minimum distance of the music.
            
             The "minimum distance" of a sound is the maximum
             distance at which it is heard at its maximum volume. Further
             than the minimum distance, it will start to fade out according
             to its attenuation factor. A value of 0 ("inside the head
             of the listener") is an invalid value and is forbidden.
             The default value of the minimum distance is 1.
             </summary>
        </member>
        <member name="P:SFML.Audio.SoundStream.Attenuation">
             <summary>
             Attenuation factor of the stream.
            
             The attenuation is a multiplicative factor which makes
             the music more or less loud according to its distance
             from the listener. An attenuation of 0 will produce a
             non-attenuated sound, i.e. its volume will always be the same
             whether it is heard from near or from far. On the other hand,
             an attenuation value such as 100 will make the sound fade out
             very quickly as it gets further from the listener.
             The default value of the attenuation is 1.
             </summary>
        </member>
        <member name="P:SFML.Audio.SoundStream.PlayingOffset">
            <summary>
            Current playing position of the stream.
            
            The playing position can be changed when the music is
            either paused or playing.
            </summary>
        </member>
        <member name="M:SFML.Audio.SoundStream.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Audio.SoundStream.Initialize(System.UInt32,System.UInt32)">
            <summary>
            Set the audio stream parameters, you must call it before Play()
            </summary>
            <param name="channelCount">Number of channels</param>
            <param name="sampleRate">Sample rate, in samples per second</param>
        </member>
        <member name="M:SFML.Audio.SoundStream.OnGetData(System.Int16[]@)">
            <summary>
            Virtual function called each time new audio data is needed to feed the stream
            </summary>
            <param name="samples">Array of samples to fill for the stream</param>
            <returns>True to continue playback, false to stop</returns>
        </member>
        <member name="M:SFML.Audio.SoundStream.OnSeek(SFML.System.Time)">
            <summary>
            Virtual function called to seek into the stream
            </summary>
            <param name="timeOffset">New position</param>
        </member>
        <member name="M:SFML.Audio.SoundStream.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="T:SFML.Audio.SoundStream.Chunk">
            <summary>
            Structure mapping the C library arguments passed to the data callback
            </summary>
        </member>
        <member name="M:SFML.Audio.SoundStream.GetData(SFML.Audio.SoundStream.Chunk@,System.IntPtr)">
            <summary>
            Called each time new audio data is needed to feed the stream
            </summary>
            <param name="dataChunk">Data chunk to fill with new audio samples</param>
            <param name="userData">User data -- unused</param>
            <returns>True to continue playback, false to stop</returns>
        </member>
        <member name="M:SFML.Audio.SoundStream.Seek(SFML.System.Time,System.IntPtr)">
            <summary>
            Called to seek in the stream
            </summary>
            <param name="timeOffset">New position</param>
            <param name="userData">User data -- unused</param>
            <returns>If false is returned, the playback is aborted</returns>
        </member>
        <member name="T:SFML.Graphics.BlendMode">
            <summary>
            Blending modes for drawing
            </summary>
        </member>
        <member name="T:SFML.Graphics.BlendMode.Factor">
            <summary>
            Enumeration of the blending factors
            </summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Factor.Zero">
            <summary>(0, 0, 0, 0)</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Factor.One">
            <summary>(1, 1, 1, 1)</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Factor.SrcColor">
            <summary>(src.r, src.g, src.b, src.a)</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Factor.OneMinusSrcColor">
            <summary>(1, 1, 1, 1) - (src.r, src.g, src.b, src.a)</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Factor.DstColor">
            <summary>(dst.r, dst.g, dst.b, dst.a)</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Factor.OneMinusDstColor">
            <summary>(1, 1, 1, 1) - (dst.r, dst.g, dst.b, dst.a)</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Factor.SrcAlpha">
            <summary>(src.a, src.a, src.a, src.a)</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Factor.OneMinusSrcAlpha">
            <summary>(1, 1, 1, 1) - (src.a, src.a, src.a, src.a)</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Factor.DstAlpha">
            <summary>(dst.a, dst.a, dst.a, dst.a)</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Factor.OneMinusDstAlpha">
            <summary>(1, 1, 1, 1) - (dst.a, dst.a, dst.a, dst.a)</summary>
        </member>
        <member name="T:SFML.Graphics.BlendMode.Equation">
            <summary>
            Enumeration of the blending equations
            </summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Equation.Add">
            <summary>Pixel = Src * SrcFactor + Dst * DstFactor</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Equation.Subtract">
            <summary>Pixel = Src * SrcFactor - Dst * DstFactor</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Equation.ReverseSubtract">
            <summary>Pixel = Dst * DstFactor - Src * SrcFactor</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Alpha">
            <summary>Blend source and dest according to dest alpha</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Add">
            <summary>Add source to dest</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.Multiply">
            <summary>Multiply source and dest</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.None">
            <summary>Overwrite dest with source</summary>
        </member>
        <member name="M:SFML.Graphics.BlendMode.#ctor(SFML.Graphics.BlendMode.Factor,SFML.Graphics.BlendMode.Factor)">
            <summary>
            Construct the blend mode given the factors and equation
            </summary>
            <param name="SourceFactor">Specifies how to compute the source factor for the color and alpha channels.</param>
            <param name="DestinationFactor">Specifies how to compute the destination factor for the color and alpha channels.</param>
        </member>
        <member name="M:SFML.Graphics.BlendMode.#ctor(SFML.Graphics.BlendMode.Factor,SFML.Graphics.BlendMode.Factor,SFML.Graphics.BlendMode.Equation)">
            <summary>
            Construct the blend mode given the factors and equation
            </summary>
            <param name="SourceFactor">Specifies how to compute the source factor for the color and alpha channels.</param>
            <param name="DestinationFactor">Specifies how to compute the destination factor for the color and alpha channels.</param>
            <param name="BlendEquation">Specifies how to combine the source and destination colors and alpha.</param>
        </member>
        <member name="M:SFML.Graphics.BlendMode.#ctor(SFML.Graphics.BlendMode.Factor,SFML.Graphics.BlendMode.Factor,SFML.Graphics.BlendMode.Equation,SFML.Graphics.BlendMode.Factor,SFML.Graphics.BlendMode.Factor,SFML.Graphics.BlendMode.Equation)">
            <summary>
            Construct the blend mode given the factors and equation
            </summary>
            <param name="ColorSourceFactor">Specifies how to compute the source factor for the color channels.</param>
            <param name="ColorDestinationFactor">Specifies how to compute the destination factor for the color channels.</param>
            <param name="ColorBlendEquation">Specifies how to combine the source and destination colors.</param>
            <param name="AlphaSourceFactor">Specifies how to compute the source factor.</param>
            <param name="AlphaDestinationFactor">Specifies how to compute the destination factor.</param>
            <param name="AlphaBlendEquation">Specifies how to combine the source and destination alphas.</param>
        </member>
        <member name="M:SFML.Graphics.BlendMode.op_Equality(SFML.Graphics.BlendMode,SFML.Graphics.BlendMode)">
            <summary>
            Compare two blend modes and checks if they are equal
            </summary>
            <returns>Blend Modes are equal</returns>
        </member>
        <member name="M:SFML.Graphics.BlendMode.op_Inequality(SFML.Graphics.BlendMode,SFML.Graphics.BlendMode)">
            <summary>
            Compare two blend modes and checks if they are not equal
            </summary>
            <returns>Blend Modes are not equal</returns>
        </member>
        <member name="M:SFML.Graphics.BlendMode.Equals(System.Object)">
            <summary>
            Compare blend mode and object and checks if they are equal
            </summary>
            <param name="obj">Object to check</param>
            <returns>Object and blend mode are equal</returns>
        </member>
        <member name="M:SFML.Graphics.BlendMode.Equals(SFML.Graphics.BlendMode)">
            <summary>
            Compare two blend modes and checks if they are equal
            </summary>
            <param name="other">Blend Mode to check</param>
            <returns>blend modes are equal</returns>
        </member>
        <member name="M:SFML.Graphics.BlendMode.GetHashCode">
            <summary>
            Provide a integer describing the object
            </summary>
            <returns>Integer description of the object</returns>
        </member>
        <member name="F:SFML.Graphics.BlendMode.ColorSrcFactor">
            <summary>Source blending factor for the color channels</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.ColorDstFactor">
            <summary>Destination blending factor for the color channels</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.ColorEquation">
            <summary>Blending equation for the color channels</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.AlphaSrcFactor">
            <summary>Source blending factor for the alpha channel</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.AlphaDstFactor">
            <summary>Destination blending factor for the alpha channel</summary>
        </member>
        <member name="F:SFML.Graphics.BlendMode.AlphaEquation">
            <summary>Blending equation for the alpha channel</summary>
        </member>
        <member name="T:SFML.Graphics.CircleShape">
            <summary>
            Specialized shape representing a circle
            </summary>
        </member>
        <member name="M:SFML.Graphics.CircleShape.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:SFML.Graphics.CircleShape.#ctor(System.Single)">
            <summary>
            Construct the shape with an initial radius
            </summary>
            <param name="radius">Radius of the shape</param>
        </member>
        <member name="M:SFML.Graphics.CircleShape.#ctor(System.Single,System.UInt32)">
            <summary>
            Construct the shape with an initial radius and point count
            </summary>
            <param name="radius">Radius of the shape</param>
            <param name="pointCount">Number of points of the shape</param>
        </member>
        <member name="M:SFML.Graphics.CircleShape.#ctor(SFML.Graphics.CircleShape)">
            <summary>
            Construct the shape from another shape
            </summary>
            <param name="copy">Shape to copy</param>
        </member>
        <member name="P:SFML.Graphics.CircleShape.Radius">
            <summary>
            The radius of the shape
            </summary>
        </member>
        <member name="M:SFML.Graphics.CircleShape.GetPointCount">
            <summary>
            Get the total number of points of the circle
            </summary>
            <returns>The total point count</returns>
        </member>
        <member name="M:SFML.Graphics.CircleShape.SetPointCount(System.UInt32)">
            <summary>
            Set the number of points of the circle.
            The count must be greater than 2 to define a valid shape.
            </summary>
            <param name="count">New number of points of the circle</param>
        </member>
        <member name="M:SFML.Graphics.CircleShape.GetPoint(System.UInt32)">
             <summary>
             Get the position of a point
            
             The returned point is in local coordinates, that is,
             the shape's transforms (position, rotation, scale) are
             not taken into account.
             The result is undefined if index is out of the valid range.
             </summary>
             <param name="index">Index of the point to get, in range [0 .. PointCount - 1]</param>
             <returns>index-th point of the shape</returns>
        </member>
        <member name="T:SFML.Graphics.Color">
            <summary>
            Utility class for manipulating 32-bits RGBA colors
            </summary>
        </member>
        <member name="M:SFML.Graphics.Color.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Construct the color from its red, green and blue components
            </summary>
            <param name="red">Red component</param>
            <param name="green">Green component</param>
            <param name="blue">Blue component</param>
        </member>
        <member name="M:SFML.Graphics.Color.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Construct the color from its red, green, blue and alpha components
            </summary>
            <param name="red">Red component</param>
            <param name="green">Green component</param>
            <param name="blue">Blue component</param>
            <param name="alpha">Alpha (transparency) component</param>
        </member>
        <member name="M:SFML.Graphics.Color.#ctor(System.UInt32)">
            <summary>
            Construct the color from 32-bit unsigned integer
            </summary>
            <param name="color">Number containing the RGBA components (in that order)</param>
        </member>
        <member name="M:SFML.Graphics.Color.#ctor(SFML.Graphics.Color)">
            <summary>
            Construct the color from another
            </summary>
            <param name="color">Color to copy</param>
        </member>
        <member name="M:SFML.Graphics.Color.ToInteger">
            <summary>
            Convert a color to a 32-bit unsigned integer
            </summary>
            <returns>Color represented as a 32-bit unsigned integer</returns>
        </member>
        <member name="M:SFML.Graphics.Color.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.Color.Equals(System.Object)">
            <summary>
            Compare color and object and checks if they are equal
            </summary>
            <param name="obj">Object to check</param>
            <returns>Object and color are equal</returns>
        </member>
        <member name="M:SFML.Graphics.Color.Equals(SFML.Graphics.Color)">
            <summary>
            Compare two colors and checks if they are equal
            </summary>
            <param name="other">Color to check</param>
            <returns>Colors are equal</returns>
        </member>
        <member name="M:SFML.Graphics.Color.GetHashCode">
            <summary>
            Provide a integer describing the object
            </summary>
            <returns>Integer description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.Color.op_Equality(SFML.Graphics.Color,SFML.Graphics.Color)">
            <summary>
            Compare two colors and checks if they are equal
            </summary>
            <returns>Colors are equal</returns>
        </member>
        <member name="M:SFML.Graphics.Color.op_Inequality(SFML.Graphics.Color,SFML.Graphics.Color)">
            <summary>
            Compare two colors and checks if they are not equal
            </summary>
            <returns>Colors are not equal</returns>
        </member>
        <member name="M:SFML.Graphics.Color.op_Addition(SFML.Graphics.Color,SFML.Graphics.Color)">
            <summary>
            This operator returns the component-wise sum of two colors.
            Components that exceed 255 are clamped to 255.
            </summary>
            <returns>Result of left + right</returns>
        </member>
        <member name="M:SFML.Graphics.Color.op_Subtraction(SFML.Graphics.Color,SFML.Graphics.Color)">
            <summary>
            This operator returns the component-wise subtraction of two colors.
            Components below 0 are clamped to 0.
            </summary>
            <returns>Result of left - right</returns>
        </member>
        <member name="M:SFML.Graphics.Color.op_Multiply(SFML.Graphics.Color,SFML.Graphics.Color)">
            <summary>
            This operator returns the component-wise multiplication of two colors.
            Components above 255 are clamped to 255.
            </summary>
            <returns>Result of left * right</returns>
        </member>
        <member name="F:SFML.Graphics.Color.R">
            <summary>Red component of the color</summary>
        </member>
        <member name="F:SFML.Graphics.Color.G">
            <summary>Green component of the color</summary>
        </member>
        <member name="F:SFML.Graphics.Color.B">
            <summary>Blue component of the color</summary>
        </member>
        <member name="F:SFML.Graphics.Color.A">
            <summary>Alpha (transparent) component of the color</summary>
        </member>
        <member name="F:SFML.Graphics.Color.Black">
            <summary>Predefined black color</summary>
        </member>
        <member name="F:SFML.Graphics.Color.White">
            <summary>Predefined white color</summary>
        </member>
        <member name="F:SFML.Graphics.Color.Red">
            <summary>Predefined red color</summary>
        </member>
        <member name="F:SFML.Graphics.Color.Green">
            <summary>Predefined green color</summary>
        </member>
        <member name="F:SFML.Graphics.Color.Blue">
            <summary>Predefined blue color</summary>
        </member>
        <member name="F:SFML.Graphics.Color.Yellow">
            <summary>Predefined yellow color</summary>
        </member>
        <member name="F:SFML.Graphics.Color.Magenta">
            <summary>Predefined magenta color</summary>
        </member>
        <member name="F:SFML.Graphics.Color.Cyan">
            <summary>Predefined cyan color</summary>
        </member>
        <member name="F:SFML.Graphics.Color.Transparent">
            <summary>Predefined (black) transparent color</summary>
        </member>
        <member name="T:SFML.Graphics.ConvexShape">
            <summary>
            Specialized shape representing a convex polygon
            </summary>
        </member>
        <member name="M:SFML.Graphics.ConvexShape.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:SFML.Graphics.ConvexShape.#ctor(System.UInt32)">
            <summary>
            Construct the shape with an initial point count
            </summary>
            <param name="pointCount">Number of points of the shape</param>
        </member>
        <member name="M:SFML.Graphics.ConvexShape.#ctor(SFML.Graphics.ConvexShape)">
            <summary>
            Construct the shape from another shape
            </summary>
            <param name="copy">Shape to copy</param>
        </member>
        <member name="M:SFML.Graphics.ConvexShape.GetPointCount">
            <summary>
            Get the total number of points of the polygon
            </summary>
            <returns>The total point count</returns>
        </member>
        <member name="M:SFML.Graphics.ConvexShape.SetPointCount(System.UInt32)">
            <summary>
            Set the number of points of the polygon.
            The count must be greater than 2 to define a valid shape.
            </summary>
            <param name="count">New number of points of the polygon</param>
        </member>
        <member name="M:SFML.Graphics.ConvexShape.GetPoint(System.UInt32)">
             <summary>
             Get the position of a point
            
             The returned point is in local coordinates, that is,
             the shape's transforms (position, rotation, scale) are
             not taken into account.
             The result is undefined if index is out of the valid range.
             </summary>
             <param name="index">Index of the point to get, in range [0 .. PointCount - 1]</param>
             <returns>index-th point of the shape</returns>
        </member>
        <member name="M:SFML.Graphics.ConvexShape.SetPoint(System.UInt32,SFML.System.Vector2f)">
             <summary>
             Set the position of a point.
            
             Don't forget that the polygon must remain convex, and
             the points need to stay ordered!
             PointCount must be set first in order to set the total
             number of points. The result is undefined if index is out
             of the valid range.
             </summary>
             <param name="index">Index of the point to change, in range [0 .. PointCount - 1]</param>
             <param name="point">New position of the point</param>
        </member>
        <member name="T:SFML.Graphics.Drawable">
            <summary>
            Interface for every object that can be drawn to a render window
            </summary>
        </member>
        <member name="M:SFML.Graphics.Drawable.Draw(SFML.Graphics.RenderTarget,SFML.Graphics.RenderStates)">
             <summary>
             Draw the object to a render target
            
             This is a function that has to be implemented by the
             derived class to define how the drawable should be drawn.
             </summary>
             <param name="target">Render target to draw to</param>
             <param name="states">Current render states</param>
        </member>
        <member name="T:SFML.Graphics.Font">
            <summary>
            Font is the low-level class for loading and
            manipulating character fonts. This class is meant to
            be used by String2D
            </summary>
        </member>
        <member name="M:SFML.Graphics.Font.#ctor(System.String)">
            <summary>
            Construct the font from a file
            </summary>
            <param name="filename">Font file to load</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Font.#ctor(System.IO.Stream)">
            <summary>
            Construct the font from a custom stream
            </summary>
            <param name="stream">Source stream to read from</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Font.#ctor(System.Byte[])">
            <summary>
            Construct the font from a file in memory
            </summary>
            <param name="bytes">Byte array containing the file contents</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Font.#ctor(SFML.Graphics.Font)">
            <summary>
            Construct the font from another font
            </summary>
            <param name="copy">Font to copy</param>
        </member>
        <member name="M:SFML.Graphics.Font.GetGlyph(System.UInt32,System.UInt32,System.Boolean,System.Single)">
            <summary>
            Get a glyph in the font
            </summary>
            <param name="codePoint">Unicode code point of the character to get</param>
            <param name="characterSize">Character size</param>
            <param name="bold">Retrieve the bold version or the regular one?</param>
            <param name="outlineThickness">Thickness of outline (when != 0 the glyph will not be filled)</param>
            <returns>The glyph corresponding to the character</returns>
        </member>
        <member name="M:SFML.Graphics.Font.GetKerning(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Get the kerning offset between two glyphs
            </summary>
            <param name="first">Unicode code point of the first character</param>
            <param name="second">Unicode code point of the second character</param>
            <param name="characterSize">Character size</param>
            <returns>Kerning offset, in pixels</returns>
        </member>
        <member name="M:SFML.Graphics.Font.GetLineSpacing(System.UInt32)">
            <summary>
            Get spacing between two consecutive lines
            </summary>
            <param name="characterSize">Character size</param>
            <returns>Line spacing, in pixels</returns>
        </member>
        <member name="M:SFML.Graphics.Font.GetUnderlinePosition(System.UInt32)">
            <summary>
            Get the position of the underline
            </summary>
            <param name="characterSize">Character size</param>
            <returns>Underline position, in pixels</returns>
        </member>
        <member name="M:SFML.Graphics.Font.GetUnderlineThickness(System.UInt32)">
            <summary>
            Get the thickness of the underline
            </summary>
            <param name="characterSize">Character size</param>
            <returns>Underline thickness, in pixels</returns>
        </member>
        <member name="M:SFML.Graphics.Font.GetTexture(System.UInt32)">
            <summary>
            Get the texture containing the glyphs of a given size
            </summary>
            <param name="characterSize">Character size</param>
            <returns>Texture storing the glyphs for the given size</returns>
        </member>
        <member name="M:SFML.Graphics.Font.GetInfo">
            <summary>
            Get the font information
            </summary>
            <returns>A structure that holds the font information</returns>
        </member>
        <member name="M:SFML.Graphics.Font.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.Font.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call?</param>
        </member>
        <member name="M:SFML.Graphics.Font.#ctor(System.IntPtr)">
            <summary>
            Internal constructor
            </summary>
            <param name="cPointer">Pointer to the object in C library</param>
        </member>
        <member name="T:SFML.Graphics.Font.Info">
            <summary>
            Info holds various information about a font
            </summary>
        </member>
        <member name="F:SFML.Graphics.Font.Info.Family">
            <summary>The font family</summary>
        </member>
        <member name="T:SFML.Graphics.Font.InfoMarshalData">
            <summary>
            Internal struct used for marshaling the font info
            struct from unmanaged code.
            </summary>
        </member>
        <member name="T:SFML.Graphics.Glsl.Vec2">
            <summary>
            <see cref="T:SFML.Graphics.Glsl.Vec2"/> is a struct represent a glsl vec2 value
            </summary>
        </member>
        <member name="M:SFML.Graphics.Glsl.Vec2.op_Implicit(SFML.System.Vector2f)~SFML.Graphics.Glsl.Vec2">
            <summary>
            Implicit cast from <see cref="T:SFML.System.Vector2f"/> to <see cref="T:SFML.Graphics.Glsl.Vec2"/>
            </summary>
        </member>
        <member name="M:SFML.Graphics.Glsl.Vec2.#ctor(System.Single,System.Single)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Vec2"/> from its coordinates
            </summary>
            <param name="x">X coordinate</param>
            <param name="y">Y coordinate</param>
        </member>
        <member name="M:SFML.Graphics.Glsl.Vec2.#ctor(SFML.System.Vector2f)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Vec2"/> from a standard SFML <see cref="T:SFML.System.Vector2f"/>
            </summary>
            <param name="vec">A standard SFML 2D vector</param>
        </member>
        <member name="F:SFML.Graphics.Glsl.Vec2.X">
            <summary>Horizontal component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Vec2.Y">
            <summary>Vertical component of the vector</summary>
        </member>
        <member name="T:SFML.Graphics.Glsl.Ivec2">
            <summary>
            <see cref="T:SFML.Graphics.Glsl.Ivec2"/> is a struct represent a glsl ivec2 value
            </summary>
        </member>
        <member name="M:SFML.Graphics.Glsl.Ivec2.op_Implicit(SFML.System.Vector2i)~SFML.Graphics.Glsl.Ivec2">
            <summary>
            Implicit cast from <see cref="T:SFML.System.Vector2i"/> to <see cref="T:SFML.Graphics.Glsl.Ivec2"/>
            </summary>
        </member>
        <member name="M:SFML.Graphics.Glsl.Ivec2.#ctor(System.Int32,System.Int32)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Ivec2"/> from its coordinates
            </summary>
            <param name="x">X coordinate</param>
            <param name="y">Y coordinate</param>
        </member>
        <member name="M:SFML.Graphics.Glsl.Ivec2.#ctor(SFML.System.Vector2i)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Ivec2"/> from a standard SFML <see cref="T:SFML.System.Vector2i"/>
            </summary>
            <param name="vec">A standard SFML 2D integer vector</param>
        </member>
        <member name="F:SFML.Graphics.Glsl.Ivec2.X">
            <summary>Horizontal component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Ivec2.Y">
            <summary>Vertical component of the vector</summary>
        </member>
        <member name="T:SFML.Graphics.Glsl.Bvec2">
            <summary>
            <see cref="T:SFML.Graphics.Glsl.Bvec2"/> is a struct represent a glsl bvec2 value
            </summary>
        </member>
        <member name="M:SFML.Graphics.Glsl.Bvec2.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Bvec2"/> from its coordinates
            </summary>
            <param name="x">X coordinate</param>
            <param name="y">Y coordinate</param>
        </member>
        <member name="F:SFML.Graphics.Glsl.Bvec2.X">
            <summary>Horizontal component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Bvec2.Y">
            <summary>Vertical component of the vector</summary>
        </member>
        <member name="T:SFML.Graphics.Glsl.Vec3">
            <summary>
            <see cref="T:SFML.Graphics.Glsl.Vec3"/> is a struct represent a glsl vec3 value
            </summary>
        </member>
        <member name="M:SFML.Graphics.Glsl.Vec3.op_Implicit(SFML.System.Vector3f)~SFML.Graphics.Glsl.Vec3">
            <summary>
            Implicit cast from <see cref="T:SFML.System.Vector3f"/> to <see cref="T:SFML.Graphics.Glsl.Vec3"/>
            </summary>
        </member>
        <member name="M:SFML.Graphics.Glsl.Vec3.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Vec3"/> from its coordinates
            </summary>
            <param name="x">X coordinate</param>
            <param name="y">Y coordinate</param>
            <param name="z">Z coordinate</param>
        </member>
        <member name="M:SFML.Graphics.Glsl.Vec3.#ctor(SFML.System.Vector3f)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Vec3"/> from a standard SFML <see cref="T:SFML.System.Vector3f"/>
            </summary>
            <param name="vec">A standard SFML 3D vector</param>
        </member>
        <member name="F:SFML.Graphics.Glsl.Vec3.X">
            <summary>Horizontal component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Vec3.Y">
            <summary>Vertical component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Vec3.Z">
            <summary>Depth component of the vector</summary>
        </member>
        <member name="T:SFML.Graphics.Glsl.Ivec3">
            <summary>
            <see cref="T:SFML.Graphics.Glsl.Ivec3"/> is a struct represent a glsl ivec3 value
            </summary>
        </member>
        <member name="M:SFML.Graphics.Glsl.Ivec3.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Ivec3"/> from its coordinates
            </summary>
            <param name="x">X coordinate</param>
            <param name="y">Y coordinate</param>
            <param name="z">Z coordinate</param>
        </member>
        <member name="F:SFML.Graphics.Glsl.Ivec3.X">
            <summary>Horizontal component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Ivec3.Y">
            <summary>Vertical component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Ivec3.Z">
            <summary>Depth component of the vector</summary>
        </member>
        <member name="T:SFML.Graphics.Glsl.Bvec3">
            <summary>
            <see cref="T:SFML.Graphics.Glsl.Bvec3"/> is a struct represent a glsl bvec3 value
            </summary>
        </member>
        <member name="M:SFML.Graphics.Glsl.Bvec3.#ctor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Bvec3"/> from its coordinates
            </summary>
            <param name="x">X coordinate</param>
            <param name="y">Y coordinate</param>
            <param name="z">Z coordinate</param>
        </member>
        <member name="F:SFML.Graphics.Glsl.Bvec3.X">
            <summary>Horizontal component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Bvec3.Y">
            <summary>Vertical component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Bvec3.Z">
            <summary>Depth component of the vector</summary>
        </member>
        <member name="T:SFML.Graphics.Glsl.Vec4">
            <summary>
            <see cref="T:SFML.Graphics.Glsl.Vec4"/> is a struct represent a glsl vec4 value
            </summary>
        </member>
        <member name="M:SFML.Graphics.Glsl.Vec4.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Vec4"/> from its coordinates
            </summary>
            <param name="x">X coordinate</param>
            <param name="y">Y coordinate</param>
            <param name="z">Z coordinate</param>
            <param name="w">W coordinate</param>
        </member>
        <member name="M:SFML.Graphics.Glsl.Vec4.#ctor(SFML.Graphics.Color)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Vec4"/> from a <see cref="T:SFML.Graphics.Color"/>
            </summary>
            <remarks>
            The <see cref="T:SFML.Graphics.Color"/>'s values will be normalized from 0..255 to 0..1
            </remarks>
            <param name="color">A SFML <see cref="T:SFML.Graphics.Color"/> to be translated to a 4D floating-point vector</param>
        </member>
        <member name="F:SFML.Graphics.Glsl.Vec4.X">
            <summary>Horizontal component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Vec4.Y">
            <summary>Vertical component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Vec4.Z">
            <summary>Depth component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Vec4.W">
            <summary>Projective/Homogenous component of the vector</summary>
        </member>
        <member name="T:SFML.Graphics.Glsl.Ivec4">
            <summary>
            <see cref="T:SFML.Graphics.Glsl.Ivec4"/> is a struct represent a glsl ivec4 value
            </summary>
        </member>
        <member name="M:SFML.Graphics.Glsl.Ivec4.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Ivec4"/> from its coordinates
            </summary>
            <param name="x">X coordinate</param>
            <param name="y">Y coordinate</param>
            <param name="z">Z coordinate</param>
            <param name="w">W coordinate</param>
        </member>
        <member name="M:SFML.Graphics.Glsl.Ivec4.#ctor(SFML.Graphics.Color)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Ivec4"/> from a <see cref="T:SFML.Graphics.Color"/>
            </summary>
            <param name="color">A SFML <see cref="T:SFML.Graphics.Color"/> to be translated to a 4D integer vector</param>
        </member>
        <member name="F:SFML.Graphics.Glsl.Ivec4.X">
            <summary>Horizontal component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Ivec4.Y">
            <summary>Vertical component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Ivec4.Z">
            <summary>Depth component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Ivec4.W">
            <summary>Projective/Homogenous component of the vector</summary>
        </member>
        <member name="T:SFML.Graphics.Glsl.Bvec4">
            <summary>
            <see cref="T:SFML.Graphics.Glsl.Bvec4"/> is a struct represent a glsl bvec4 value
            </summary>
        </member>
        <member name="M:SFML.Graphics.Glsl.Bvec4.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Bvec4"/> from its coordinates
            </summary>
            <param name="x">X coordinate</param>
            <param name="y">Y coordinate</param>
            <param name="z">Z coordinate</param>
            <param name="w">W coordinate</param>
        </member>
        <member name="F:SFML.Graphics.Glsl.Bvec4.X">
            <summary>Horizontal component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Bvec4.Y">
            <summary>Vertical component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Bvec4.Z">
            <summary>Depth component of the vector</summary>
        </member>
        <member name="F:SFML.Graphics.Glsl.Bvec4.W">
            <summary>Projective/Homogenous component of the vector</summary>
        </member>
        <member name="T:SFML.Graphics.Glsl.Mat3">
            <summary>
            <see cref="T:SFML.Graphics.Glsl.Mat3"/> is a struct representing a glsl mat3 value
            </summary>
        </member>
        <member name="M:SFML.Graphics.Glsl.Mat3.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
             <summary>
             Construct the <see cref="T:SFML.Graphics.Glsl.Mat3"/> from its components
             </summary>
            
             <remarks>
             Arguments are in row-major order
             </remarks>
        </member>
        <member name="M:SFML.Graphics.Glsl.Mat3.#ctor(SFML.Graphics.Transform)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Mat3"/> from a SFML <see cref="T:SFML.Graphics.Transform"/>
            </summary>
            <param name="transform">A SFML <see cref="T:SFML.Graphics.Transform"/></param>
        </member>
        <member name="T:SFML.Graphics.Glsl.Mat4">
            <summary>
            <see cref="T:SFML.Graphics.Glsl.Mat4"/> is a struct representing a glsl mat4 value
            </summary>
        </member>
        <member name="P:SFML.Graphics.Glsl.Mat4.Identity">
             <summary>
             Provides easy-access to an identity matrix
             </summary>
            
             <remarks>
             Keep in mind that a Mat4 cannot be modified after construction
             </remarks>
        </member>
        <member name="M:SFML.Graphics.Glsl.Mat4.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
             <summary>
             Construct the <see cref="T:SFML.Graphics.Glsl.Mat4"/> from its components
             </summary>
            
             <remarks>
             Arguments are in row-major order
             </remarks>
        </member>
        <member name="M:SFML.Graphics.Glsl.Mat4.#ctor(SFML.Graphics.Transform)">
            <summary>
            Construct the <see cref="T:SFML.Graphics.Glsl.Mat3"/> from a SFML <see cref="T:SFML.Graphics.Transform"/> and expand it to a 4x4 matrix
            </summary>
            <param name="transform">A SFML <see cref="T:SFML.Graphics.Transform"/></param>
        </member>
        <member name="T:SFML.Graphics.Glyph">
            <summary>
            Structure describing a glyph (a visual character)
            </summary>
        </member>
        <member name="F:SFML.Graphics.Glyph.Advance">
            <summary>Offset to move horizontally to the next character</summary>
        </member>
        <member name="F:SFML.Graphics.Glyph.Bounds">
            <summary>Bounding rectangle of the glyph, in coordinates relative to the baseline</summary>
        </member>
        <member name="F:SFML.Graphics.Glyph.TextureRect">
            <summary>Texture coordinates of the glyph inside the font's texture</summary>
        </member>
        <member name="T:SFML.Graphics.Image">
            <summary>
            Image is the low-level class for loading and
            manipulating images
            </summary>
        </member>
        <member name="M:SFML.Graphics.Image.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Construct the image with black color
            </summary>
            <param name="width">Image width</param>
            <param name="height">Image height</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Image.#ctor(System.UInt32,System.UInt32,SFML.Graphics.Color)">
            <summary>
            Construct the image from a single color
            </summary>
            <param name="width">Image width</param>
            <param name="height">Image height</param>
            <param name="color">Color to fill the image with</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Image.#ctor(System.String)">
            <summary>
            Construct the image from a file
            </summary>
            <param name="filename">Path of the image file to load</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Image.#ctor(System.IO.Stream)">
            <summary>
            Construct the image from a file in a stream
            </summary>
            <param name="stream">Stream containing the file contents</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Image.#ctor(System.Byte[])">
            <summary>
            Construct the image from a file in memory
            </summary>
            <param name="bytes">Byte array containing the file contents</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Image.#ctor(SFML.Graphics.Color[0:,0:])">
            <summary>
            Construct the image directly from an array of pixels
            </summary>
            <param name="pixels">2 dimensions array containing the pixels</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Image.#ctor(System.UInt32,System.UInt32,System.Byte[])">
            <summary>
            Construct the image directly from an array of pixels
            </summary>
            <param name="width">Image width</param>
            <param name="height">Image height</param>
            <param name="pixels">array containing the pixels</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Image.#ctor(SFML.Graphics.Image)">
            <summary>
            Construct the image from another image
            </summary>
            <param name="copy">Image to copy</param>
        </member>
        <member name="M:SFML.Graphics.Image.SaveToFile(System.String)">
            <summary>
            Save the contents of the image to a file
            </summary>
            <param name="filename">Path of the file to save (overwritten if already exist)</param>
            <returns>True if saving was successful</returns>
        </member>
        <member name="M:SFML.Graphics.Image.CreateMaskFromColor(SFML.Graphics.Color)">
            <summary>
            Create a transparency mask from a specified colorkey
            </summary>
            <param name="color">Color to become transparent</param>
        </member>
        <member name="M:SFML.Graphics.Image.CreateMaskFromColor(SFML.Graphics.Color,System.Byte)">
            <summary>
            Create a transparency mask from a specified colorkey
            </summary>
            <param name="color">Color to become transparent</param>
            <param name="alpha">Alpha value to use for transparent pixels</param>
        </member>
        <member name="M:SFML.Graphics.Image.Copy(SFML.Graphics.Image,System.UInt32,System.UInt32)">
            <summary>
            Copy pixels from another image onto this one.
            This function does a slow pixel copy and should only
            be used at initialization time
            </summary>
            <param name="source">Source image to copy</param>
            <param name="destX">X coordinate of the destination position</param>
            <param name="destY">Y coordinate of the destination position</param>
        </member>
        <member name="M:SFML.Graphics.Image.Copy(SFML.Graphics.Image,System.UInt32,System.UInt32,SFML.Graphics.IntRect)">
            <summary>
            Copy pixels from another image onto this one.
            This function does a slow pixel copy and should only
            be used at initialization time
            </summary>
            <param name="source">Source image to copy</param>
            <param name="destX">X coordinate of the destination position</param>
            <param name="destY">Y coordinate of the destination position</param>
            <param name="sourceRect">Sub-rectangle of the source image to copy</param>
        </member>
        <member name="M:SFML.Graphics.Image.Copy(SFML.Graphics.Image,System.UInt32,System.UInt32,SFML.Graphics.IntRect,System.Boolean)">
            <summary>
            Copy pixels from another image onto this one.
            This function does a slow pixel copy and should only
            be used at initialization time
            </summary>
            <param name="source">Source image to copy</param>
            <param name="destX">X coordinate of the destination position</param>
            <param name="destY">Y coordinate of the destination position</param>
            <param name="sourceRect">Sub-rectangle of the source image to copy</param>
            <param name="applyAlpha">Should the copy take in account the source transparency?</param>
        </member>
        <member name="M:SFML.Graphics.Image.GetPixel(System.UInt32,System.UInt32)">
            <summary>
            Get a pixel from the image
            </summary>
            <param name="x">X coordinate of pixel in the image</param>
            <param name="y">Y coordinate of pixel in the image</param>
            <returns>Color of pixel (x, y)</returns>
        </member>
        <member name="M:SFML.Graphics.Image.SetPixel(System.UInt32,System.UInt32,SFML.Graphics.Color)">
            <summary>
            Change the color of a pixel
            </summary>
            <param name="x">X coordinate of pixel in the image</param>
            <param name="y">Y coordinate of pixel in the image</param>
            <param name="color">New color for pixel (x, y)</param>
        </member>
        <member name="P:SFML.Graphics.Image.Pixels">
            <summary>
            Get a copy of the array of pixels (RGBA 8 bits integers components)
            Array size is Width x Height x 4
            </summary>
            <returns>Array of pixels</returns>
        </member>
        <member name="P:SFML.Graphics.Image.Size">
            <summary>
            Size of the image, in pixels
            </summary>
        </member>
        <member name="M:SFML.Graphics.Image.FlipHorizontally">
            <summary>
            Flip the image horizontally
            </summary>
        </member>
        <member name="M:SFML.Graphics.Image.FlipVertically">
            <summary>
            Flip the image vertically
            </summary>
        </member>
        <member name="M:SFML.Graphics.Image.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.Image.#ctor(System.IntPtr)">
            <summary>
            Internal constructor
            </summary>
            <param name="cPointer">Pointer to the object in C library</param>
        </member>
        <member name="M:SFML.Graphics.Image.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="T:SFML.Graphics.PrimitiveType">
             <summary>
             Types of primitives that a VertexArray can render.
            
             Points and lines have no area, therefore their thickness
             will always be 1 pixel, regardless the current transform
             and view.
             </summary>
        </member>
        <member name="F:SFML.Graphics.PrimitiveType.Points">
            List of individual points
        </member>
        <member name="F:SFML.Graphics.PrimitiveType.Lines">
            List of individual lines
        </member>
        <member name="F:SFML.Graphics.PrimitiveType.LineStrip">
            List of connected lines, a point uses the previous point to form a line
        </member>
        <member name="F:SFML.Graphics.PrimitiveType.Triangles">
            List of individual triangles
        </member>
        <member name="F:SFML.Graphics.PrimitiveType.TriangleStrip">
            List of connected triangles, a point uses the two previous points to form a triangle
        </member>
        <member name="F:SFML.Graphics.PrimitiveType.TriangleFan">
            List of connected triangles, a point uses the common center and the previous point to form a triangle
        </member>
        <member name="F:SFML.Graphics.PrimitiveType.Quads">
            List of individual quads
        </member>
        <member name="F:SFML.Graphics.PrimitiveType.LinesStrip">
            List of connected lines, a point uses the previous point to form a line
        </member>
        <member name="F:SFML.Graphics.PrimitiveType.TrianglesStrip">
            List of connected triangles, a point uses the two previous points to form a triangle
        </member>
        <member name="F:SFML.Graphics.PrimitiveType.TrianglesFan">
            List of connected triangles, a point uses the common center and the previous point to form a triangle
        </member>
        <member name="T:SFML.Graphics.IntRect">
            <summary>
            IntRect is an utility class for manipulating 2D rectangles
            with integer coordinates
            </summary>
        </member>
        <member name="M:SFML.Graphics.IntRect.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Construct the rectangle from its coordinates
            </summary>
            <param name="left">Left coordinate of the rectangle</param>
            <param name="top">Top coordinate of the rectangle</param>
            <param name="width">Width of the rectangle</param>
            <param name="height">Height of the rectangle</param>
        </member>
        <member name="M:SFML.Graphics.IntRect.#ctor(SFML.System.Vector2i,SFML.System.Vector2i)">
            <summary>
            Construct the rectangle from position and size
            </summary>
            <param name="position">Position of the top-left corner of the rectangle</param>
            <param name="size">Size of the rectangle</param>
        </member>
        <member name="M:SFML.Graphics.IntRect.Contains(System.Int32,System.Int32)">
            <summary>
            Check if a point is inside the rectangle's area
            </summary>
            <param name="x">X coordinate of the point to test</param>
            <param name="y">Y coordinate of the point to test</param>
            <returns>True if the point is inside</returns>
        </member>
        <member name="M:SFML.Graphics.IntRect.Intersects(SFML.Graphics.IntRect)">
            <summary>
            Check intersection between two rectangles
            </summary>
            <param name="rect"> Rectangle to test</param>
            <returns>True if rectangles overlap</returns>
        </member>
        <member name="M:SFML.Graphics.IntRect.Intersects(SFML.Graphics.IntRect,SFML.Graphics.IntRect@)">
            <summary>
            Check intersection between two rectangles
            </summary>
            <param name="rect"> Rectangle to test</param>
            <param name="overlap">Rectangle to be filled with overlapping rect</param>
            <returns>True if rectangles overlap</returns>
        </member>
        <member name="M:SFML.Graphics.IntRect.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.IntRect.Equals(System.Object)">
            <summary>
            Compare rectangle and object and checks if they are equal
            </summary>
            <param name="obj">Object to check</param>
            <returns>Object and rectangle are equal</returns>
        </member>
        <member name="M:SFML.Graphics.IntRect.Equals(SFML.Graphics.IntRect)">
            <summary>
            Compare two rectangles and checks if they are equal
            </summary>
            <param name="other">Rectangle to check</param>
            <returns>Rectangles are equal</returns>
        </member>
        <member name="M:SFML.Graphics.IntRect.GetHashCode">
            <summary>
            Provide a integer describing the object
            </summary>
            <returns>Integer description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.IntRect.op_Equality(SFML.Graphics.IntRect,SFML.Graphics.IntRect)">
            <summary>
            Operator == overload ; check rect equality
            </summary>
            <param name="r1">First rect</param>
            <param name="r2">Second rect</param>
            <returns>r1 == r2</returns>
        </member>
        <member name="M:SFML.Graphics.IntRect.op_Inequality(SFML.Graphics.IntRect,SFML.Graphics.IntRect)">
            <summary>
            Operator != overload ; check rect inequality
            </summary>
            <param name="r1">First rect</param>
            <param name="r2">Second rect</param>
            <returns>r1 != r2</returns>
        </member>
        <member name="M:SFML.Graphics.IntRect.op_Explicit(SFML.Graphics.IntRect)~SFML.Graphics.FloatRect">
            <summary>
            Explicit casting to another rectangle type
            </summary>
            <param name="r">Rectangle being casted</param>
            <returns>Casting result</returns>
        </member>
        <member name="F:SFML.Graphics.IntRect.Left">
            <summary>Left coordinate of the rectangle</summary>
        </member>
        <member name="F:SFML.Graphics.IntRect.Top">
            <summary>Top coordinate of the rectangle</summary>
        </member>
        <member name="F:SFML.Graphics.IntRect.Width">
            <summary>Width of the rectangle</summary>
        </member>
        <member name="F:SFML.Graphics.IntRect.Height">
            <summary>Height of the rectangle</summary>
        </member>
        <member name="T:SFML.Graphics.FloatRect">
            <summary>
            IntRect is an utility class for manipulating 2D rectangles
            with float coordinates
            </summary>
        </member>
        <member name="M:SFML.Graphics.FloatRect.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Construct the rectangle from its coordinates
            </summary>
            <param name="left">Left coordinate of the rectangle</param>
            <param name="top">Top coordinate of the rectangle</param>
            <param name="width">Width of the rectangle</param>
            <param name="height">Height of the rectangle</param>
        </member>
        <member name="M:SFML.Graphics.FloatRect.#ctor(SFML.System.Vector2f,SFML.System.Vector2f)">
            <summary>
            Construct the rectangle from position and size
            </summary>
            <param name="position">Position of the top-left corner of the rectangle</param>
            <param name="size">Size of the rectangle</param>
        </member>
        <member name="M:SFML.Graphics.FloatRect.Contains(System.Single,System.Single)">
            <summary>
            Check if a point is inside the rectangle's area
            </summary>
            <param name="x">X coordinate of the point to test</param>
            <param name="y">Y coordinate of the point to test</param>
            <returns>True if the point is inside</returns>
        </member>
        <member name="M:SFML.Graphics.FloatRect.Intersects(SFML.Graphics.FloatRect)">
            <summary>
            Check intersection between two rectangles
            </summary>
            <param name="rect"> Rectangle to test</param>
            <returns>True if rectangles overlap</returns>
        </member>
        <member name="M:SFML.Graphics.FloatRect.Intersects(SFML.Graphics.FloatRect,SFML.Graphics.FloatRect@)">
            <summary>
            Check intersection between two rectangles
            </summary>
            <param name="rect"> Rectangle to test</param>
            <param name="overlap">Rectangle to be filled with overlapping rect</param>
            <returns>True if rectangles overlap</returns>
        </member>
        <member name="M:SFML.Graphics.FloatRect.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.FloatRect.Equals(System.Object)">
            <summary>
            Compare rectangle and object and checks if they are equal
            </summary>
            <param name="obj">Object to check</param>
            <returns>Object and rectangle are equal</returns>
        </member>
        <member name="M:SFML.Graphics.FloatRect.Equals(SFML.Graphics.FloatRect)">
            <summary>
            Compare two rectangles and checks if they are equal
            </summary>
            <param name="other">Rectangle to check</param>
            <returns>Rectangles are equal</returns>
        </member>
        <member name="M:SFML.Graphics.FloatRect.GetHashCode">
            <summary>
            Provide a integer describing the object
            </summary>
            <returns>Integer description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.FloatRect.op_Equality(SFML.Graphics.FloatRect,SFML.Graphics.FloatRect)">
            <summary>
            Operator == overload ; check rect equality
            </summary>
            <param name="r1">First rect</param>
            <param name="r2">Second rect</param>
            <returns>r1 == r2</returns>
        </member>
        <member name="M:SFML.Graphics.FloatRect.op_Inequality(SFML.Graphics.FloatRect,SFML.Graphics.FloatRect)">
            <summary>
            Operator != overload ; check rect inequality
            </summary>
            <param name="r1">First rect</param>
            <param name="r2">Second rect</param>
            <returns>r1 != r2</returns>
        </member>
        <member name="M:SFML.Graphics.FloatRect.op_Explicit(SFML.Graphics.FloatRect)~SFML.Graphics.IntRect">
            <summary>
            Explicit casting to another rectangle type
            </summary>
            <param name="r">Rectangle being casted</param>
            <returns>Casting result</returns>
        </member>
        <member name="F:SFML.Graphics.FloatRect.Left">
            <summary>Left coordinate of the rectangle</summary>
        </member>
        <member name="F:SFML.Graphics.FloatRect.Top">
            <summary>Top coordinate of the rectangle</summary>
        </member>
        <member name="F:SFML.Graphics.FloatRect.Width">
            <summary>Width of the rectangle</summary>
        </member>
        <member name="F:SFML.Graphics.FloatRect.Height">
            <summary>Height of the rectangle</summary>
        </member>
        <member name="T:SFML.Graphics.RectangleShape">
            <summary>
            Specialized shape representing a rectangle
            </summary>
        </member>
        <member name="M:SFML.Graphics.RectangleShape.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:SFML.Graphics.RectangleShape.#ctor(SFML.System.Vector2f)">
            <summary>
            Construct the shape with an initial size
            </summary>
            <param name="size">Size of the shape</param>
        </member>
        <member name="M:SFML.Graphics.RectangleShape.#ctor(SFML.Graphics.RectangleShape)">
            <summary>
            Construct the shape from another shape
            </summary>
            <param name="copy">Shape to copy</param>
        </member>
        <member name="P:SFML.Graphics.RectangleShape.Size">
            <summary>
            The size of the rectangle
            </summary>
        </member>
        <member name="M:SFML.Graphics.RectangleShape.GetPointCount">
            <summary>
            Get the total number of points of the rectangle.
            </summary>
            <returns>The total point count. For rectangle shapes,
            this number is always 4.</returns>
        </member>
        <member name="M:SFML.Graphics.RectangleShape.GetPoint(System.UInt32)">
             <summary>
             Get the position of a point
            
             The returned point is in local coordinates, that is,
             the shape's transforms (position, rotation, scale) are
             not taken into account.
             The result is undefined if index is out of the valid range.
             </summary>
             <param name="index">Index of the point to get, in range [0 .. 3]</param>
             <returns>index-th point of the shape</returns>
        </member>
        <member name="T:SFML.Graphics.RenderStates">
            <summary>
            Define the states used for drawing to a RenderTarget
            </summary>
        </member>
        <member name="M:SFML.Graphics.RenderStates.#ctor(SFML.Graphics.BlendMode)">
            <summary>
            Construct a default set of render states with a custom blend mode
            </summary>
            <param name="blendMode">Blend mode to use</param>
        </member>
        <member name="M:SFML.Graphics.RenderStates.#ctor(SFML.Graphics.Transform)">
            <summary>
            Construct a default set of render states with a custom transform
            </summary>
            <param name="transform">Transform to use</param>
        </member>
        <member name="M:SFML.Graphics.RenderStates.#ctor(SFML.Graphics.Texture)">
            <summary>
            Construct a default set of render states with a custom texture
            </summary>
            <param name="texture">Texture to use</param>
        </member>
        <member name="M:SFML.Graphics.RenderStates.#ctor(SFML.Graphics.Shader)">
            <summary>
            Construct a default set of render states with a custom shader
            </summary>
            <param name="shader">Shader to use</param>
        </member>
        <member name="M:SFML.Graphics.RenderStates.#ctor(SFML.Graphics.BlendMode,SFML.Graphics.Transform,SFML.Graphics.Texture,SFML.Graphics.Shader)">
            <summary>
            Construct a set of render states with all its attributes
            </summary>
            <param name="blendMode">Blend mode to use</param>
            <param name="transform">Transform to use</param>
            <param name="texture">Texture to use</param>
            <param name="shader">Shader to use</param>
        </member>
        <member name="M:SFML.Graphics.RenderStates.#ctor(SFML.Graphics.RenderStates)">
            <summary>
            Copy constructor
            </summary>
            <param name="copy">States to copy</param>
        </member>
        <member name="P:SFML.Graphics.RenderStates.Default">
            <summary>Special instance holding the default render states</summary>
        </member>
        <member name="F:SFML.Graphics.RenderStates.BlendMode">
            <summary>Blending mode</summary>
        </member>
        <member name="F:SFML.Graphics.RenderStates.Transform">
            <summary>Transform</summary>
        </member>
        <member name="F:SFML.Graphics.RenderStates.Texture">
            <summary>Texture</summary>
        </member>
        <member name="F:SFML.Graphics.RenderStates.Shader">
            <summary>Shader</summary>
        </member>
        <member name="T:SFML.Graphics.RenderTarget">
            <summary>
            Abstract base class for render targets (renderwindow, renderimage)
            </summary>
        </member>
        <member name="P:SFML.Graphics.RenderTarget.Size">
            <summary>
            Size of the rendering region of the target
            </summary>
        </member>
        <member name="P:SFML.Graphics.RenderTarget.DefaultView">
            <summary>
            Default view of the target
            </summary>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.GetView">
            <summary>
            Return the current active view
            </summary>
            <returns>The current view</returns>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.SetView(SFML.Graphics.View)">
            <summary>
            Change the current active view
            </summary>
            <param name="view">New view</param>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.GetViewport(SFML.Graphics.View)">
            <summary>
            Get the viewport of a view applied to this target
            </summary>
            <param name="view">Target view</param>
            <returns>Viewport rectangle, expressed in pixels in the current target</returns>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.MapPixelToCoords(SFML.System.Vector2i)">
             <summary>
             Convert a point from target coordinates to world
             coordinates, using the current view
            
             This function is an overload of the MapPixelToCoords
             function that implicitly uses the current view.
             It is equivalent to:
             target.MapPixelToCoords(point, target.GetView());
             </summary>
             <param name="point">Pixel to convert</param>
             <returns>The converted point, in "world" coordinates</returns>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.MapPixelToCoords(SFML.System.Vector2i,SFML.Graphics.View)">
             <summary>
             Convert a point from target coordinates to world coordinates
            
             This function finds the 2D position that matches the
             given pixel of the render-target. In other words, it does
             the inverse of what the graphics card does, to find the
             initial position of a rendered pixel.
            
             Initially, both coordinate systems (world units and target pixels)
             match perfectly. But if you define a custom view or resize your
             render-target, this assertion is not true anymore, ie. a point
             located at (10, 50) in your render-target may map to the point
             (150, 75) in your 2D world -- if the view is translated by (140, 25).
            
             For render-windows, this function is typically used to find
             which point (or object) is located below the mouse cursor.
            
             This version uses a custom view for calculations, see the other
             overload of the function if you want to use the current view of the
             render-target.
             </summary>
             <param name="point">Pixel to convert</param>
             <param name="view">The view to use for converting the point</param>
             <returns>The converted point, in "world" coordinates</returns>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.MapCoordsToPixel(SFML.System.Vector2f)">
             <summary>
             Convert a point from world coordinates to target
             coordinates, using the current view
            
             This function is an overload of the mapCoordsToPixel
             function that implicitly uses the current view.
             It is equivalent to:
             target.MapCoordsToPixel(point, target.GetView());
             </summary>
             <param name="point">Point to convert</param>
             <returns>The converted point, in target coordinates (pixels)</returns>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.MapCoordsToPixel(SFML.System.Vector2f,SFML.Graphics.View)">
             <summary>
             Convert a point from world coordinates to target coordinates
            
             This function finds the pixel of the render-target that matches
             the given 2D point. In other words, it goes through the same process
             as the graphics card, to compute the final position of a rendered point.
            
             Initially, both coordinate systems (world units and target pixels)
             match perfectly. But if you define a custom view or resize your
             render-target, this assertion is not true anymore, ie. a point
             located at (150, 75) in your 2D world may map to the pixel
             (10, 50) of your render-target -- if the view is translated by (140, 25).
            
             This version uses a custom view for calculations, see the other
             overload of the function if you want to use the current view of the
             render-target.
             </summary>
             <param name="point">Point to convert</param>
             <param name="view">The view to use for converting the point</param>
             <returns>The converted point, in target coordinates (pixels)</returns>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.Clear">
            <summary>
            Clear the entire target with black color
            </summary>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.Clear(SFML.Graphics.Color)">
            <summary>
            Clear the entire target with a single color
            </summary>
            <param name="color">Color to use to clear the window</param>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.Draw(SFML.Graphics.Drawable)">
            <summary>
            Draw a drawable object to the render-target, with default render states
            </summary>
            <param name="drawable">Object to draw</param>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.Draw(SFML.Graphics.Drawable,SFML.Graphics.RenderStates)">
            <summary>
            Draw a drawable object to the render-target
            </summary>
            <param name="drawable">Object to draw</param>
            <param name="states">Render states to use for drawing</param>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.Draw(SFML.Graphics.Vertex[],SFML.Graphics.PrimitiveType)">
            <summary>
            Draw primitives defined by an array of vertices, with default render states
            </summary>
            <param name="vertices">Array of vertices to draw</param>
            <param name="type">Type of primitives to draw</param>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.Draw(SFML.Graphics.Vertex[],SFML.Graphics.PrimitiveType,SFML.Graphics.RenderStates)">
            <summary>
            Draw primitives defined by an array of vertices
            </summary>
            <param name="vertices">Array of vertices to draw</param>
            <param name="type">Type of primitives to draw</param>
            <param name="states">Render states to use for drawing</param>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.Draw(SFML.Graphics.Vertex[],System.UInt32,System.UInt32,SFML.Graphics.PrimitiveType)">
            <summary>
            Draw primitives defined by a sub-array of vertices, with default render states
            </summary>
            <param name="vertices">Array of vertices to draw</param>
            <param name="start">Index of the first vertex to draw in the array</param>
            <param name="count">Number of vertices to draw</param>
            <param name="type">Type of primitives to draw</param>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.Draw(SFML.Graphics.Vertex[],System.UInt32,System.UInt32,SFML.Graphics.PrimitiveType,SFML.Graphics.RenderStates)">
            <summary>
            Draw primitives defined by a sub-array of vertices
            </summary>
            <param name="vertices">Pointer to the vertices</param>
            <param name="start">Index of the first vertex to use in the array</param>
            <param name="count">Number of vertices to draw</param>
            <param name="type">Type of primitives to draw</param>
            <param name="states">Render states to use for drawing</param>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.PushGLStates">
             <summary>
             Save the current OpenGL render states and matrices.
            
             This function can be used when you mix SFML drawing
             and direct OpenGL rendering. Combined with PopGLStates,
             it ensures that:
             \li SFML's internal states are not messed up by your OpenGL code
             \li your OpenGL states are not modified by a call to a SFML function
            
             More specifically, it must be used around code that
             calls Draw functions. Example:
            
             // OpenGL code here...
             window.PushGLStates();
             window.Draw(...);
             window.Draw(...);
             window.PopGLStates();
             // OpenGL code here...
            
             Note that this function is quite expensive: it saves all the
             possible OpenGL states and matrices, even the ones you
             don't care about. Therefore it should be used wisely.
             It is provided for convenience, but the best results will
             be achieved if you handle OpenGL states yourself (because
             you know which states have really changed, and need to be
             saved and restored). Take a look at the ResetGLStates
             function if you do so.
             </summary>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.PopGLStates">
             <summary>
             Restore the previously saved OpenGL render states and matrices.
            
             See the description of PushGLStates to get a detailed
             description of these functions.
             </summary>
        </member>
        <member name="M:SFML.Graphics.RenderTarget.ResetGLStates">
             <summary>
             Reset the internal OpenGL states so that the target is ready for drawing.
            
             This function can be used when you mix SFML drawing
             and direct OpenGL rendering, if you choose not to use
             PushGLStates/PopGLStates. It makes sure that all OpenGL
             states needed by SFML are set, so that subsequent Draw()
             calls will work as expected.
            
             Example:
            
             // OpenGL code here...
             glPushAttrib(...);
             window.ResetGLStates();
             window.Draw(...);
             window.Draw(...);
             glPopAttrib(...);
             // OpenGL code here...
             </summary>
        </member>
        <member name="T:SFML.Graphics.RenderTexture">
            <summary>
            Target for off-screen 2D rendering into an texture
            </summary>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Create the render-texture with the given dimensions
            </summary>
            <param name="width">Width of the render-texture</param>
            <param name="height">Height of the render-texture</param>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.#ctor(System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Create the render-texture with the given dimensions and
            an optional depth-buffer attached
            </summary>
            <param name="width">Width of the render-texture</param>
            <param name="height">Height of the render-texture</param>
            <param name="depthBuffer">Do you want a depth-buffer attached?</param>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.#ctor(System.UInt32,System.UInt32,SFML.Window.ContextSettings)">
            <summary>
            Create the render-texture with the given dimensions and
            a ContextSettings.
            </summary>
            <param name="width">Width of the render-texture</param>
            <param name="height">Height of the render-texture</param>
            <param name="settings">A ContextSettings struct representing settings for the RenderTexture</param>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.SetActive(System.Boolean)">
            <summary>
            Activate of deactivate the render texture as the current target
            for rendering
            </summary>
            <param name="active">True to activate, false to deactivate (true by default)</param>
            <returns>True if operation was successful, false otherwise</returns>
        </member>
        <member name="P:SFML.Graphics.RenderTexture.Repeated">
             <summary>
             Enable or disable texture repeating
             </summary>
            
             <remarks>
             This property is similar to <see cref="P:SFML.Graphics.Texture.Repeated"/>.
             This parameter is disabled by default.
             </remarks>
        </member>
        <member name="P:SFML.Graphics.RenderTexture.Size">
            <summary>
            Size of the rendering region of the render texture
            </summary>
        </member>
        <member name="P:SFML.Graphics.RenderTexture.DefaultView">
            <summary>
            Default view of the render texture
            </summary>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.GetView">
            <summary>
            Return the current active view
            </summary>
            <returns>The current view</returns>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.SetView(SFML.Graphics.View)">
            <summary>
            Change the current active view
            </summary>
            <param name="view">New view</param>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.GetViewport(SFML.Graphics.View)">
            <summary>
            Get the viewport of a view applied to this target
            </summary>
            <param name="view">Target view</param>
            <returns>Viewport rectangle, expressed in pixels in the current target</returns>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.MapPixelToCoords(SFML.System.Vector2i)">
             <summary>
             Convert a point from target coordinates to world
             coordinates, using the current view
            
             This function is an overload of the MapPixelToCoords
             function that implicitly uses the current view.
             It is equivalent to:
             target.MapPixelToCoords(point, target.GetView());
             </summary>
             <param name="point">Pixel to convert</param>
             <returns>The converted point, in "world" coordinates</returns>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.MapPixelToCoords(SFML.System.Vector2i,SFML.Graphics.View)">
             <summary>
             Convert a point from target coordinates to world coordinates
            
             This function finds the 2D position that matches the
             given pixel of the render-target. In other words, it does
             the inverse of what the graphics card does, to find the
             initial position of a rendered pixel.
            
             Initially, both coordinate systems (world units and target pixels)
             match perfectly. But if you define a custom view or resize your
             render-target, this assertion is not true anymore, ie. a point
             located at (10, 50) in your render-target may map to the point
             (150, 75) in your 2D world -- if the view is translated by (140, 25).
            
             For render-windows, this function is typically used to find
             which point (or object) is located below the mouse cursor.
            
             This version uses a custom view for calculations, see the other
             overload of the function if you want to use the current view of the
             render-target.
             </summary>
             <param name="point">Pixel to convert</param>
             <param name="view">The view to use for converting the point</param>
             <returns>The converted point, in "world" coordinates</returns>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.MapCoordsToPixel(SFML.System.Vector2f)">
             <summary>
             Convert a point from world coordinates to target
             coordinates, using the current view
            
             This function is an overload of the mapCoordsToPixel
             function that implicitly uses the current view.
             It is equivalent to:
             target.MapCoordsToPixel(point, target.GetView());
             </summary>
             <param name="point">Point to convert</param>
             <returns>The converted point, in target coordinates (pixels)</returns>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.MapCoordsToPixel(SFML.System.Vector2f,SFML.Graphics.View)">
             <summary>
             Convert a point from world coordinates to target coordinates
            
             This function finds the pixel of the render-target that matches
             the given 2D point. In other words, it goes through the same process
             as the graphics card, to compute the final position of a rendered point.
            
             Initially, both coordinate systems (world units and target pixels)
             match perfectly. But if you define a custom view or resize your
             render-target, this assertion is not true anymore, ie. a point
             located at (150, 75) in your 2D world may map to the pixel
             (10, 50) of your render-target -- if the view is translated by (140, 25).
            
             This version uses a custom view for calculations, see the other
             overload of the function if you want to use the current view of the
             render-target.
             </summary>
             <param name="point">Point to convert</param>
             <param name="view">The view to use for converting the point</param>
             <returns>The converted point, in target coordinates (pixels)</returns>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.GenerateMipmap">
             <summary>
             Generate a mipmap using the current texture data
             </summary>
            
             <remarks>
             This function is similar to <see cref="M:SFML.Graphics.Texture.GenerateMipmap"/> and operates
             on the texture used as the target for drawing.
             Be aware that any draw operation may modify the base level image data.
             For this reason, calling this function only makes sense after all
             drawing is completed and display has been called. Not calling display
             after subsequent drawing will lead to undefined behavior if a mipmap
             had been previously generated.
             </remarks>
            
             <returns>True if mipmap generation was successful, false if unsuccessful</returns>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.Clear">
            <summary>
            Clear the entire render texture with black color
            </summary>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.Clear(SFML.Graphics.Color)">
            <summary>
            Clear the entire render texture with a single color
            </summary>
            <param name="color">Color to use to clear the texture</param>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.Display">
            <summary>
            Update the contents of the target texture
            </summary>
        </member>
        <member name="P:SFML.Graphics.RenderTexture.Texture">
            <summary>
            Target texture of the render texture
            </summary>
        </member>
        <member name="P:SFML.Graphics.RenderTexture.MaximumAntialiasingLevel">
            <summary>
            The maximum anti-aliasing level supported by the system
            </summary>
        </member>
        <member name="P:SFML.Graphics.RenderTexture.Smooth">
            <summary>
            Control the smooth filter
            </summary>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.Draw(SFML.Graphics.Drawable)">
            <summary>
            Draw a drawable object to the render-target, with default render states
            </summary>
            <param name="drawable">Object to draw</param>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.Draw(SFML.Graphics.Drawable,SFML.Graphics.RenderStates)">
            <summary>
            Draw a drawable object to the render-target
            </summary>
            <param name="drawable">Object to draw</param>
            <param name="states">Render states to use for drawing</param>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.Draw(SFML.Graphics.Vertex[],SFML.Graphics.PrimitiveType)">
            <summary>
            Draw primitives defined by an array of vertices, with default render states
            </summary>
            <param name="vertices">Pointer to the vertices</param>
            <param name="type">Type of primitives to draw</param>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.Draw(SFML.Graphics.Vertex[],SFML.Graphics.PrimitiveType,SFML.Graphics.RenderStates)">
            <summary>
            Draw primitives defined by an array of vertices
            </summary>
            <param name="vertices">Pointer to the vertices</param>
            <param name="type">Type of primitives to draw</param>
            <param name="states">Render states to use for drawing</param>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.Draw(SFML.Graphics.Vertex[],System.UInt32,System.UInt32,SFML.Graphics.PrimitiveType)">
            <summary>
            Draw primitives defined by a sub-array of vertices, with default render states
            </summary>
            <param name="vertices">Array of vertices to draw</param>
            <param name="start">Index of the first vertex to draw in the array</param>
            <param name="count">Number of vertices to draw</param>
            <param name="type">Type of primitives to draw</param>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.Draw(SFML.Graphics.Vertex[],System.UInt32,System.UInt32,SFML.Graphics.PrimitiveType,SFML.Graphics.RenderStates)">
            <summary>
            Draw primitives defined by a sub-array of vertices
            </summary>
            <param name="vertices">Pointer to the vertices</param>
            <param name="start">Index of the first vertex to use in the array</param>
            <param name="count">Number of vertices to draw</param>
            <param name="type">Type of primitives to draw</param>
            <param name="states">Render states to use for drawing</param>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.PushGLStates">
             <summary>
             Save the current OpenGL render states and matrices.
            
             This function can be used when you mix SFML drawing
             and direct OpenGL rendering. Combined with PopGLStates,
             it ensures that:
             \li SFML's internal states are not messed up by your OpenGL code
             \li your OpenGL states are not modified by a call to a SFML function
            
             More specifically, it must be used around code that
             calls Draw functions. Example:
            
             // OpenGL code here...
             window.PushGLStates();
             window.Draw(...);
             window.Draw(...);
             window.PopGLStates();
             // OpenGL code here...
            
             Note that this function is quite expensive: it saves all the
             possible OpenGL states and matrices, even the ones you
             don't care about. Therefore it should be used wisely.
             It is provided for convenience, but the best results will
             be achieved if you handle OpenGL states yourself (because
             you know which states have really changed, and need to be
             saved and restored). Take a look at the ResetGLStates
             function if you do so.
             </summary>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.PopGLStates">
             <summary>
             Restore the previously saved OpenGL render states and matrices.
            
             See the description of PushGLStates to get a detailed
             description of these functions.
             </summary>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.ResetGLStates">
             <summary>
             Reset the internal OpenGL states so that the target is ready for drawing.
            
             This function can be used when you mix SFML drawing
             and direct OpenGL rendering, if you choose not to use
             PushGLStates/PopGLStates. It makes sure that all OpenGL
             states needed by SFML are set, so that subsequent Draw()
             calls will work as expected.
            
             Example:
            
             // OpenGL code here...
             glPushAttrib(...);
             window.ResetGLStates();
             window.Draw(...);
             window.Draw(...);
             glPopAttrib(...);
             // OpenGL code here...
             </summary>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.RenderTexture.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="T:SFML.Graphics.RenderWindow">
            <summary>
            Simple wrapper for Window that allows easy
            2D rendering
            </summary>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.#ctor(SFML.Window.VideoMode,System.String)">
            <summary>
            Create the window with default style and creation settings
            </summary>
            <param name="mode">Video mode to use</param>
            <param name="title">Title of the window</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.#ctor(SFML.Window.VideoMode,System.String,SFML.Window.Styles)">
            <summary>
            Create the window with default creation settings
            </summary>
            <param name="mode">Video mode to use</param>
            <param name="title">Title of the window</param>
            <param name="style">Window style (Resize | Close by default)</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.#ctor(SFML.Window.VideoMode,System.String,SFML.Window.Styles,SFML.Window.ContextSettings)">
            <summary>
            Create the window
            </summary>
            <param name="mode">Video mode to use</param>
            <param name="title">Title of the window</param>
            <param name="style">Window style (Resize | Close by default)</param>
            <param name="settings">Creation parameters</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.#ctor(System.IntPtr)">
            <summary>
            Create the window from an existing control with default creation settings
            </summary>
            <param name="handle">Platform-specific handle of the control</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.#ctor(System.IntPtr,SFML.Window.ContextSettings)">
            <summary>
            Create the window from an existing control
            </summary>
            <param name="handle">Platform-specific handle of the control</param>
            <param name="settings">Creation parameters</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.Close">
            <summary>
            Close (destroy) the window.
            The Window instance remains valid and you can call
            Create to recreate the window
            </summary>
        </member>
        <member name="P:SFML.Graphics.RenderWindow.IsOpen">
            <summary>
            Tell whether or not the window is opened (ie. has been created).
            Note that a hidden window (Show(false))
            will still return true
            </summary>
            <returns>True if the window is opened</returns>
        </member>
        <member name="P:SFML.Graphics.RenderWindow.Settings">
            <summary>
            Creation settings of the window
            </summary>
        </member>
        <member name="P:SFML.Graphics.RenderWindow.Position">
            <summary>
            Position of the window
            </summary>
        </member>
        <member name="P:SFML.Graphics.RenderWindow.Size">
            <summary>
            Size of the rendering region of the window
            </summary>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.SetTitle(System.String)">
            <summary>
            Change the title of the window
            </summary>
            <param name="title">New title</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.SetIcon(System.UInt32,System.UInt32,System.Byte[])">
            <summary>
            Change the window's icon
            </summary>
            <param name="width">Icon's width, in pixels</param>
            <param name="height">Icon's height, in pixels</param>
            <param name="pixels">Array of pixels, format must be RGBA 32 bits</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.SetVisible(System.Boolean)">
            <summary>
            Show or hide the window
            </summary>
            <param name="visible">True to show the window, false to hide it</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.SetVerticalSyncEnabled(System.Boolean)">
            <summary>
            Enable / disable vertical synchronization
            </summary>
            <param name="enable">True to enable v-sync, false to deactivate</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.SetMouseCursorVisible(System.Boolean)">
            <summary>
            Show or hide the mouse cursor
            </summary>
            <param name="visible">True to show, false to hide</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.SetMouseCursorGrabbed(System.Boolean)">
            <summary>
            Grab or release the mouse cursor
            </summary>
            <param name="grabbed">True to grab, false to release</param>
            
            <remarks>
            If set, grabs the mouse cursor inside this window's client
            area so it may no longer be moved outside its bounds.
            Note that grabbing is only active while the window has
            focus and calling this function for fullscreen windows
            won't have any effect (fullscreen windows always grab the
            cursor).
            </remarks>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.SetMouseCursor(SFML.Window.Cursor)">
            <summary>
            Set the displayed cursor to a native system cursor
            </summary>
            <param name="cursor">Native system cursor type to display</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.SetKeyRepeatEnabled(System.Boolean)">
            <summary>
            Enable or disable automatic key-repeat.
            Automatic key-repeat is enabled by default
            </summary>
            <param name="enable">True to enable, false to disable</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.SetFramerateLimit(System.UInt32)">
            <summary>
            Limit the framerate to a maximum fixed frequency
            </summary>
            <param name="limit">Framerate limit, in frames per seconds (use 0 to disable limit)</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.SetJoystickThreshold(System.Single)">
            <summary>
            Change the joystick threshold, ie. the value below which
            no move event will be generated
            </summary>
            <param name="threshold">New threshold, in range [0, 100]</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.SetActive(System.Boolean)">
            <summary>
            Activate of deactivate the window as the current target
            for rendering
            </summary>
            <param name="active">True to activate, false to deactivate (true by default)</param>
            <returns>True if operation was successful, false otherwise</returns>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.RequestFocus">
            <summary>
            Request the current window to be made the active
            foreground window
            </summary>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.HasFocus">
            <summary>
            Check whether the window has the input focus
            </summary>
            <returns>True if the window has focus, false otherwise</returns>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.Display">
            <summary>
            Display the window on screen
            </summary>
        </member>
        <member name="P:SFML.Graphics.RenderWindow.SystemHandle">
            <summary>
            OS-specific handle of the window
            </summary>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.Clear">
            <summary>
            Clear the entire window with black color
            </summary>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.Clear(SFML.Graphics.Color)">
            <summary>
            Clear the entire window with a single color
            </summary>
            <param name="color">Color to use to clear the window</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.SetView(SFML.Graphics.View)">
            <summary>
            Change the current active view
            </summary>
            <param name="view">New view</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.GetView">
            <summary>
            Return the current active view
            </summary>
            <returns>The current view</returns>
        </member>
        <member name="P:SFML.Graphics.RenderWindow.DefaultView">
            <summary>
            Default view of the window
            </summary>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.GetViewport(SFML.Graphics.View)">
            <summary>
            Get the viewport of a view applied to this target
            </summary>
            <param name="view">Target view</param>
            <returns>Viewport rectangle, expressed in pixels in the current target</returns>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.MapPixelToCoords(SFML.System.Vector2i)">
             <summary>
             Convert a point from target coordinates to world
             coordinates, using the current view
            
             This function is an overload of the MapPixelToCoords
             function that implicitly uses the current view.
             It is equivalent to:
             target.MapPixelToCoords(point, target.GetView());
             </summary>
             <param name="point">Pixel to convert</param>
             <returns>The converted point, in "world" coordinates</returns>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.MapPixelToCoords(SFML.System.Vector2i,SFML.Graphics.View)">
             <summary>
             Convert a point from target coordinates to world coordinates
            
             This function finds the 2D position that matches the
             given pixel of the render-target. In other words, it does
             the inverse of what the graphics card does, to find the
             initial position of a rendered pixel.
            
             Initially, both coordinate systems (world units and target pixels)
             match perfectly. But if you define a custom view or resize your
             render-target, this assertion is not true anymore, ie. a point
             located at (10, 50) in your render-target may map to the point
             (150, 75) in your 2D world -- if the view is translated by (140, 25).
            
             For render-windows, this function is typically used to find
             which point (or object) is located below the mouse cursor.
            
             This version uses a custom view for calculations, see the other
             overload of the function if you want to use the current view of the
             render-target.
             </summary>
             <param name="point">Pixel to convert</param>
             <param name="view">The view to use for converting the point</param>
             <returns>The converted point, in "world" coordinates</returns>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.MapCoordsToPixel(SFML.System.Vector2f)">
             <summary>
             Convert a point from world coordinates to target
             coordinates, using the current view
            
             This function is an overload of the mapCoordsToPixel
             function that implicitly uses the current view.
             It is equivalent to:
             target.MapCoordsToPixel(point, target.GetView());
             </summary>
             <param name="point">Point to convert</param>
             <returns>The converted point, in target coordinates (pixels)</returns>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.MapCoordsToPixel(SFML.System.Vector2f,SFML.Graphics.View)">
             <summary>
             Convert a point from world coordinates to target coordinates
            
             This function finds the pixel of the render-target that matches
             the given 2D point. In other words, it goes through the same process
             as the graphics card, to compute the final position of a rendered point.
            
             Initially, both coordinate systems (world units and target pixels)
             match perfectly. But if you define a custom view or resize your
             render-target, this assertion is not true anymore, ie. a point
             located at (150, 75) in your 2D world may map to the pixel
             (10, 50) of your render-target -- if the view is translated by (140, 25).
            
             This version uses a custom view for calculations, see the other
             overload of the function if you want to use the current view of the
             render-target.
             </summary>
             <param name="point">Point to convert</param>
             <param name="view">The view to use for converting the point</param>
             <returns>The converted point, in target coordinates (pixels)</returns>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.Draw(SFML.Graphics.Drawable)">
            <summary>
            Draw a drawable object to the render-target, with default render states
            </summary>
            <param name="drawable">Object to draw</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.Draw(SFML.Graphics.Drawable,SFML.Graphics.RenderStates)">
            <summary>
            Draw a drawable object to the render-target
            </summary>
            <param name="drawable">Object to draw</param>
            <param name="states">Render states to use for drawing</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.Draw(SFML.Graphics.Vertex[],SFML.Graphics.PrimitiveType)">
            <summary>
            Draw primitives defined by an array of vertices, with default render states
            </summary>
            <param name="vertices">Pointer to the vertices</param>
            <param name="type">Type of primitives to draw</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.Draw(SFML.Graphics.Vertex[],SFML.Graphics.PrimitiveType,SFML.Graphics.RenderStates)">
            <summary>
            Draw primitives defined by an array of vertices
            </summary>
            <param name="vertices">Pointer to the vertices</param>
            <param name="type">Type of primitives to draw</param>
            <param name="states">Render states to use for drawing</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.Draw(SFML.Graphics.Vertex[],System.UInt32,System.UInt32,SFML.Graphics.PrimitiveType)">
            <summary>
            Draw primitives defined by a sub-array of vertices, with default render states
            </summary>
            <param name="vertices">Array of vertices to draw</param>
            <param name="start">Index of the first vertex to draw in the array</param>
            <param name="count">Number of vertices to draw</param>
            <param name="type">Type of primitives to draw</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.Draw(SFML.Graphics.Vertex[],System.UInt32,System.UInt32,SFML.Graphics.PrimitiveType,SFML.Graphics.RenderStates)">
            <summary>
            Draw primitives defined by a sub-array of vertices
            </summary>
            <param name="vertices">Pointer to the vertices</param>
            <param name="start">Index of the first vertex to use in the array</param>
            <param name="count">Number of vertices to draw</param>
            <param name="type">Type of primitives to draw</param>
            <param name="states">Render states to use for drawing</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.PushGLStates">
             <summary>
             Save the current OpenGL render states and matrices.
             </summary>
             
             <example>
             // OpenGL code here...
             window.PushGLStates();
             window.Draw(...);
             window.Draw(...);
             window.PopGLStates();
             // OpenGL code here...
             </example>
            
             <remarks>
             <para>This function can be used when you mix SFML drawing
             and direct OpenGL rendering. Combined with PopGLStates,
             it ensures that:</para>
             <para>SFML's internal states are not messed up by your OpenGL code</para>
             <para>Your OpenGL states are not modified by a call to a SFML function</para>
            
             <para>More specifically, it must be used around code that
             calls Draw functions.</para>
            
             <para>Note that this function is quite expensive: it saves all the
             possible OpenGL states and matrices, even the ones you
             don't care about. Therefore it should be used wisely.
             It is provided for convenience, but the best results will
             be achieved if you handle OpenGL states yourself (because
             you know which states have really changed, and need to be
             saved and restored). Take a look at the <seealso cref="M:SFML.Graphics.RenderWindow.ResetGLStates"/>
             function if you do so.</para>
             </remarks>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.PopGLStates">
             <summary>
             Restore the previously saved OpenGL render states and matrices.
            
             See the description of <seealso cref="M:SFML.Graphics.RenderWindow.PushGLStates"/> to get a detailed
             description of these functions.
             </summary>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.ResetGLStates">
             <summary>
             Reset the internal OpenGL states so that the target is ready for drawing.
             </summary>
            
             <remarks>
             This function can be used when you mix SFML drawing
             and direct OpenGL rendering, if you choose not to use
             PushGLStates/PopGLStates. It makes sure that all OpenGL
             states needed by SFML are set, so that subsequent Draw()
             calls will work as expected.
             </remarks>
             
             <example>
             // OpenGL code here...
             glPushAttrib(...);
             window.ResetGLStates();
             window.Draw(...);
             window.Draw(...);
             glPopAttrib(...);
             // OpenGL code here...
             </example>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.Capture">
            <summary>
            Capture the current contents of the window into an image.
            </summary>
            
            <remarks>
            Deprecated. Use <see cref="T:SFML.Graphics.Texture"/> and <see cref="M:SFML.Graphics.Texture.Update(SFML.Graphics.RenderWindow)"/>
            instead:
            <code>
               Texture texture = new Texture(window.Size);
               texture.update(window);
               Image img = texture.CopyToImage();
               </code>
            </remarks>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.PollEvent(SFML.Window.Event@)">
            <summary>
            Internal function to get the next event
            </summary>
            <param name="eventToFill">Variable to fill with the raw pointer to the event structure</param>
            <returns>True if there was an event, false otherwise</returns>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.WaitEvent(SFML.Window.Event@)">
            <summary>
            Internal function to get the next event (blocking)
            </summary>
            <param name="eventToFill">Variable to fill with the raw pointer to the event structure</param>
            <returns>False if any error occured</returns>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.InternalGetMousePosition">
            <summary>
            Internal function to get the mouse position relative to the window.
            This function is protected because it is called by another class,
            it is not meant to be called by users.
            </summary>
            <returns>Relative mouse position</returns>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.InternalSetMousePosition(SFML.System.Vector2i)">
            <summary>
            Internal function to set the mouse position relative to the window.
            This function is protected because it is called by another class,
            it is not meant to be called by users.
            </summary>
            <param name="position">Relative mouse position</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.InternalGetTouchPosition(System.UInt32)">
            <summary>
            Internal function to get the touch position relative to the window.
            This function is protected because it is called by another class of
            another module, it is not meant to be called by users.
            </summary>
            <param name="Finger">Finger index</param>
            <returns>Relative touch position</returns>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="M:SFML.Graphics.RenderWindow.Initialize">
            <summary>
            Do common initializations
            </summary>
        </member>
        <member name="T:SFML.Graphics.Shader">
            <summary>
            Wrapper for pixel shaders
            </summary>
        </member>
        <member name="T:SFML.Graphics.Shader.CurrentTextureType">
            <summary>
            Special type that can be passed to SetParameter,
            and that represents the texture of the object being drawn
            </summary>
        </member>
        <member name="F:SFML.Graphics.Shader.CurrentTexture">
            <summary>
            Special value that can be passed to SetParameter,
            and that represents the texture of the object being drawn
            </summary>
        </member>
        <member name="M:SFML.Graphics.Shader.#ctor(System.String,System.String,System.String)">
            <summary>
            Load the vertex, geometry and fragment shaders from files
            </summary>
            <remarks>
            This function loads the vertex, geometry and fragment
            shaders. Pass NULL if you don't want to load
            a specific shader.
            The sources must be text files containing valid shaders
            in GLSL language. GLSL is a C-like language dedicated to
            OpenGL shaders; you'll probably need to read a good documentation
            for it before writing your own shaders.
            </remarks>
            <param name="vertexShaderFilename">Path of the vertex shader file to load, or null to skip this shader</param>
            <param name="geometryShaderFilename">Path of the geometry shader file to load, or null to skip this shader</param>
            <param name="fragmentShaderFilename">Path of the fragment shader file to load, or null to skip this shader</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Shader.#ctor(System.IO.Stream,System.IO.Stream,System.IO.Stream)">
             <summary>
             Load the vertex, geometry and fragment shaders from custom streams
             </summary>
            
             <remarks>
             This function loads the vertex, geometry and fragment
             shaders. Pass NULL if you don't want to load
             a specific shader.
             The sources must be valid shaders in GLSL language. GLSL is
             a C-like language dedicated to OpenGL shaders; you'll
             probably need to read a good documentation for it before
             writing your own shaders.
             </remarks>
             <param name="vertexShaderStream">Source stream to read the vertex shader from, or null to skip this shader</param>
             <param name="geometryShaderStream">Source stream to read the geometry shader from, or null to skip this shader</param>
             <param name="fragmentShaderStream">Source stream to read the fragment shader from, or null to skip this shader</param>
             <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="P:SFML.Graphics.Shader.NativeHandle">
            <summary>
            Get the underlying OpenGL handle of the shader.
            </summary>
            <remarks>
            You shouldn't need to use this handle, unless you have
            very specific stuff to implement that SFML doesn't support,
            or implement a temporary workaround until a bug is fixed.
            </remarks>
        </member>
        <member name="M:SFML.Graphics.Shader.FromString(System.String,System.String,System.String)">
            <summary>
            Load the vertex, geometry and fragment shaders from source code in memory
            </summary>
            <remarks>
            This function loads the vertex, geometry and fragment
            shaders. Pass NULL if you don't want to load
            a specific shader.
            The sources must be valid shaders in GLSL language. GLSL is
            a C-like language dedicated to OpenGL shaders; you'll
            probably need to read a good documentation for it before
            writing your own shaders.
            </remarks>
            <param name="vertexShader">String containing the source code of the vertex shader</param>
            <param name="geometryShader">String containing the source code of the geometry shader</param>
            <param name="fragmentShader">String containing the source code of the fragment shader</param>
            <returns>New shader instance</returns>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,System.Single)">
            <summary>
            Specify value for <c>float</c> uniform
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="x">Value of the float scalar</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,SFML.Graphics.Glsl.Vec2)">
            <summary>
            Specify value for <c>vec2</c> uniform
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="vector">Value of the vec2 vector</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,SFML.Graphics.Glsl.Vec3)">
            <summary>
            Specify value for <c>vec3</c> uniform
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="vector">Value of the vec3 vector</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,SFML.Graphics.Glsl.Vec4)">
            <summary>
            Specify value for <c>vec4</c> uniform
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="vector">Value of the vec4 vector</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,System.Int32)">
            <summary>
            Specify value for <c>int</c> uniform
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="x">Value of the int scalar</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,SFML.Graphics.Glsl.Ivec2)">
            <summary>
            Specify value for <c>ivec2</c> uniform
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="vector">Value of the ivec2 vector</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,SFML.Graphics.Glsl.Ivec3)">
            <summary>
            Specify value for <c>ivec3</c> uniform
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="vector">Value of the ivec3 vector</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,SFML.Graphics.Glsl.Ivec4)">
            <summary>
            Specify value for <c>ivec4</c> uniform
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="vector">Value of the ivec4 vector</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,System.Boolean)">
            <summary>
            Specify value for <c>bool</c> uniform
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="x">Value of the bool scalar</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,SFML.Graphics.Glsl.Bvec2)">
            <summary>
            Specify value for <c>bvec2</c> uniform
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="vector">Value of the bvec2 vector</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,SFML.Graphics.Glsl.Bvec3)">
            <summary>
            Specify value for <c>bvec3</c> uniform
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="vector">Value of the bvec3 vector</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,SFML.Graphics.Glsl.Bvec4)">
            <summary>
            Specify value for <c>bvec4</c> uniform
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="vector">Value of the bvec4 vector</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,SFML.Graphics.Glsl.Mat3)">
            <summary>
            Specify value for <c>mat3</c> uniform
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="matrix">Value of the mat3 matrix</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,SFML.Graphics.Glsl.Mat4)">
            <summary>
            Specify value for <c>mat4</c> uniform
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="matrix">Value of the mat4 matrix</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,SFML.Graphics.Texture)">
             <summary>
             Specify a texture as <c>sampler2D</c> uniform
             </summary>
            
             <remarks>
             <para>name is the name of the variable to change in the shader.
             The corresponding parameter in the shader must be a 2D texture
             (<c>sampler2D</c> GLSL type).</para>
            
             <para>Example:
             <code>
             uniform sampler2D the_texture; // this is the variable in the shader
             </code>
             <code>
             sf::Texture texture;
             ...
             shader.setUniform("the_texture", texture);
             </code>
             It is important to note that <paramref name="texture"/> must remain alive as long
             as the shader uses it, no copy is made internally.</para>
            
             <para>To use the texture of the object being drawn, which cannot be
             known in advance, you can pass the special value
             Shader.CurrentTexture:
             <code>
             shader.setUniform("the_texture", Shader.CurrentTexture);
             </code>
             </para>
             </remarks>
             
             <param name="name">Name of the texture in the shader</param>
             <param name="texture">Texture to assign</param>
            
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniform(System.String,SFML.Graphics.Shader.CurrentTextureType)">
             <summary>
             Specify current texture as \p sampler2D uniform
             </summary>
            
             <remarks>
             <para>This overload maps a shader texture variable to the
             texture of the object being drawn, which cannot be
             known in advance. The second argument must be
             <see cref="F:SFML.Graphics.Shader.CurrentTexture"/>.
             The corresponding parameter in the shader must be a 2D texture
             (<c>sampler2D</c> GLSL type).</para>
            
             <para>Example:
             <code>
             uniform sampler2D current; // this is the variable in the shader
             </code>
             <code>
             shader.setUniform("current", Shader.CurrentTexture);
             </code>
             </para>
             </remarks>
             
             <param name="name">Name of the texture in the shader</param>
             <param name="current"/>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniformArray(System.String,System.Single[])">
            <summary>
            Specify values for <c>float[]</c> array uniforms
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="array">array of <c>float</c> values</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniformArray(System.String,SFML.Graphics.Glsl.Vec2[])">
            <summary>
            Specify values for <c>vec2[]</c> array uniforms
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="array">array of <c>vec2</c> values</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniformArray(System.String,SFML.Graphics.Glsl.Vec3[])">
            <summary>
            Specify values for <c>vec3[]</c> array uniforms
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="array">array of <c>vec3</c> values</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniformArray(System.String,SFML.Graphics.Glsl.Vec4[])">
            <summary>
            Specify values for <c>vec4[]</c> array uniforms
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="array">array of <c>vec4</c> values</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniformArray(System.String,SFML.Graphics.Glsl.Mat3[])">
            <summary>
            Specify values for <c>mat3[]</c> array uniforms
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="array">array of <c>mat3</c> values</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetUniformArray(System.String,SFML.Graphics.Glsl.Mat4[])">
            <summary>
            Specify values for <c>mat4[]</c> array uniforms
            </summary>
            <param name="name">Name of the uniform variable in GLSL</param>
            <param name="array">array of <c>mat4</c> values</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetParameter(System.String,System.Single)">
             <summary>
             Change a float parameter of the shader
            
             "name" is the name of the variable to change in the shader.
             The corresponding parameter in the shader must be a float
             (float GLSL type).
             </summary>
            
             <param name="name">Name of the parameter in the shader</param>
             <param name="x">Value to assign</param>
            
        </member>
        <member name="M:SFML.Graphics.Shader.SetParameter(System.String,System.Single,System.Single)">
             <summary>
             Change a 2-components vector parameter of the shader
            
             "name" is the name of the variable to change in the shader.
             The corresponding parameter in the shader must be a 2x1 vector
             (vec2 GLSL type).
             </summary>
             <param name="name">Name of the parameter in the shader</param>
             <param name="x">First component of the value to assign</param>
             <param name="y">Second component of the value to assign</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetParameter(System.String,System.Single,System.Single,System.Single)">
             <summary>
             Change a 3-components vector parameter of the shader
            
             "name" is the name of the variable to change in the shader.
             The corresponding parameter in the shader must be a 3x1 vector
             (vec3 GLSL type).
             </summary>
             <param name="name">Name of the parameter in the shader</param>
             <param name="x">First component of the value to assign</param>
             <param name="y">Second component of the value to assign</param>
             <param name="z">Third component of the value to assign</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetParameter(System.String,System.Single,System.Single,System.Single,System.Single)">
             <summary>
             Change a 4-components vector parameter of the shader
            
             "name" is the name of the variable to change in the shader.
             The corresponding parameter in the shader must be a 4x1 vector
             (vec4 GLSL type).
             </summary>
             <param name="name">Name of the parameter in the shader</param>
             <param name="x">First component of the value to assign</param>
             <param name="y">Second component of the value to assign</param>
             <param name="z">Third component of the value to assign</param>
             <param name="w">Fourth component of the value to assign</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetParameter(System.String,SFML.System.Vector2f)">
             <summary>
             Change a 2-components vector parameter of the shader
            
             "name" is the name of the variable to change in the shader.
             The corresponding parameter in the shader must be a 2x1 vector
             (vec2 GLSL type).
             </summary>
             <param name="name">Name of the parameter in the shader</param>
             <param name="vector">Vector to assign</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetParameter(System.String,SFML.Graphics.Color)">
             <summary>
             Change a color parameter of the shader
            
             "name" is the name of the variable to change in the shader.
             The corresponding parameter in the shader must be a 4x1 vector
             (vec4 GLSL type).
             </summary>
             <param name="name">Name of the parameter in the shader</param>
             <param name="color">Color to assign</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetParameter(System.String,SFML.Graphics.Transform)">
             <summary>
             Change a matrix parameter of the shader
            
             "name" is the name of the variable to change in the shader.
             The corresponding parameter in the shader must be a 4x4 matrix
             (mat4 GLSL type).
             </summary>
             <param name="name">Name of the parameter in the shader</param>
             <param name="transform">Transform to assign</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetParameter(System.String,SFML.Graphics.Texture)">
             <summary>
             Change a texture parameter of the shader
            
             "name" is the name of the variable to change in the shader.
             The corresponding parameter in the shader must be a 2D texture
             (sampler2D GLSL type).
            
             It is important to note that \a texture must remain alive as long
             as the shader uses it, no copy is made internally.
            
             To use the texture of the object being draw, which cannot be
             known in advance, you can pass the special value
             Shader.CurrentTexture.
             </summary>
             <param name="name">Name of the texture in the shader</param>
             <param name="texture">Texture to assign</param>
        </member>
        <member name="M:SFML.Graphics.Shader.SetParameter(System.String,SFML.Graphics.Shader.CurrentTextureType)">
             <summary>
             Change a texture parameter of the shader
            
             This overload maps a shader texture variable to the
             texture of the object being drawn, which cannot be
             known in advance. The second argument must be
             sf::Shader::CurrentTexture.
             The corresponding parameter in the shader must be a 2D texture
             (sampler2D GLSL type).
             </summary>
             <param name="name">Name of the texture in the shader</param>
             <param name="current">Always pass the spacial value Shader.CurrentTexture</param>
        </member>
        <member name="M:SFML.Graphics.Shader.Bind(SFML.Graphics.Shader)">
            <summary>
            Bind a shader for rendering
            </summary>
            <param name="shader">Shader to bind (can be null to use no shader)</param>
        </member>
        <member name="P:SFML.Graphics.Shader.IsAvailable">
             <summary>
             Tell whether or not the system supports shaders.
             </summary>
            
             <remarks>
             This property should always be checked before using
             the shader features. If it returns false, then
             any attempt to use Shader will fail.
             </remarks>
        </member>
        <member name="P:SFML.Graphics.Shader.IsGeometryAvailable">
            <summary>
            Tell whether or not the system supports geometry shaders.
            </summary>
            
            <remarks>
            <para>This property should always be checked before using
            the geometry shader features. If it returns false, then
            any attempt to use geometry shader features will fail.</para>
            
            <para>Note: The first call to this function, whether by your
            code or SFML will result in a context switch.</para>
            </remarks>
        </member>
        <member name="M:SFML.Graphics.Shader.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.Shader.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="M:SFML.Graphics.Shader.#ctor(System.IntPtr)">
            <summary>
            Construct the shader from a pointer
            </summary>
            <param name="ptr">Pointer to the shader instance</param>
        </member>
        <member name="T:SFML.Graphics.Shape">
            <summary>
            Base class for textured shapes with outline
            </summary>
        </member>
        <member name="P:SFML.Graphics.Shape.Texture">
            <summary>
            Source texture of the shape
            </summary>
        </member>
        <member name="P:SFML.Graphics.Shape.TextureRect">
            <summary>
            Sub-rectangle of the texture that the shape will display
            </summary>
        </member>
        <member name="P:SFML.Graphics.Shape.FillColor">
            <summary>
            Fill color of the shape
            </summary>
        </member>
        <member name="P:SFML.Graphics.Shape.OutlineColor">
            <summary>
            Outline color of the shape
            </summary>
        </member>
        <member name="P:SFML.Graphics.Shape.OutlineThickness">
            <summary>
            Thickness of the shape's outline
            </summary>
        </member>
        <member name="M:SFML.Graphics.Shape.GetPointCount">
            <summary>
            Get the total number of points of the shape
            </summary>
            <returns>The total point count</returns>
        </member>
        <member name="M:SFML.Graphics.Shape.GetPoint(System.UInt32)">
             <summary>
             Get the position of a point
            
             The returned point is in local coordinates, that is,
             the shape's transforms (position, rotation, scale) are
             not taken into account.
             The result is undefined if index is out of the valid range.
             </summary>
             <param name="index">Index of the point to get, in range [0 .. PointCount - 1]</param>
             <returns>index-th point of the shape</returns>
        </member>
        <member name="M:SFML.Graphics.Shape.GetLocalBounds">
             <summary>
             Get the local bounding rectangle of the entity.
            
             The returned rectangle is in local coordinates, which means
             that it ignores the transformations (translation, rotation,
             scale, ...) that are applied to the entity.
             In other words, this function returns the bounds of the
             entity in the entity's coordinate system.
             </summary>
             <returns>Local bounding rectangle of the entity</returns>
        </member>
        <member name="M:SFML.Graphics.Shape.GetGlobalBounds">
             <summary>
             Get the global bounding rectangle of the entity.
            
             The returned rectangle is in global coordinates, which means
             that it takes in account the transformations (translation,
             rotation, scale, ...) that are applied to the entity.
             In other words, this function returns the bounds of the
             sprite in the global 2D world's coordinate system.
             </summary>
             <returns>Global bounding rectangle of the entity</returns>
        </member>
        <member name="M:SFML.Graphics.Shape.Draw(SFML.Graphics.RenderTarget,SFML.Graphics.RenderStates)">
            <summary>
            Draw the shape to a render target
            </summary>
            <param name="target">Render target to draw to</param>
            <param name="states">Current render states</param>
        </member>
        <member name="M:SFML.Graphics.Shape.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:SFML.Graphics.Shape.#ctor(SFML.Graphics.Shape)">
            <summary>
            Construct the shape from another shape
            </summary>
            <param name="copy">Shape to copy</param>
        </member>
        <member name="M:SFML.Graphics.Shape.Update">
             <summary>
             Recompute the internal geometry of the shape.
            
             This function must be called by the derived class everytime
             the shape's points change (ie. the result of either
             PointCount or GetPoint is different).
             </summary>
        </member>
        <member name="M:SFML.Graphics.Shape.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="M:SFML.Graphics.Shape.InternalGetPointCount(System.IntPtr)">
            <summary>
            Callback passed to the C API
            </summary>
        </member>
        <member name="M:SFML.Graphics.Shape.InternalGetPoint(System.UInt32,System.IntPtr)">
            <summary>
            Callback passed to the C API
            </summary>
        </member>
        <member name="T:SFML.Graphics.Sprite">
            <summary>
            This class defines a sprite : texture, transformations,
            color, and draw on screen
            </summary>
            <remarks>
            See also the note on coordinates and undistorted rendering in SFML.Graphics.Transformable.
            </remarks>
        </member>
        <member name="M:SFML.Graphics.Sprite.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:SFML.Graphics.Sprite.#ctor(SFML.Graphics.Texture)">
            <summary>
            Construct the sprite from a source texture
            </summary>
            <param name="texture">Source texture to assign to the sprite</param>
        </member>
        <member name="M:SFML.Graphics.Sprite.#ctor(SFML.Graphics.Texture,SFML.Graphics.IntRect)">
            <summary>
            Construct the sprite from a source texture
            </summary>
            <param name="texture">Source texture to assign to the sprite</param>
            <param name="rectangle">Sub-rectangle of the texture to assign to the sprite</param>
        </member>
        <member name="M:SFML.Graphics.Sprite.#ctor(SFML.Graphics.Sprite)">
            <summary>
            Construct the sprite from another sprite
            </summary>
            <param name="copy">Sprite to copy</param>
        </member>
        <member name="P:SFML.Graphics.Sprite.Color">
            <summary>
            Global color of the object
            </summary>
        </member>
        <member name="P:SFML.Graphics.Sprite.Texture">
            <summary>
            Source texture displayed by the sprite
            </summary>
        </member>
        <member name="P:SFML.Graphics.Sprite.TextureRect">
            <summary>
            Sub-rectangle of the source image displayed by the sprite
            </summary>
        </member>
        <member name="M:SFML.Graphics.Sprite.GetLocalBounds">
             <summary>
             Get the local bounding rectangle of the entity.
            
             The returned rectangle is in local coordinates, which means
             that it ignores the transformations (translation, rotation,
             scale, ...) that are applied to the entity.
             In other words, this function returns the bounds of the
             entity in the entity's coordinate system.
             </summary>
             <returns>Local bounding rectangle of the entity</returns>
        </member>
        <member name="M:SFML.Graphics.Sprite.GetGlobalBounds">
             <summary>
             Get the global bounding rectangle of the entity.
            
             The returned rectangle is in global coordinates, which means
             that it takes in account the transformations (translation,
             rotation, scale, ...) that are applied to the entity.
             In other words, this function returns the bounds of the
             sprite in the global 2D world's coordinate system.
             </summary>
             <returns>Global bounding rectangle of the entity</returns>
        </member>
        <member name="M:SFML.Graphics.Sprite.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.Sprite.Draw(SFML.Graphics.RenderTarget,SFML.Graphics.RenderStates)">
            <summary>
            Draw the sprite to a render target
            </summary>
            <param name="target">Render target to draw to</param>
            <param name="states">Current render states</param>
        </member>
        <member name="M:SFML.Graphics.Sprite.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="T:SFML.Graphics.Text">
            <summary>
            This class defines a graphical 2D text, that can be drawn on screen
            </summary>
            <remarks>
            See also the note on coordinates and undistorted rendering in SFML.Graphics.Transformable.
            </remarks>
        </member>
        <member name="T:SFML.Graphics.Text.Styles">
            <summary>
            Enumerate the string drawing styles
            </summary>
        </member>
        <member name="F:SFML.Graphics.Text.Styles.Regular">
            <summary>Regular characters, no style</summary>
        </member>
        <member name="F:SFML.Graphics.Text.Styles.Bold">
            <summary>Bold characters</summary>
        </member>
        <member name="F:SFML.Graphics.Text.Styles.Italic">
            <summary>Italic characters</summary>
        </member>
        <member name="F:SFML.Graphics.Text.Styles.Underlined">
            <summary>Underlined characters</summary>
        </member>
        <member name="F:SFML.Graphics.Text.Styles.StrikeThrough">
            <summary>Strike through characters</summary>
        </member>
        <member name="M:SFML.Graphics.Text.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:SFML.Graphics.Text.#ctor(System.String,SFML.Graphics.Font)">
            <summary>
            Construct the text from a string and a font
            </summary>
            <param name="str">String to display</param>
            <param name="font">Font to use</param>
        </member>
        <member name="M:SFML.Graphics.Text.#ctor(System.String,SFML.Graphics.Font,System.UInt32)">
            <summary>
            Construct the text from a string, font and size
            </summary>
            <param name="str">String to display</param>
            <param name="font">Font to use</param>
            <param name="characterSize">Base characters size</param>
        </member>
        <member name="M:SFML.Graphics.Text.#ctor(SFML.Graphics.Text)">
            <summary>
            Construct the text from another text
            </summary>
            <param name="copy">Text to copy</param>
        </member>
        <member name="P:SFML.Graphics.Text.Color">
            <summary>
            Fill color of the object
            </summary>
            
            <remarks>
            Deprecated. Use <see cref="P:SFML.Graphics.Text.FillColor"/> instead.
            
            By default, the text's fill color is opaque white.
            Setting the fill color to a transparent color with an outline
            will cause the outline to be displayed in the fill area of the text.
            </remarks>
        </member>
        <member name="P:SFML.Graphics.Text.FillColor">
            <summary>
            Fill color of the object
            </summary>
            
            <remarks>
            By default, the text's fill color is opaque white.
            Setting the fill color to a transparent color with an outline
            will cause the outline to be displayed in the fill area of the text.
            </remarks>
        </member>
        <member name="P:SFML.Graphics.Text.OutlineColor">
            <summary>
            Outline color of the object
            </summary>
            
            <remarks>
            By default, the text's outline color is opaque black.
            </remarks>
        </member>
        <member name="P:SFML.Graphics.Text.OutlineThickness">
            <summary>
            Thickness of the object's outline
            </summary>
            
            <remarks>
            <para>By default, the outline thickness is 0.</para>
            <para>Be aware that using a negative value for the outline
            thickness will cause distorted rendering.</para>
            </remarks>
        </member>
        <member name="P:SFML.Graphics.Text.DisplayedString">
            <summary>
            String which is displayed
            </summary>
        </member>
        <member name="P:SFML.Graphics.Text.Font">
            <summary>
            Font used to display the text
            </summary>
        </member>
        <member name="P:SFML.Graphics.Text.CharacterSize">
            <summary>
            Base size of characters
            </summary>
        </member>
        <member name="P:SFML.Graphics.Text.LetterSpacing">
            <summary>
            Size of the letter spacing factor
            </summary>
        </member>
        <member name="P:SFML.Graphics.Text.LineSpacing">
            <summary>
            Size of the line spacing factor
            </summary>
        </member>
        <member name="P:SFML.Graphics.Text.Style">
            <summary>
            Style of the text (see Styles enum)
            </summary>
        </member>
        <member name="M:SFML.Graphics.Text.FindCharacterPos(System.UInt32)">
            <summary>
            Return the visual position of the Index-th character of the text,
            in coordinates relative to the text
            (note : translation, origin, rotation and scale are not applied)
            </summary>
            <param name="index">Index of the character</param>
            <returns>Position of the Index-th character (end of text if Index is out of range)</returns>
        </member>
        <member name="M:SFML.Graphics.Text.GetLocalBounds">
             <summary>
             Get the local bounding rectangle of the entity.
            
             The returned rectangle is in local coordinates, which means
             that it ignores the transformations (translation, rotation,
             scale, ...) that are applied to the entity.
             In other words, this function returns the bounds of the
             entity in the entity's coordinate system.
             </summary>
             <returns>Local bounding rectangle of the entity</returns>
        </member>
        <member name="M:SFML.Graphics.Text.GetGlobalBounds">
             <summary>
             Get the global bounding rectangle of the entity.
            
             The returned rectangle is in global coordinates, which means
             that it takes in account the transformations (translation,
             rotation, scale, ...) that are applied to the entity.
             In other words, this function returns the bounds of the
             sprite in the global 2D world's coordinate system.
             </summary>
             <returns>Global bounding rectangle of the entity</returns>
        </member>
        <member name="M:SFML.Graphics.Text.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.Text.Draw(SFML.Graphics.RenderTarget,SFML.Graphics.RenderStates)">
            <summary>
            Draw the text to a render target
            </summary>
            <param name="target">Render target to draw to</param>
            <param name="states">Current render states</param>
        </member>
        <member name="M:SFML.Graphics.Text.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="T:SFML.Graphics.Texture">
            <summary>
            Image living on the graphics card that can be used for drawing
            </summary>
        </member>
        <member name="M:SFML.Graphics.Texture.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Construct the texture
            </summary>
            <param name="width">Texture width</param>
            <param name="height">Texture height</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Texture.#ctor(System.String)">
            <summary>
            Construct the texture from a file
            </summary>
            <param name="filename">Path of the image file to load</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Texture.#ctor(System.String,SFML.Graphics.IntRect)">
            <summary>
            Construct the texture from a file
            </summary>
            <param name="filename">Path of the image file to load</param>
            <param name="area">Area of the image to load</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Texture.#ctor(System.IO.Stream)">
            <summary>
            Construct the texture from a file in a stream
            </summary>
            <param name="stream">Stream containing the file contents</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Texture.#ctor(System.IO.Stream,SFML.Graphics.IntRect)">
            <summary>
            Construct the texture from a file in a stream
            </summary>
            <param name="stream">Stream containing the file contents</param>
            <param name="area">Area of the image to load</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Texture.#ctor(SFML.Graphics.Image)">
            <summary>
            Construct the texture from an image
            </summary>
            <param name="image">Image to load to the texture</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Texture.#ctor(SFML.Graphics.Image,SFML.Graphics.IntRect)">
            <summary>
            Construct the texture from an image
            </summary>
            <param name="image">Image to load to the texture</param>
            <param name="area">Area of the image to load</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Texture.#ctor(System.Byte[])">
            <summary>
            Construct the texture from a file in memory
            </summary>
            <param name="bytes">Byte array containing the file contents</param>
            <exception cref="T:SFML.LoadingFailedException" />
        </member>
        <member name="M:SFML.Graphics.Texture.#ctor(SFML.Graphics.Texture)">
            <summary>
            Construct the texture from another texture
            </summary>
            <param name="copy">Texture to copy</param>
        </member>
        <member name="P:SFML.Graphics.Texture.NativeHandle">
            <summary>
            Get the underlying OpenGL handle of the texture.
            </summary>
            <remarks>
            You shouldn't need to use this handle, unless you have
            very specific stuff to implement that SFML doesn't support,
            or implement a temporary workaround until a bug is fixed.
            </remarks>
        </member>
        <member name="M:SFML.Graphics.Texture.CopyToImage">
            <summary>
            Copy a texture's pixels to an image
            </summary>
            <returns>Image containing the texture's pixels</returns>
        </member>
        <member name="M:SFML.Graphics.Texture.Update(System.Byte[])">
            <summary>
            Update a texture from an array of pixels
            </summary>
            <param name="pixels">Array of pixels to copy to the texture</param>
        </member>
        <member name="M:SFML.Graphics.Texture.Update(System.Byte[],System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Update a texture from an array of pixels
            </summary>
            <param name="pixels">Array of pixels to copy to the texture</param>
            <param name="width">Width of the pixel region contained in pixels</param>
            <param name="height">Height of the pixel region contained in pixels</param>
            <param name="x">X offset in the texture where to copy the source pixels</param>
            <param name="y">Y offset in the texture where to copy the source pixels</param>
        </member>
        <member name="M:SFML.Graphics.Texture.Update(SFML.Graphics.Texture,System.UInt32,System.UInt32)">
            <summary>
            Update a part of this texture from another texture
            </summary>
            <param name="texture">Source texture to copy to destination texture</param>
            <param name="x">X offset in this texture where to copy the source texture</param>
            <param name="y">Y offset in this texture where to copy the source texture</param>
        </member>
        <member name="M:SFML.Graphics.Texture.Update(SFML.Graphics.Image)">
            <summary>
            Update a texture from an image
            </summary>
            <param name="image">Image to copy to the texture</param>
        </member>
        <member name="M:SFML.Graphics.Texture.Update(SFML.Graphics.Image,System.UInt32,System.UInt32)">
            <summary>
            Update a texture from an image
            </summary>
            <param name="image">Image to copy to the texture</param>
            <param name="x">X offset in the texture where to copy the source pixels</param>
            <param name="y">Y offset in the texture where to copy the source pixels</param>
        </member>
        <member name="M:SFML.Graphics.Texture.Update(SFML.Window.Window)">
            <summary>
            Update a texture from the contents of a window
            </summary>
            <param name="window">Window to copy to the texture</param>
        </member>
        <member name="M:SFML.Graphics.Texture.Update(SFML.Window.Window,System.UInt32,System.UInt32)">
            <summary>
            Update a texture from the contents of a window
            </summary>
            <param name="window">Window to copy to the texture</param>
            <param name="x">X offset in the texture where to copy the source pixels</param>
            <param name="y">Y offset in the texture where to copy the source pixels</param>
        </member>
        <member name="M:SFML.Graphics.Texture.Update(SFML.Graphics.RenderWindow)">
            <summary>
            Update a texture from the contents of a render-window
            </summary>
            <param name="window">Render-window to copy to the texture</param>
        </member>
        <member name="M:SFML.Graphics.Texture.Update(SFML.Graphics.RenderWindow,System.UInt32,System.UInt32)">
            <summary>
            Update a texture from the contents of a render-window
            </summary>
            <param name="window">Render-window to copy to the texture</param>
            <param name="x">X offset in the texture where to copy the source pixels</param>
            <param name="y">Y offset in the texture where to copy the source pixels</param>
        </member>
        <member name="M:SFML.Graphics.Texture.GenerateMipmap">
             <summary>
             Generate a mipmap using the current texture data
             </summary>
             
             <remarks>
             <para>Mipmaps are pre-computed chains of optimized textures. Each
             level of texture in a mipmap is generated by halving each of
             the previous level's dimensions. This is done until the final
             level has the size of 1x1. The textures generated in this process may
             make use of more advanced filters which might improve the visual quality
             of textures when they are applied to objects much smaller than they are.
             This is known as minification. Because fewer texels (texture elements)
             have to be sampled from when heavily minified, usage of mipmaps
             can also improve rendering performance in certain scenarios.</para>
            
             <para>Mipmap generation relies on the necessary OpenGL extension being
             available. If it is unavailable or generation fails due to another
             reason, this function will return false. Mipmap data is only valid from
             the time it is generated until the next time the base level image is
             modified, at which point this function will have to be called again to
             regenerate it.</para>
             </remarks>
             
             <returns>True if mipmap generation was successful, false if unsuccessful</returns>
        </member>
        <member name="M:SFML.Graphics.Texture.Swap(SFML.Graphics.Texture)">
            <summary>
            Swap the contents of this texture with those of another
            </summary>
            <param name="right">Instance to swap with</param>
        </member>
        <member name="P:SFML.Graphics.Texture.Smooth">
            <summary>
            Control the smooth filter
            </summary>
        </member>
        <member name="P:SFML.Graphics.Texture.Srgb">
             <summary>
             Enable or disable conversion from sRGB
             </summary>
             
             <remarks>
             <para>When providing texture data from an image file or memory, it can
             either be stored in a linear color space or an sRGB color space.
             Most digital images account for gamma correction already, so they
             would need to be "uncorrected" back to linear color space before
             being processed by the hardware. The hardware can automatically
             convert it from the sRGB color space to a linear color space when
             it gets sampled. When the rendered image gets output to the final
             framebuffer, it gets converted back to sRGB.</para>
            
             <para>After enabling or disabling sRGB conversion, make sure to reload
             the texture data in order for the setting to take effect.</para>
            
             <para>This option is only useful in conjunction with an sRGB capable
             framebuffer. This can be requested during window creation.</para>
             </remarks>
        </member>
        <member name="P:SFML.Graphics.Texture.Repeated">
            <summary>
            Control the repeat mode
            </summary>
        </member>
        <member name="P:SFML.Graphics.Texture.Size">
            <summary>
            Size of the texture, in pixels
            </summary>
        </member>
        <member name="M:SFML.Graphics.Texture.Bind(SFML.Graphics.Texture)">
            <summary>
            Bind a texture for rendering
            </summary>
            <param name="texture">Shader to bind (can be null to use no texture)</param>
        </member>
        <member name="P:SFML.Graphics.Texture.MaximumSize">
            <summary>
            Maximum texture size allowed
            </summary>
        </member>
        <member name="M:SFML.Graphics.Texture.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.Texture.#ctor(System.IntPtr)">
            <summary>
            Internal constructor
            </summary>
            <param name="cPointer">Pointer to the object in C library</param>
        </member>
        <member name="M:SFML.Graphics.Texture.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="T:SFML.Graphics.Transform">
            <summary>
            Define a 3x3 transform matrix
            </summary>
        </member>
        <member name="M:SFML.Graphics.Transform.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Construct a transform from a 3x3 matrix
            </summary>
            <param name="a00">Element (0, 0) of the matrix</param>
            <param name="a01">Element (0, 1) of the matrix</param>
            <param name="a02">Element (0, 2) of the matrix</param>
            <param name="a10">Element (1, 0) of the matrix</param>
            <param name="a11">Element (1, 1) of the matrix</param>
            <param name="a12">Element (1, 2) of the matrix</param>
            <param name="a20">Element (2, 0) of the matrix</param>
            <param name="a21">Element (2, 1) of the matrix</param>
            <param name="a22">Element (2, 2) of the matrix</param>
        </member>
        <member name="M:SFML.Graphics.Transform.GetInverse">
            <summary>
            Return the inverse of the transform.
            
            If the inverse cannot be computed, an identity transform
            is returned.
            </summary>
            <returns>A new transform which is the inverse of self</returns>
        </member>
        <member name="M:SFML.Graphics.Transform.TransformPoint(System.Single,System.Single)">
            <summary>
            Transform a 2D point.
            </summary>
            <param name="x">X coordinate of the point to transform</param>
            <param name="y">Y coordinate of the point to transform</param>
            <returns>Transformed point</returns>
        </member>
        <member name="M:SFML.Graphics.Transform.TransformPoint(SFML.System.Vector2f)">
            <summary>
            Transform a 2D point.
            </summary>
            <param name="point">Point to transform</param>
            <returns>Transformed point</returns>
        </member>
        <member name="M:SFML.Graphics.Transform.TransformRect(SFML.Graphics.FloatRect)">
            <summary>
            Transform a rectangle.
            
            Since SFML doesn't provide support for oriented rectangles,
            the result of this function is always an axis-aligned
            rectangle. Which means that if the transform contains a
            rotation, the bounding rectangle of the transformed rectangle
            is returned.
            </summary>
            <param name="rectangle">Rectangle to transform</param>
            <returns>Transformed rectangle</returns>
        </member>
        <member name="M:SFML.Graphics.Transform.Combine(SFML.Graphics.Transform)">
            <summary>
            Combine the current transform with another one.
            
            The result is a transform that is equivalent to applying
            this followed by transform. Mathematically, it is
            equivalent to a matrix multiplication.
            </summary>
            <param name="transform">Transform to combine to this transform</param>
        </member>
        <member name="M:SFML.Graphics.Transform.Translate(System.Single,System.Single)">
            <summary>
            Combine the current transform with a translation.
            </summary>
            <param name="x">Offset to apply on X axis</param>
            <param name="y">Offset to apply on Y axis</param>
        </member>
        <member name="M:SFML.Graphics.Transform.Translate(SFML.System.Vector2f)">
            <summary>
            Combine the current transform with a translation.
            </summary>
            <param name="offset">Translation offset to apply</param>
        </member>
        <member name="M:SFML.Graphics.Transform.Rotate(System.Single)">
            <summary>
            Combine the current transform with a rotation.
            </summary>
            <param name="angle">Rotation angle, in degrees</param>
        </member>
        <member name="M:SFML.Graphics.Transform.Rotate(System.Single,System.Single,System.Single)">
            <summary>
            Combine the current transform with a rotation.
            
            The center of rotation is provided for convenience as a second
            argument, so that you can build rotations around arbitrary points
            more easily (and efficiently) than the usual
            Translate(-center); Rotate(angle); Translate(center).
            </summary>
            <param name="angle">Rotation angle, in degrees</param>
            <param name="centerX">X coordinate of the center of rotation</param>
            <param name="centerY">Y coordinate of the center of rotation</param>
        </member>
        <member name="M:SFML.Graphics.Transform.Rotate(System.Single,SFML.System.Vector2f)">
            <summary>
            Combine the current transform with a rotation.
            
            The center of rotation is provided for convenience as a second
            argument, so that you can build rotations around arbitrary points
            more easily (and efficiently) than the usual
            Translate(-center); Rotate(angle); Translate(center).
            </summary>
            <param name="angle">Rotation angle, in degrees</param>
            <param name="center">Center of rotation</param>
        </member>
        <member name="M:SFML.Graphics.Transform.Scale(System.Single,System.Single)">
            <summary>
            Combine the current transform with a scaling.
            </summary>
            <param name="scaleX">Scaling factor on the X axis</param>
            <param name="scaleY">Scaling factor on the Y axis</param>
        </member>
        <member name="M:SFML.Graphics.Transform.Scale(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Combine the current transform with a scaling.
            
            The center of scaling is provided for convenience as a second
            argument, so that you can build scaling around arbitrary points
            more easily (and efficiently) than the usual
            Translate(-center); Scale(factors); Translate(center).
            </summary>
            <param name="scaleX">Scaling factor on X axis</param>
            <param name="scaleY">Scaling factor on Y axis</param>
            <param name="centerX">X coordinate of the center of scaling</param>
            <param name="centerY">Y coordinate of the center of scaling</param>
        </member>
        <member name="M:SFML.Graphics.Transform.Scale(SFML.System.Vector2f)">
            <summary>
            Combine the current transform with a scaling.
            </summary>
            <param name="factors">Scaling factors</param>
        </member>
        <member name="M:SFML.Graphics.Transform.Scale(SFML.System.Vector2f,SFML.System.Vector2f)">
            <summary>
            Combine the current transform with a scaling.
            
            The center of scaling is provided for convenience as a second
            argument, so that you can build scaling around arbitrary points
            more easily (and efficiently) than the usual
            Translate(-center); Scale(factors); Translate(center).
            </summary>
            <param name="factors">Scaling factors</param>
            <param name="center">Center of scaling</param>
        </member>
        <member name="M:SFML.Graphics.Transform.Equals(System.Object)">
            <summary>
            Compare Transform and object and checks if they are equal
            </summary>
            <param name="obj">Object to check</param>
            <returns>Object and transform are equal</returns>
        </member>
        <member name="M:SFML.Graphics.Transform.Equals(SFML.Graphics.Transform)">
             <summary>
             Compare two transforms for equality
            
             Performs an element-wise comparison of the elements of this
             transform with the elements of the right transform.
             </summary>
             <param name="transform">Transform to check</param>
             <returns>Transforms are equal</returns>
        </member>
        <member name="M:SFML.Graphics.Transform.op_Multiply(SFML.Graphics.Transform,SFML.Graphics.Transform)">
            <summary>
            Overload of binary operator * to combine two transforms.
            This call is equivalent to calling new Transform(left).Combine(right).
            </summary>
            <param name="left">Left operand (the first transform)</param>
            <param name="right">Right operand (the second transform)</param>
            <returns>New combined transform</returns>
        </member>
        <member name="M:SFML.Graphics.Transform.op_Multiply(SFML.Graphics.Transform,SFML.System.Vector2f)">
            <summary>
            Overload of binary operator * to transform a point.
            This call is equivalent to calling left.TransformPoint(right).
            </summary>
            <param name="left">Left operand (the transform)</param>
            <param name="right">Right operand (the point to transform)</param>
            <returns>New transformed point</returns>
        </member>
        <member name="P:SFML.Graphics.Transform.Identity">
            <summary>The identity transform (does nothing)</summary>
        </member>
        <member name="M:SFML.Graphics.Transform.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.Transform.GetHashCode">
            <summary>Returns a hash code for this instance.</summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        </member>
        <member name="T:SFML.Graphics.Transformable">
            <summary>
            Decomposed transform defined by a position, a rotation and a scale
            </summary>
            <remarks>
            A note on coordinates and undistorted rendering:
            By default, SFML (or more exactly, OpenGL) may interpolate drawable objects
            such as sprites or texts when rendering. While this allows transitions
            like slow movements or rotations to appear smoothly, it can lead to
            unwanted results in some cases, for example blurred or distorted objects.
            In order to render a SFML.Graphics.Drawable object pixel-perfectly, make sure
            the involved coordinates allow a 1:1 mapping of pixels in the window
            to texels (pixels in the texture). More specifically, this means:
            * The object's position, origin and scale have no fractional part
            * The object's and the view's rotation are a multiple of 90 degrees
            * The view's center and size have no fractional part
            </remarks>
        </member>
        <member name="M:SFML.Graphics.Transformable.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:SFML.Graphics.Transformable.#ctor(SFML.Graphics.Transformable)">
            <summary>
            Construct the transformable from another transformable
            </summary>
            <param name="transformable">Transformable to copy</param>
        </member>
        <member name="P:SFML.Graphics.Transformable.Position">
            <summary>
            Position of the object
            </summary>
        </member>
        <member name="P:SFML.Graphics.Transformable.Rotation">
            <summary>
            Rotation of the object
            </summary>
        </member>
        <member name="P:SFML.Graphics.Transformable.Scale">
            <summary>
            Scale of the object
            </summary>
        </member>
        <member name="P:SFML.Graphics.Transformable.Origin">
            <summary>
            The origin of an object defines the center point for
            all transformations (position, scale, rotation).
            The coordinates of this point must be relative to the
            top-left corner of the object, and ignore all
            transformations (position, scale, rotation).
            </summary>
        </member>
        <member name="P:SFML.Graphics.Transformable.Transform">
            <summary>
            The combined transform of the object
            </summary>
        </member>
        <member name="P:SFML.Graphics.Transformable.InverseTransform">
            <summary>
            The combined transform of the object
            </summary>
        </member>
        <member name="M:SFML.Graphics.Transformable.#ctor(System.IntPtr)">
            <summary>
            Construct the object from its internal C pointer
            </summary>
            <param name="cPointer">Pointer to the object in the C library</param>
        </member>
        <member name="M:SFML.Graphics.Transformable.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="T:SFML.Graphics.Vertex">
            <summary>
            Define a point with color and texture coordinates
            </summary>
        </member>
        <member name="M:SFML.Graphics.Vertex.#ctor(SFML.System.Vector2f)">
            <summary>
            Construct the vertex from its position
            The vertex color is white and texture coordinates are (0, 0).
            </summary>
            <param name="position">Vertex position</param>
        </member>
        <member name="M:SFML.Graphics.Vertex.#ctor(SFML.System.Vector2f,SFML.Graphics.Color)">
            <summary>
            Construct the vertex from its position and color
            The texture coordinates are (0, 0).
            </summary>
            <param name="position">Vertex position</param>
            <param name="color">Vertex color</param>
        </member>
        <member name="M:SFML.Graphics.Vertex.#ctor(SFML.System.Vector2f,SFML.System.Vector2f)">
            <summary>
            Construct the vertex from its position and texture coordinates
            The vertex color is white.
            </summary>
            <param name="position">Vertex position</param>
            <param name="texCoords">Vertex texture coordinates</param>
        </member>
        <member name="M:SFML.Graphics.Vertex.#ctor(SFML.System.Vector2f,SFML.Graphics.Color,SFML.System.Vector2f)">
            <summary>
            Construct the vertex from its position, color and texture coordinates
            </summary>
            <param name="position">Vertex position</param>
            <param name="color">Vertex color</param>
            <param name="texCoords">Vertex texture coordinates</param>
        </member>
        <member name="M:SFML.Graphics.Vertex.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="F:SFML.Graphics.Vertex.Position">
            <summary>2D position of the vertex</summary>
        </member>
        <member name="F:SFML.Graphics.Vertex.Color">
            <summary>Color of the vertex</summary>
        </member>
        <member name="F:SFML.Graphics.Vertex.TexCoords">
            <summary>Coordinates of the texture's pixel to map to the vertex</summary>
        </member>
        <member name="T:SFML.Graphics.VertexArray">
            <summary>
            Define a set of one or more 2D primitives
            </summary>
        </member>
        <member name="M:SFML.Graphics.VertexArray.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:SFML.Graphics.VertexArray.#ctor(SFML.Graphics.PrimitiveType)">
            <summary>
            Construct the vertex array with a type
            </summary>
            <param name="type">Type of primitives</param>
        </member>
        <member name="M:SFML.Graphics.VertexArray.#ctor(SFML.Graphics.PrimitiveType,System.UInt32)">
            <summary>
            Construct the vertex array with a type and an initial number of vertices
            </summary>
            <param name="type">Type of primitives</param>
            <param name="vertexCount">Initial number of vertices in the array</param>
        </member>
        <member name="M:SFML.Graphics.VertexArray.#ctor(SFML.Graphics.VertexArray)">
            <summary>
            Construct the vertex array from another vertex array
            </summary>
            <param name="copy">Transformable to copy</param>
        </member>
        <member name="P:SFML.Graphics.VertexArray.VertexCount">
            <summary>
            Total vertex count
            </summary>
        </member>
        <member name="P:SFML.Graphics.VertexArray.Item(System.UInt32)">
             <summary>
             Read-write access to vertices by their index.
            
             This function doesn't check index, it must be in range
             [0, VertexCount - 1]. The behaviour is undefined
             otherwise.
             </summary>
             <param name="index">Index of the vertex to get</param>
             <returns>Reference to the index-th vertex</returns>
        </member>
        <member name="M:SFML.Graphics.VertexArray.Clear">
            <summary>
            Clear the vertex array
            </summary>
        </member>
        <member name="M:SFML.Graphics.VertexArray.Resize(System.UInt32)">
            <summary>
            Resize the vertex array
            
            If \a vertexCount is greater than the current size, the previous
            vertices are kept and new (default-constructed) vertices are
            added.
            If \a vertexCount is less than the current size, existing vertices
            are removed from the array.
            </summary>
            <param name="vertexCount">New size of the array (number of vertices)</param>
        </member>
        <member name="M:SFML.Graphics.VertexArray.Append(SFML.Graphics.Vertex)">
            <summary>
            Add a vertex to the array
            </summary>
            <param name="vertex">Vertex to add</param>
        </member>
        <member name="P:SFML.Graphics.VertexArray.PrimitiveType">
            <summary>
            Type of primitives to draw
            </summary>
        </member>
        <member name="P:SFML.Graphics.VertexArray.Bounds">
             <summary>
             Compute the bounding rectangle of the vertex array.
            
             This function returns the axis-aligned rectangle that
             contains all the vertices of the array.
             </summary>
        </member>
        <member name="M:SFML.Graphics.VertexArray.Draw(SFML.Graphics.RenderTarget,SFML.Graphics.RenderStates)">
            <summary>
            Draw the vertex array to a render target
            </summary>
            <param name="target">Render target to draw to</param>
            <param name="states">Current render states</param>
        </member>
        <member name="M:SFML.Graphics.VertexArray.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="T:SFML.Graphics.VertexBuffer">
            <summary>
              <br />
            </summary>
        </member>
        <member name="T:SFML.Graphics.VertexBuffer.UsageSpecifier">
             <summary>
             Usage specifiers
            
             If data is going to be updated once or more every frame,
             set the usage to Stream. If data is going
             to be set once and used for a long time without being
             modified, set the usage to Static.
             For everything else Dynamic should
             be a good compromise.
             </summary>
        </member>
        <member name="P:SFML.Graphics.VertexBuffer.Available">
             <summary>
             Whether or not the system supports vertex buffers
            
             This function should always be called before using
             the vertex buffer features. If it returns false, then
             any attempt to use sf::VertexBuffer will fail.
             </summary>
        </member>
        <member name="M:SFML.Graphics.VertexBuffer.#ctor(System.UInt32,SFML.Graphics.PrimitiveType,SFML.Graphics.VertexBuffer.UsageSpecifier)">
             <summary>
             Create a new vertex buffer with a specific
             PrimitiveType and usage specifier.
            
             Creates the vertex buffer, allocating enough graphcis
             memory to hold \p vertexCount vertices, and sets its
             primitive type to \p type and usage to \p usage.
             </summary>
             <param name="vertexCount">Amount of vertices</param>
             <param name="primitiveType">Type of primitives</param>
             <param name="usageType">Usage specifier</param>
        </member>
        <member name="M:SFML.Graphics.VertexBuffer.#ctor(SFML.Graphics.VertexBuffer)">
            <summary>
            Construct the vertex buffer from another vertex array
            </summary>
            <param name="copy">VertexBuffer to copy</param>
        </member>
        <member name="P:SFML.Graphics.VertexBuffer.VertexCount">
            <summary>
            Total vertex count
            </summary>
        </member>
        <member name="P:SFML.Graphics.VertexBuffer.NativeHandle">
            <summary>
            OpenGL handle of the vertex buffer or 0 if not yet created
            
            You shouldn't need to use this property, unless you have
            very specific stuff to implement that SFML doesn't support,
            or implement a temporary workaround until a bug is fixed.
            </summary>
        </member>
        <member name="P:SFML.Graphics.VertexBuffer.PrimitiveType">
            <summary>
            The type of primitives drawn by the vertex buffer
            </summary>
        </member>
        <member name="P:SFML.Graphics.VertexBuffer.Usage">
            <summary>
            The usage specifier for the vertex buffer
            </summary>
        </member>
        <member name="M:SFML.Graphics.VertexBuffer.Update(SFML.Graphics.Vertex[],System.UInt32,System.UInt32)">
             <summary>
             Update a part of the buffer from an array of vertices
             offset is specified as the number of vertices to skip
             from the beginning of the buffer.
            
             If offset is 0 and vertexCount is equal to the size of
             the currently created buffer, its whole contents are replaced.
            
             If offset is 0 and vertexCount is greater than the
             size of the currently created buffer, a new buffer is created
             containing the vertex data.
            
             If offset is 0 and vertexCount is less than the size of
             the currently created buffer, only the corresponding region
             is updated.
            
             If offset is not 0 and offset + vertexCount is greater
             than the size of the currently created buffer, the update fails.
            
             No additional check is performed on the size of the vertex
             array, passing invalid arguments will lead to undefined
             behavior.
             </summary>
             <param name="vertices">Array of vertices to copy to the buffer</param>
             <param name="vertexCount">Number of vertices to copy</param>
             <param name="offset">Offset in the buffer to copy to</param>
        </member>
        <member name="M:SFML.Graphics.VertexBuffer.Update(SFML.Graphics.Vertex[])">
             <summary>
             Update a part of the buffer from an array of vertices
             assuming an offset of 0 and a vertex count the length of the passed array.
            
             If offset is 0 and vertexCount is equal to the size of
             the currently created buffer, its whole contents are replaced.
            
             If offset is 0 and vertexCount is greater than the
             size of the currently created buffer, a new buffer is created
             containing the vertex data.
            
             If offset is 0 and vertexCount is less than the size of
             the currently created buffer, only the corresponding region
             is updated.
            
             If offset is not 0 and offset + vertexCount is greater
             than the size of the currently created buffer, the update fails.
            
             No additional check is performed on the size of the vertex
             array, passing invalid arguments will lead to undefined
             behavior.
             </summary>
             <param name="vertices">Array of vertices to copy to the buffer</param>
        </member>
        <member name="M:SFML.Graphics.VertexBuffer.Update(SFML.Graphics.Vertex[],System.UInt32)">
             <summary>
             Update a part of the buffer from an array of vertices
             assuming a vertex count the length of the passed array.
            
             If offset is 0 and vertexCount is equal to the size of
             the currently created buffer, its whole contents are replaced.
            
             If offset is 0 and vertexCount is greater than the
             size of the currently created buffer, a new buffer is created
             containing the vertex data.
            
             If offset is 0 and vertexCount is less than the size of
             the currently created buffer, only the corresponding region
             is updated.
            
             If offset is not 0 and offset + vertexCount is greater
             than the size of the currently created buffer, the update fails.
            
             No additional check is performed on the size of the vertex
             array, passing invalid arguments will lead to undefined
             behavior.
             </summary>
             <param name="vertices">Array of vertices to copy to the buffer</param>
             <param name="offset">Offset in the buffer to copy to</param>
        </member>
        <member name="M:SFML.Graphics.VertexBuffer.Update(SFML.Graphics.VertexBuffer)">
            <summary>
            Copy the contents of another buffer into this buffer
            </summary>
            <param name="other">Vertex buffer whose contents to copy into first vertex buffer</param>
        </member>
        <member name="M:SFML.Graphics.VertexBuffer.Swap(SFML.Graphics.VertexBuffer)">
            <summary>
            Swap the contents of another buffer into this buffer
            </summary>
            <param name="other">Vertex buffer whose contents to swap with</param>
        </member>
        <member name="M:SFML.Graphics.VertexBuffer.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="M:SFML.Graphics.VertexBuffer.Draw(SFML.Graphics.RenderTarget,SFML.Graphics.RenderStates)">
            <summary>
            Draw the vertex buffer to a render target
            </summary>
            <param name="target">Render target to draw to</param>
            <param name="states">Current render states</param>
        </member>
        <member name="T:SFML.Graphics.View">
            <summary>
            This class defines a view (position, size, etc.) ;
            you can consider it as a 2D camera
            </summary>
            <remarks>
            See also the note on coordinates and undistorted rendering in SFML.Graphics.Transformable.
            </remarks>
        </member>
        <member name="M:SFML.Graphics.View.#ctor">
            <summary>
            Create a default view (1000x1000)
            </summary>
        </member>
        <member name="M:SFML.Graphics.View.#ctor(SFML.Graphics.FloatRect)">
            <summary>
            Construct the view from a rectangle
            </summary>
            <param name="viewRect">Rectangle defining the position and size of the view</param>
        </member>
        <member name="M:SFML.Graphics.View.#ctor(SFML.System.Vector2f,SFML.System.Vector2f)">
            <summary>
            Construct the view from its center and size
            </summary>
            <param name="center">Center of the view</param>
            <param name="size">Size of the view</param>
        </member>
        <member name="M:SFML.Graphics.View.#ctor(SFML.Graphics.View)">
            <summary>
            Construct the view from another view
            </summary>
            <param name="copy">View to copy</param>
        </member>
        <member name="P:SFML.Graphics.View.Center">
            <summary>
            Center of the view
            </summary>
        </member>
        <member name="P:SFML.Graphics.View.Size">
            <summary>
            Half-size of the view
            </summary>
        </member>
        <member name="P:SFML.Graphics.View.Rotation">
            <summary>
            Rotation of the view, in degrees
            </summary>
        </member>
        <member name="P:SFML.Graphics.View.Viewport">
            <summary>
            Target viewport of the view, defined as a factor of the
            size of the target to which the view is applied
            </summary>
        </member>
        <member name="M:SFML.Graphics.View.Reset(SFML.Graphics.FloatRect)">
            <summary>
            Rebuild the view from a rectangle
            </summary>
            <param name="rectangle">Rectangle defining the position and size of the view</param>
        </member>
        <member name="M:SFML.Graphics.View.Move(SFML.System.Vector2f)">
            <summary>
            Move the view
            </summary>
            <param name="offset">Offset to move the view</param>
        </member>
        <member name="M:SFML.Graphics.View.Rotate(System.Single)">
            <summary>
            Rotate the view
            </summary>
            <param name="angle">Angle of rotation, in degrees</param>
        </member>
        <member name="M:SFML.Graphics.View.Zoom(System.Single)">
            <summary>
            Resize the view rectangle to simulate a zoom / unzoom effect
            </summary>
            <param name="factor">Zoom factor to apply, relative to the current zoom</param>
        </member>
        <member name="M:SFML.Graphics.View.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Graphics.View.#ctor(System.IntPtr)">
            <summary>
            Internal constructor for other classes which need to manipulate raw views
            </summary>
            <param name="cPointer">Direct pointer to the view object in the C library</param>
        </member>
        <member name="M:SFML.Graphics.View.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="T:SFML.System.Clock">
            <summary>
            Utility class that measures the elapsed time
            </summary>
        </member>
        <member name="M:SFML.System.Clock.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:SFML.System.Clock.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="P:SFML.System.Clock.ElapsedTime">
            <summary>
            Gets the time elapsed since the last call to Restart
            </summary>
        </member>
        <member name="M:SFML.System.Clock.Restart">
            <summary>
            This function puts the time counter back to zero.
            </summary>
            <returns>Time elapsed since the clock was started.</returns>
        </member>
        <member name="T:SFML.System.LoadingFailedException">
            <summary>
            Exception thrown by SFML whenever loading a resource fails
            </summary>
        </member>
        <member name="M:SFML.System.LoadingFailedException.#ctor">
            <summary>
            Default constructor (unknown error)
            </summary>
        </member>
        <member name="M:SFML.System.LoadingFailedException.#ctor(System.String)">
            <summary>
            Failure to load a resource from memory
            </summary>
            <param name="resourceName">Name of the resource</param>
        </member>
        <member name="M:SFML.System.LoadingFailedException.#ctor(System.String,System.Exception)">
            <summary>
            Failure to load a resource from memory
            </summary>
            <param name="resourceName">Name of the resource</param>
            <param name="innerException">Exception which is the cause ofthe current exception</param>
        </member>
        <member name="M:SFML.System.LoadingFailedException.#ctor(System.String,System.String)">
            <summary>
            Failure to load a resource from a file
            </summary>
            <param name="resourceName">Name of the resource</param>
            <param name="filename">Path of the file</param>
        </member>
        <member name="M:SFML.System.LoadingFailedException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Failure to load a resource from a file
            </summary>
            <param name="resourceName">Name of the resource</param>
            <param name="filename">Path of the file</param>
            <param name="innerException">Exception which is the cause ofthe current exception</param>
        </member>
        <member name="M:SFML.System.LoadingFailedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initialize an instance of the exception with serialized data
            </summary>
            <param name="info">Serialized data</param>
            <param name="context">Contextual informations</param>
        </member>
        <member name="F:SFML.System.CSFML.audio">
            <summary>Gets the audio.</summary>
            <value>The audio.</value>
        </member>
        <member name="F:SFML.System.CSFML.graphics">
            <summary>The graphics</summary>
        </member>
        <member name="F:SFML.System.CSFML.system">
            <summary>The system</summary>
        </member>
        <member name="F:SFML.System.CSFML.window">
            <summary>The window</summary>
        </member>
        <member name="T:SFML.System.InputStream">
            <summary>
            Structure that contains InputStream callbacks
            (directly maps to a CSFML sfInputStream)
            </summary>
        </member>
        <member name="T:SFML.System.InputStream.ReadCallbackType">
            <summary>
            Type of callback to read data from the current stream
            </summary>
        </member>
        <member name="T:SFML.System.InputStream.SeekCallbackType">
            <summary>
            Type of callback to seek the current stream's position
            </summary>
        </member>
        <member name="T:SFML.System.InputStream.TellCallbackType">
            <summary>
            Type of callback to return the current stream's position
            </summary>
        </member>
        <member name="T:SFML.System.InputStream.GetSizeCallbackType">
            <summary>
            Type of callback to return the current stream's size
            </summary>
        </member>
        <member name="F:SFML.System.InputStream.Read">
            <summary>
            Function that is called to read data from the stream
            </summary>
        </member>
        <member name="F:SFML.System.InputStream.Seek">
            <summary>
            Function that is called to seek the stream
            </summary>
        </member>
        <member name="F:SFML.System.InputStream.Tell">
            <summary>
            Function that is called to return the positon
            </summary>
        </member>
        <member name="F:SFML.System.InputStream.GetSize">
            <summary>
            Function that is called to return the size
            </summary>
        </member>
        <member name="T:SFML.System.StreamAdaptor">
            <summary>
            Adapts a System.IO.Stream to be usable as a SFML InputStream
            </summary>
        </member>
        <member name="M:SFML.System.StreamAdaptor.#ctor(System.IO.Stream)">
            <summary>
            Construct from a System.IO.Stream
            </summary>
            <param name="stream">Stream to adapt</param>
        </member>
        <member name="M:SFML.System.StreamAdaptor.Finalize">
            <summary>
            Dispose the object
            </summary>
        </member>
        <member name="P:SFML.System.StreamAdaptor.InputStreamPtr">
            <summary>
            The pointer to the CSFML InputStream structure
            </summary>
        </member>
        <member name="M:SFML.System.StreamAdaptor.Dispose">
            <summary>
            Explicitly dispose the object
            </summary>
        </member>
        <member name="M:SFML.System.StreamAdaptor.Dispose(System.Boolean)">
            <summary>
            Destroy the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="M:SFML.System.StreamAdaptor.Read(System.IntPtr,System.Int64,System.IntPtr)">
            <summary>
            Called to read from the stream
            </summary>
            <param name="data">Where to copy the read bytes</param>
            <param name="size">Size to read, in bytes</param>
            <param name="userData">User data -- unused</param>
            <returns>Number of bytes read</returns>
        </member>
        <member name="M:SFML.System.StreamAdaptor.Seek(System.Int64,System.IntPtr)">
            <summary>
            Called to set the read position in the stream
            </summary>
            <param name="position">New read position</param>
            <param name="userData">User data -- unused</param>
            <returns>Actual position</returns>
        </member>
        <member name="M:SFML.System.StreamAdaptor.Tell(System.IntPtr)">
            <summary>
            Get the current read position in the stream
            </summary>
            <param name="userData">User data -- unused</param>
            <returns>Current position in the stream</returns>
        </member>
        <member name="M:SFML.System.StreamAdaptor.GetSize(System.IntPtr)">
            <summary>
            Called to get the total size of the stream
            </summary>
            <param name="userData">User data -- unused</param>
            <returns>Number of bytes in the stream</returns>
        </member>
        <member name="T:SFML.System.Time">
            <summary>
            This class represents a time value
            </summary>
        </member>
        <member name="F:SFML.System.Time.Zero">
            <summary>
            Predefined "zero" time value
            </summary>
        </member>
        <member name="M:SFML.System.Time.FromSeconds(System.Single)">
            <summary>
            Construct a time value from a number of seconds
            </summary>
            <param name="seconds">Number of seconds</param>
            <returns>Time value constructed from the amount of seconds</returns>
        </member>
        <member name="M:SFML.System.Time.FromMilliseconds(System.Int32)">
            <summary>
            Construct a time value from a number of milliseconds
            </summary>
            <param name="milliseconds">Number of milliseconds</param>
            <returns>Time value constructed from the amount of milliseconds</returns>
        </member>
        <member name="M:SFML.System.Time.FromMicroseconds(System.Int64)">
            <summary>
            Construct a time value from a number of microseconds
            </summary>
            <param name="microseconds">Number of microseconds</param>
            <returns>Time value constructed from the amount of microseconds</returns>
        </member>
        <member name="M:SFML.System.Time.AsSeconds">
            <summary>
            Returns the time value as a number of seconds
            </summary>
        </member>
        <member name="M:SFML.System.Time.AsMilliseconds">
            <summary>
            Returns the time value as a number of milliseconds
            </summary>
        </member>
        <member name="M:SFML.System.Time.AsMicroseconds">
            <summary>
            Returns the time value as a number of microseconds
            </summary>
        </member>
        <member name="M:SFML.System.Time.op_Equality(SFML.System.Time,SFML.System.Time)">
            <summary>
            Compare two times and checks if they are equal
            </summary>
            <returns>Times are equal</returns>
        </member>
        <member name="M:SFML.System.Time.op_Inequality(SFML.System.Time,SFML.System.Time)">
            <summary>
            Compare two times and checks if they are not equal
            </summary>
            <returns>Times are not equal</returns>
        </member>
        <member name="M:SFML.System.Time.Equals(System.Object)">
            <summary>
            Compare time and object and checks if they are equal
            </summary>
            <param name="obj">Object to check</param>
            <returns>Object and time are equal</returns>
        </member>
        <member name="M:SFML.System.Time.Equals(SFML.System.Time)">
            <summary>
            Compare two times and checks if they are equal
            </summary>
            <param name="other">Time to check</param>
            <returns>times are equal</returns>
        </member>
        <member name="M:SFML.System.Time.op_LessThan(SFML.System.Time,SFML.System.Time)">
            <summary>
            Overload of &lt; operator to compare two time values
            </summary>
            <returns>True if left is lesser than right</returns>
        </member>
        <member name="M:SFML.System.Time.op_LessThanOrEqual(SFML.System.Time,SFML.System.Time)">
            <summary>
            Overload of &lt;= operator to compare two time values
            </summary>
            <returns>True if left is lesser or equal than right</returns>
        </member>
        <member name="M:SFML.System.Time.op_GreaterThan(SFML.System.Time,SFML.System.Time)">
            <summary>
            Overload of &gt; operator to compare two time values
            </summary>
            <returns>True if left is greater than right</returns>
        </member>
        <member name="M:SFML.System.Time.op_GreaterThanOrEqual(SFML.System.Time,SFML.System.Time)">
            <summary>
            Overload of &gt;= operator to compare two time values
            </summary>
            <returns>True if left is greater or equal than right</returns>
        </member>
        <member name="M:SFML.System.Time.op_Subtraction(SFML.System.Time,SFML.System.Time)">
            <summary>
            Overload of binary - operator to subtract two time values
            </summary>
            <returns>Difference of the two times values</returns>
        </member>
        <member name="M:SFML.System.Time.op_Addition(SFML.System.Time,SFML.System.Time)">
            <summary>
            Overload of binary + operator to add two time values
            </summary>
            <returns>Sum of the two times values</returns>
        </member>
        <member name="M:SFML.System.Time.op_Multiply(SFML.System.Time,System.Single)">
            <summary>
            Overload of binary * operator to scale a time value
            </summary>
            <returns>left multiplied by the right</returns>
        </member>
        <member name="M:SFML.System.Time.op_Multiply(SFML.System.Time,System.Int64)">
            <summary>
            Overload of binary * operator to scale a time value
            </summary>
            <returns>left multiplied by the right</returns>
        </member>
        <member name="M:SFML.System.Time.op_Multiply(System.Single,SFML.System.Time)">
            <summary>
            Overload of binary * operator to scale a time value
            </summary>
            <returns>left multiplied by the right</returns>
        </member>
        <member name="M:SFML.System.Time.op_Multiply(System.Int64,SFML.System.Time)">
            <summary>
            Overload of binary * operator to scale a time value
            </summary>
            <returns>left multiplied by the right</returns>
        </member>
        <member name="M:SFML.System.Time.op_Division(SFML.System.Time,SFML.System.Time)">
            <summary>
            Overload of binary / operator to scale a time value
            </summary>
            <returns>left divided by the right</returns>
        </member>
        <member name="M:SFML.System.Time.op_Division(SFML.System.Time,System.Single)">
            <summary>
            Overload of binary / operator to scale a time value
            </summary>
            <returns>left divided by the right</returns>
        </member>
        <member name="M:SFML.System.Time.op_Division(SFML.System.Time,System.Int64)">
            <summary>
            Overload of binary / operator to scale a time value
            </summary>
            <returns>left divided by the right</returns>
        </member>
        <member name="M:SFML.System.Time.op_Modulus(SFML.System.Time,SFML.System.Time)">
            <summary>
            Overload of binary % operator to compute remainder of a time value
            </summary>
            <returns>left modulo of right</returns>
        </member>
        <member name="M:SFML.System.Time.GetHashCode">
            <summary>
            Provide a integer describing the object
            </summary>
            <returns>Integer description of the object</returns>
        </member>
        <member name="T:SFML.System.Vector2f">
            <summary>
            Vector2f is an utility class for manipulating 2 dimensional
            vectors with float components
            </summary>
        </member>
        <member name="M:SFML.System.Vector2f.#ctor(System.Single,System.Single)">
            <summary>
            Construct the vector from its coordinates
            </summary>
            <param name="x">X coordinate</param>
            <param name="y">Y coordinate</param>
        </member>
        <member name="M:SFML.System.Vector2f.op_UnaryNegation(SFML.System.Vector2f)">
            <summary>
            Operator - overload ; returns the opposite of a vector
            </summary>
            <param name="v">Vector to negate</param>
            <returns>-v</returns>
        </member>
        <member name="M:SFML.System.Vector2f.op_Subtraction(SFML.System.Vector2f,SFML.System.Vector2f)">
            <summary>
            Operator - overload ; subtracts two vectors
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 - v2</returns>
        </member>
        <member name="M:SFML.System.Vector2f.op_Addition(SFML.System.Vector2f,SFML.System.Vector2f)">
            <summary>
            Operator + overload ; add two vectors
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 + v2</returns>
        </member>
        <member name="M:SFML.System.Vector2f.op_Multiply(SFML.System.Vector2f,System.Single)">
            <summary>
            Operator * overload ; multiply a vector by a scalar value
            </summary>
            <param name="v">Vector</param>
            <param name="x">Scalar value</param>
            <returns>v * x</returns>
        </member>
        <member name="M:SFML.System.Vector2f.op_Multiply(System.Single,SFML.System.Vector2f)">
            <summary>
            Operator * overload ; multiply a scalar value by a vector
            </summary>
            <param name="x">Scalar value</param>
            <param name="v">Vector</param>
            <returns>x * v</returns>
        </member>
        <member name="M:SFML.System.Vector2f.op_Division(SFML.System.Vector2f,System.Single)">
            <summary>
            Operator / overload ; divide a vector by a scalar value
            </summary>
            <param name="v">Vector</param>
            <param name="x">Scalar value</param>
            <returns>v / x</returns>
        </member>
        <member name="M:SFML.System.Vector2f.op_Equality(SFML.System.Vector2f,SFML.System.Vector2f)">
            <summary>
            Operator == overload ; check vector equality
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 == v2</returns>
        </member>
        <member name="M:SFML.System.Vector2f.op_Inequality(SFML.System.Vector2f,SFML.System.Vector2f)">
            <summary>
            Operator != overload ; check vector inequality
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 != v2</returns>
        </member>
        <member name="M:SFML.System.Vector2f.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.System.Vector2f.Equals(System.Object)">
            <summary>
            Compare vector and object and checks if they are equal
            </summary>
            <param name="obj">Object to check</param>
            <returns>Object and vector are equal</returns>
        </member>
        <member name="M:SFML.System.Vector2f.Equals(SFML.System.Vector2f)">
            <summary>
            Compare two vectors and checks if they are equal
            </summary>
            <param name="other">Vector to check</param>
            <returns>Vectors are equal</returns>
        </member>
        <member name="M:SFML.System.Vector2f.GetHashCode">
            <summary>
            Provide a integer describing the object
            </summary>
            <returns>Integer description of the object</returns>
        </member>
        <member name="M:SFML.System.Vector2f.op_Explicit(SFML.System.Vector2f)~SFML.System.Vector2i">
            <summary>
            Explicit casting to another vector type
            </summary>
            <param name="v">Vector being casted</param>
            <returns>Casting result</returns>
        </member>
        <member name="M:SFML.System.Vector2f.op_Explicit(SFML.System.Vector2f)~SFML.System.Vector2u">
            <summary>
            Explicit casting to another vector type
            </summary>
            <param name="v">Vector being casted</param>
            <returns>Casting result</returns>
        </member>
        <member name="F:SFML.System.Vector2f.X">
            <summary>X (horizontal) component of the vector</summary>
        </member>
        <member name="F:SFML.System.Vector2f.Y">
            <summary>Y (vertical) component of the vector</summary>
        </member>
        <member name="T:SFML.System.Vector2i">
            <summary>
            Vector2i is an utility class for manipulating 2 dimensional
            vectors with integer components
            </summary>
        </member>
        <member name="M:SFML.System.Vector2i.#ctor(System.Int32,System.Int32)">
            <summary>
            Construct the vector from its coordinates
            </summary>
            <param name="x">X coordinate</param>
            <param name="y">Y coordinate</param>
        </member>
        <member name="M:SFML.System.Vector2i.op_UnaryNegation(SFML.System.Vector2i)">
            <summary>
            Operator - overload ; returns the opposite of a vector
            </summary>
            <param name="v">Vector to negate</param>
            <returns>-v</returns>
        </member>
        <member name="M:SFML.System.Vector2i.op_Subtraction(SFML.System.Vector2i,SFML.System.Vector2i)">
            <summary>
            Operator - overload ; subtracts two vectors
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 - v2</returns>
        </member>
        <member name="M:SFML.System.Vector2i.op_Addition(SFML.System.Vector2i,SFML.System.Vector2i)">
            <summary>
            Operator + overload ; add two vectors
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 + v2</returns>
        </member>
        <member name="M:SFML.System.Vector2i.op_Multiply(SFML.System.Vector2i,System.Int32)">
            <summary>
            Operator * overload ; multiply a vector by a scalar value
            </summary>
            <param name="v">Vector</param>
            <param name="x">Scalar value</param>
            <returns>v * x</returns>
        </member>
        <member name="M:SFML.System.Vector2i.op_Multiply(System.Int32,SFML.System.Vector2i)">
            <summary>
            Operator * overload ; multiply a scalar value by a vector
            </summary>
            <param name="x">Scalar value</param>
            <param name="v">Vector</param>
            <returns>x * v</returns>
        </member>
        <member name="M:SFML.System.Vector2i.op_Division(SFML.System.Vector2i,System.Int32)">
            <summary>
            Operator / overload ; divide a vector by a scalar value
            </summary>
            <param name="v">Vector</param>
            <param name="x">Scalar value</param>
            <returns>v / x</returns>
        </member>
        <member name="M:SFML.System.Vector2i.op_Equality(SFML.System.Vector2i,SFML.System.Vector2i)">
            <summary>
            Operator == overload ; check vector equality
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 == v2</returns>
        </member>
        <member name="M:SFML.System.Vector2i.op_Inequality(SFML.System.Vector2i,SFML.System.Vector2i)">
            <summary>
            Operator != overload ; check vector inequality
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 != v2</returns>
        </member>
        <member name="M:SFML.System.Vector2i.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.System.Vector2i.Equals(System.Object)">
            <summary>
            Compare vector and object and checks if they are equal
            </summary>
            <param name="obj">Object to check</param>
            <returns>Object and vector are equal</returns>
        </member>
        <member name="M:SFML.System.Vector2i.Equals(SFML.System.Vector2i)">
            <summary>
            Compare two vectors and checks if they are equal
            </summary>
            <param name="other">Vector to check</param>
            <returns>Vectors are equal</returns>
        </member>
        <member name="M:SFML.System.Vector2i.GetHashCode">
            <summary>
            Provide a integer describing the object
            </summary>
            <returns>Integer description of the object</returns>
        </member>
        <member name="M:SFML.System.Vector2i.op_Explicit(SFML.System.Vector2i)~SFML.System.Vector2f">
            <summary>
            Explicit casting to another vector type
            </summary>
            <param name="v">Vector being casted</param>
            <returns>Casting result</returns>
        </member>
        <member name="M:SFML.System.Vector2i.op_Explicit(SFML.System.Vector2i)~SFML.System.Vector2u">
            <summary>
            Explicit casting to another vector type
            </summary>
            <param name="v">Vector being casted</param>
            <returns>Casting result</returns>
        </member>
        <member name="F:SFML.System.Vector2i.X">
            <summary>X (horizontal) component of the vector</summary>
        </member>
        <member name="F:SFML.System.Vector2i.Y">
            <summary>Y (vertical) component of the vector</summary>
        </member>
        <member name="T:SFML.System.Vector2u">
            <summary>
            Vector2u is an utility class for manipulating 2 dimensional
            vectors with unsigned integer components
            </summary>
        </member>
        <member name="M:SFML.System.Vector2u.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Construct the vector from its coordinates
            </summary>
            <param name="x">X coordinate</param>
            <param name="y">Y coordinate</param>
        </member>
        <member name="M:SFML.System.Vector2u.op_Subtraction(SFML.System.Vector2u,SFML.System.Vector2u)">
            <summary>
            Operator - overload ; subtracts two vectors
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 - v2</returns>
        </member>
        <member name="M:SFML.System.Vector2u.op_Addition(SFML.System.Vector2u,SFML.System.Vector2u)">
            <summary>
            Operator + overload ; add two vectors
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 + v2</returns>
        </member>
        <member name="M:SFML.System.Vector2u.op_Multiply(SFML.System.Vector2u,System.UInt32)">
            <summary>
            Operator * overload ; multiply a vector by a scalar value
            </summary>
            <param name="v">Vector</param>
            <param name="x">Scalar value</param>
            <returns>v * x</returns>
        </member>
        <member name="M:SFML.System.Vector2u.op_Multiply(System.UInt32,SFML.System.Vector2u)">
            <summary>
            Operator * overload ; multiply a scalar value by a vector
            </summary>
            <param name="x">Scalar value</param>
            <param name="v">Vector</param>
            <returns>x * v</returns>
        </member>
        <member name="M:SFML.System.Vector2u.op_Division(SFML.System.Vector2u,System.UInt32)">
            <summary>
            Operator / overload ; divide a vector by a scalar value
            </summary>
            <param name="v">Vector</param>
            <param name="x">Scalar value</param>
            <returns>v / x</returns>
        </member>
        <member name="M:SFML.System.Vector2u.op_Equality(SFML.System.Vector2u,SFML.System.Vector2u)">
            <summary>
            Operator == overload ; check vector equality
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 == v2</returns>
        </member>
        <member name="M:SFML.System.Vector2u.op_Inequality(SFML.System.Vector2u,SFML.System.Vector2u)">
            <summary>
            Operator != overload ; check vector inequality
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 != v2</returns>
        </member>
        <member name="M:SFML.System.Vector2u.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.System.Vector2u.Equals(System.Object)">
            <summary>
            Compare vector and object and checks if they are equal
            </summary>
            <param name="obj">Object to check</param>
            <returns>Object and vector are equal</returns>
        </member>
        <member name="M:SFML.System.Vector2u.Equals(SFML.System.Vector2u)">
            <summary>
            Compare two vectors and checks if they are equal
            </summary>
            <param name="other">Vector to check</param>
            <returns>Vectors are equal</returns>
        </member>
        <member name="M:SFML.System.Vector2u.GetHashCode">
            <summary>
            Provide a integer describing the object
            </summary>
            <returns>Integer description of the object</returns>
        </member>
        <member name="M:SFML.System.Vector2u.op_Explicit(SFML.System.Vector2u)~SFML.System.Vector2i">
            <summary>
            Explicit casting to another vector type
            </summary>
            <param name="v">Vector being casted</param>
            <returns>Casting result</returns>
        </member>
        <member name="M:SFML.System.Vector2u.op_Explicit(SFML.System.Vector2u)~SFML.System.Vector2f">
            <summary>
            Explicit casting to another vector type
            </summary>
            <param name="v">Vector being casted</param>
            <returns>Casting result</returns>
        </member>
        <member name="F:SFML.System.Vector2u.X">
            <summary>X (horizontal) component of the vector</summary>
        </member>
        <member name="F:SFML.System.Vector2u.Y">
            <summary>Y (vertical) component of the vector</summary>
        </member>
        <member name="T:SFML.System.Vector3f">
            <summary>
            Vector3f is an utility class for manipulating 3 dimensional
            vectors with float components
            </summary>
        </member>
        <member name="M:SFML.System.Vector3f.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Construct the vector from its coordinates
            </summary>
            <param name="x">X coordinate</param>
            <param name="y">Y coordinate</param>
            <param name="z">Z coordinate</param>
        </member>
        <member name="M:SFML.System.Vector3f.op_UnaryNegation(SFML.System.Vector3f)">
            <summary>
            Operator - overload ; returns the opposite of a vector
            </summary>
            <param name="v">Vector to negate</param>
            <returns>-v</returns>
        </member>
        <member name="M:SFML.System.Vector3f.op_Subtraction(SFML.System.Vector3f,SFML.System.Vector3f)">
            <summary>
            Operator - overload ; subtracts two vectors
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 - v2</returns>
        </member>
        <member name="M:SFML.System.Vector3f.op_Addition(SFML.System.Vector3f,SFML.System.Vector3f)">
            <summary>
            Operator + overload ; add two vectors
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 + v2</returns>
        </member>
        <member name="M:SFML.System.Vector3f.op_Multiply(SFML.System.Vector3f,System.Single)">
            <summary>
            Operator * overload ; multiply a vector by a scalar value
            </summary>
            <param name="v">Vector</param>
            <param name="x">Scalar value</param>
            <returns>v * x</returns>
        </member>
        <member name="M:SFML.System.Vector3f.op_Multiply(System.Single,SFML.System.Vector3f)">
            <summary>
            Operator * overload ; multiply a scalar value by a vector
            </summary>
            <param name="x">Scalar value</param>
            <param name="v">Vector</param>
            <returns>x * v</returns>
        </member>
        <member name="M:SFML.System.Vector3f.op_Division(SFML.System.Vector3f,System.Single)">
            <summary>
            Operator / overload ; divide a vector by a scalar value
            </summary>
            <param name="v">Vector</param>
            <param name="x">Scalar value</param>
            <returns>v / x</returns>
        </member>
        <member name="M:SFML.System.Vector3f.op_Equality(SFML.System.Vector3f,SFML.System.Vector3f)">
            <summary>
            Operator == overload ; check vector equality
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 == v2</returns>
        </member>
        <member name="M:SFML.System.Vector3f.op_Inequality(SFML.System.Vector3f,SFML.System.Vector3f)">
            <summary>
            Operator != overload ; check vector inequality
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>v1 != v2</returns>
        </member>
        <member name="M:SFML.System.Vector3f.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.System.Vector3f.Equals(System.Object)">
            <summary>
            Compare vector and object and checks if they are equal
            </summary>
            <param name="obj">Object to check</param>
            <returns>Object and vector are equal</returns>
        </member>
        <member name="M:SFML.System.Vector3f.Equals(SFML.System.Vector3f)">
            <summary>
            Compare two vectors and checks if they are equal
            </summary>
            <param name="other">Vector to check</param>
            <returns>Vectors are equal</returns>
        </member>
        <member name="M:SFML.System.Vector3f.GetHashCode">
            <summary>
            Provide a integer describing the object
            </summary>
            <returns>Integer description of the object</returns>
        </member>
        <member name="F:SFML.System.Vector3f.X">
            <summary>X (horizontal) component of the vector</summary>
        </member>
        <member name="F:SFML.System.Vector3f.Y">
            <summary>Y (vertical) component of the vector</summary>
        </member>
        <member name="F:SFML.System.Vector3f.Z">
            <summary>Z (depth) component of the vector</summary>
        </member>
        <member name="T:SFML.ObjectBase">
            <summary>
            The ObjectBase class is an abstract base for every
            SFML object. It's meant for internal use only
            </summary>
        </member>
        <member name="M:SFML.ObjectBase.#ctor(System.IntPtr)">
            <summary>
            Construct the object from a pointer to the C library object
            </summary>
            <param name="cPointer">Internal pointer to the object in the C libraries</param>
        </member>
        <member name="M:SFML.ObjectBase.Finalize">
            <summary>
            Dispose the object
            </summary>
        </member>
        <member name="P:SFML.ObjectBase.CPointer">
            <summary>
            Access to the internal pointer of the object.
            For internal use only
            </summary>
        </member>
        <member name="M:SFML.ObjectBase.Dispose">
            <summary>
            Explicitly dispose the object
            </summary>
        </member>
        <member name="M:SFML.ObjectBase.Dispose(System.Boolean)">
            <summary>
            Destroy the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call?</param>
        </member>
        <member name="M:SFML.ObjectBase.Destroy(System.Boolean)">
            <summary>
            Destroy the object (implementation is left to each derived class)
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call?</param>
        </member>
        <member name="T:SFML.Window.Clipboard">
            <summary>
              <br />
            </summary>
        </member>
        <member name="P:SFML.Window.Clipboard.Contents">
            <summary>
            The contents of the Clipboard as a UTF-32 string
            </summary>
        </member>
        <member name="T:SFML.Window.Context">
            <summary>
            This class defines a .NET interface to an SFML OpenGL Context
            </summary>
        </member>
        <member name="M:SFML.Window.Context.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:SFML.Window.Context.Finalize">
            <summary>
            Finalizer
            </summary>
        </member>
        <member name="M:SFML.Window.Context.SetActive(System.Boolean)">
            <summary>
            Activate or deactivate the context
            </summary>
            <param name="active">True to activate, false to deactivate</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="P:SFML.Window.Context.Settings">
            <summary>
            Get the settings of the context.
            </summary>
        </member>
        <member name="P:SFML.Window.Context.Global">
            <summary>
            Global helper context
            </summary>
        </member>
        <member name="M:SFML.Window.Context.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="T:SFML.Window.ContextSettings">
            <summary>
            Structure defining the creation settings of OpenGL contexts
            </summary>
        </member>
        <member name="T:SFML.Window.ContextSettings.Attribute">
            <summary>
            Enumeration of the context attribute flags
            </summary>
        </member>
        <member name="F:SFML.Window.ContextSettings.Attribute.Default">
            <summary>Non-debug, compatibility context (this and the core attribute are mutually exclusive)</summary>
        </member>
        <member name="F:SFML.Window.ContextSettings.Attribute.Core">
            <summary>Core attribute</summary>
        </member>
        <member name="F:SFML.Window.ContextSettings.Attribute.Debug">
            <summary>Debug attribute</summary>
        </member>
        <member name="M:SFML.Window.ContextSettings.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Construct the settings from depth / stencil bits
            </summary>
            <param name="depthBits">Depth buffer bits</param>
            <param name="stencilBits">Stencil buffer bits</param>
        </member>
        <member name="M:SFML.Window.ContextSettings.#ctor(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Construct the settings from depth / stencil bits and antialiasing level
            </summary>
            <param name="depthBits">Depth buffer bits</param>
            <param name="stencilBits">Stencil buffer bits</param>
            <param name="antialiasingLevel">Antialiasing level</param>
        </member>
        <member name="M:SFML.Window.ContextSettings.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,SFML.Window.ContextSettings.Attribute,System.Boolean)">
            <summary>
            Construct the settings from depth / stencil bits and antialiasing level
            </summary>
            <param name="depthBits">Depth buffer bits</param>
            <param name="stencilBits">Stencil buffer bits</param>
            <param name="antialiasingLevel">Antialiasing level</param>
            <param name="majorVersion">Major number of the context version</param>
            <param name="minorVersion">Minor number of the context version</param>
            <param name="attributes">Attribute flags of the context</param>
            <param name="sRgbCapable">sRGB capability of the context</param>
        </member>
        <member name="M:SFML.Window.ContextSettings.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="F:SFML.Window.ContextSettings.DepthBits">
            <summary>Depth buffer bits (0 is disabled)</summary>
        </member>
        <member name="F:SFML.Window.ContextSettings.StencilBits">
            <summary>Stencil buffer bits (0 is disabled)</summary>
        </member>
        <member name="F:SFML.Window.ContextSettings.AntialiasingLevel">
            <summary>Antialiasing level (0 is disabled)</summary>
        </member>
        <member name="F:SFML.Window.ContextSettings.MajorVersion">
            <summary>Major number of the context version</summary>
        </member>
        <member name="F:SFML.Window.ContextSettings.MinorVersion">
            <summary>Minor number of the context version</summary>
        </member>
        <member name="F:SFML.Window.ContextSettings.AttributeFlags">
            <summary>The attribute flags to create the context with</summary>
        </member>
        <member name="F:SFML.Window.ContextSettings.SRgbCapable">
            <summary>Whether the context framebuffer is sRGB capable</summary>
        </member>
        <member name="T:SFML.Window.Cursor">
            <summary>
              <br />
            </summary>
        </member>
        <member name="T:SFML.Window.Cursor.CursorType">
            <summary>
            Enumeration of possibly available native system cursor types
            </summary>
        </member>
        <member name="F:SFML.Window.Cursor.CursorType.Arrow">
            <summary>
            Arrow cursor (default)
            Windows: Yes
            Mac OS:  Yes
            Linux:   Yes
            </summary>
        </member>
        <member name="F:SFML.Window.Cursor.CursorType.ArrowWait">
            <summary>
            Busy arrow cursor
            Windows: Yes
            Mac OS:  No
            Linux:   No
            </summary>
        </member>
        <member name="F:SFML.Window.Cursor.CursorType.Wait">
            <summary>
            Busy cursor
            Windows: Yes
            Mac OS:  No
            Linux:   Yes
            </summary>
        </member>
        <member name="F:SFML.Window.Cursor.CursorType.Text">
            <summary>
            I-beam, cursor when hovering over a field allowing text entry
            Windows: Yes
            Mac OS:  Yes
            Linux:   Yes
            </summary>
        </member>
        <member name="F:SFML.Window.Cursor.CursorType.Hand">
            <summary>
            Pointing hand cursor
            Windows: Yes
            Mac OS:  Yes
            Linux:   Yes
            </summary>
        </member>
        <member name="F:SFML.Window.Cursor.CursorType.SizeHorinzontal">
            <summary>
            Horizontal double arrow cursor
            Windows: Yes
            Mac OS:  Yes
            Linux:   Yes
            </summary>
        </member>
        <member name="F:SFML.Window.Cursor.CursorType.SizeVertical">
            <summary>
            Vertical double arrow cursor
            Windows: Yes
            Mac OS:  Yes
            Linux:   Yes
            </summary>
        </member>
        <member name="F:SFML.Window.Cursor.CursorType.SizeTopLeftBottomRight">
            <summary>
            Double arrow cursor going from top-left to bottom-right
            Windows: Yes
            Mac OS:  No
            Linux:   No
            </summary>
        </member>
        <member name="F:SFML.Window.Cursor.CursorType.SizeBottomLeftTopRight">
            <summary>
            Double arrow cursor going from bottom-left to top-right
            Windows: Yes
            Mac OS:  No
            Linux:   No
            </summary>
        </member>
        <member name="F:SFML.Window.Cursor.CursorType.SizeAll">
            <summary>
            Combination of SizeHorizontal and SizeVertical
            Windows: Yes
            Mac OS:  No
            Linux:   Yes
            </summary>
        </member>
        <member name="F:SFML.Window.Cursor.CursorType.Cross">
            <summary>
            Crosshair cursor
            Windows: Yes
            Mac OS:  Yes
            Linux:   Yes
            </summary>
        </member>
        <member name="F:SFML.Window.Cursor.CursorType.Help">
            <summary>
            Help cursor
            Windows: Yes
            Mac OS:  No
            Linux:   Yes
            </summary>
        </member>
        <member name="F:SFML.Window.Cursor.CursorType.NotAllowed">
            <summary>
            Action not allowed cursor
            Windows: Yes
            Mac OS:  Yes
            Linux:   Yes
            </summary>
        </member>
        <member name="M:SFML.Window.Cursor.#ctor(SFML.Window.Cursor.CursorType)">
             <summary>
             Create a native system cursor
            
             Refer to the list of cursor available on each system
             (see CursorType) to know whether a given cursor is
             expected to load successfully or is not supported by
             the operating system.
             </summary>
             <param name="type">System cursor type</param>
        </member>
        <member name="M:SFML.Window.Cursor.#ctor(System.Byte[],SFML.System.Vector2u,SFML.System.Vector2u)">
             <summary>
             Create a cursor with the provided image
            
             Pixels must be an array of width by height pixels
             in 32-bit RGBA format. If not, this will cause undefined behavior.
            
             If pixels is null or either width or height are 0,
             the current cursor is left unchanged and the function will
             return false.
            
             In addition to specifying the pixel data, you can also
             specify the location of the hotspot of the cursor. The
             hotspot is the pixel coordinate within the cursor image
             which will be located exactly where the mouse pointer
             position is. Any mouse actions that are performed will
             return the window/screen location of the hotspot.
            
             Warning: On Unix, the pixels are mapped into a monochrome
                      bitmap: pixels with an alpha channel to 0 are
                      transparent, black if the RGB channel are close
                      to zero, and white otherwise.
             </summary>
             <param name="pixels">Array of pixels of the image</param>
             <param name="size">Width and height of the image</param>
             <param name="hotspot">(x,y) location of the hotspot</param>
        </member>
        <member name="M:SFML.Window.Cursor.Destroy(System.Boolean)">
            <summary>Destroy the object (implementation is left to each derived class)</summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call?</param>
        </member>
        <member name="T:SFML.Window.EventType">
            <summary>
            Enumeration of the different types of events
            </summary>
        </member>
        <member name="F:SFML.Window.EventType.Closed">
            <summary>Event triggered when a window is manually closed</summary>
        </member>
        <member name="F:SFML.Window.EventType.Resized">
            <summary>Event triggered when a window is resized</summary>
        </member>
        <member name="F:SFML.Window.EventType.LostFocus">
            <summary>Event triggered when a window loses the focus</summary>
        </member>
        <member name="F:SFML.Window.EventType.GainedFocus">
            <summary>Event triggered when a window gains the focus</summary>
        </member>
        <member name="F:SFML.Window.EventType.TextEntered">
            <summary>Event triggered when a valid character is entered</summary>
        </member>
        <member name="F:SFML.Window.EventType.KeyPressed">
            <summary>Event triggered when a keyboard key is pressed</summary>
        </member>
        <member name="F:SFML.Window.EventType.KeyReleased">
            <summary>Event triggered when a keyboard key is released</summary>
        </member>
        <member name="F:SFML.Window.EventType.MouseWheelMoved">
            <summary>Event triggered when the mouse wheel is scrolled (deprecated)</summary>
        </member>
        <member name="F:SFML.Window.EventType.MouseWheelScrolled">
            <summary>Event triggered when a mouse wheel is scrolled</summary>
        </member>
        <member name="F:SFML.Window.EventType.MouseButtonPressed">
            <summary>Event triggered when a mouse button is pressed</summary>
        </member>
        <member name="F:SFML.Window.EventType.MouseButtonReleased">
            <summary>Event triggered when a mouse button is released</summary>
        </member>
        <member name="F:SFML.Window.EventType.MouseMoved">
            <summary>Event triggered when the mouse moves within the area of a window</summary>
        </member>
        <member name="F:SFML.Window.EventType.MouseEntered">
            <summary>Event triggered when the mouse enters the area of a window</summary>
        </member>
        <member name="F:SFML.Window.EventType.MouseLeft">
            <summary>Event triggered when the mouse leaves the area of a window</summary>
        </member>
        <member name="F:SFML.Window.EventType.JoystickButtonPressed">
            <summary>Event triggered when a joystick button is pressed</summary>
        </member>
        <member name="F:SFML.Window.EventType.JoystickButtonReleased">
            <summary>Event triggered when a joystick button is released</summary>
        </member>
        <member name="F:SFML.Window.EventType.JoystickMoved">
            <summary>Event triggered when a joystick axis moves</summary>
        </member>
        <member name="F:SFML.Window.EventType.JoystickConnected">
            <summary>Event triggered when a joystick is connected</summary>
        </member>
        <member name="F:SFML.Window.EventType.JoystickDisconnected">
            <summary>Event triggered when a joystick is disconnected</summary>
        </member>
        <member name="F:SFML.Window.EventType.TouchBegan">
            <summary>Event triggered when a touch begins</summary>
        </member>
        <member name="F:SFML.Window.EventType.TouchMoved">
            <summary>Event triggered when a touch is moved</summary>
        </member>
        <member name="F:SFML.Window.EventType.TouchEnded">
            <summary>Event triggered when a touch is ended</summary>
        </member>
        <member name="F:SFML.Window.EventType.SensorChanged">
            <summary>Event triggered when a sensor is changed</summary>
        </member>
        <member name="T:SFML.Window.KeyEvent">
            <summary>
            Keyboard event parameters
            </summary>
        </member>
        <member name="F:SFML.Window.KeyEvent.Code">
            <summary>Code of the key (see KeyCode enum)</summary>
        </member>
        <member name="F:SFML.Window.KeyEvent.Alt">
            <summary>Is the Alt modifier pressed?</summary>
        </member>
        <member name="F:SFML.Window.KeyEvent.Control">
            <summary>Is the Control modifier pressed?</summary>
        </member>
        <member name="F:SFML.Window.KeyEvent.Shift">
            <summary>Is the Shift modifier pressed?</summary>
        </member>
        <member name="F:SFML.Window.KeyEvent.System">
            <summary>Is the System modifier pressed?</summary>
        </member>
        <member name="T:SFML.Window.TextEvent">
            <summary>
            Text event parameters
            </summary>
        </member>
        <member name="F:SFML.Window.TextEvent.Unicode">
            <summary>UTF-32 value of the character</summary>
        </member>
        <member name="T:SFML.Window.MouseMoveEvent">
            <summary>
            Mouse move event parameters
            </summary>
        </member>
        <member name="F:SFML.Window.MouseMoveEvent.X">
            <summary>X coordinate of the mouse cursor</summary>
        </member>
        <member name="F:SFML.Window.MouseMoveEvent.Y">
            <summary>Y coordinate of the mouse cursor</summary>
        </member>
        <member name="T:SFML.Window.MouseButtonEvent">
            <summary>
            Mouse buttons event parameters
            </summary>
        </member>
        <member name="F:SFML.Window.MouseButtonEvent.Button">
            <summary>Code of the button (see MouseButton enum)</summary>
        </member>
        <member name="F:SFML.Window.MouseButtonEvent.X">
            <summary>X coordinate of the mouse cursor</summary>
        </member>
        <member name="F:SFML.Window.MouseButtonEvent.Y">
            <summary>Y coordinate of the mouse cursor</summary>
        </member>
        <member name="T:SFML.Window.MouseWheelEvent">
            <summary>
            Mouse wheel move event parameters
            </summary>
        </member>
        <member name="F:SFML.Window.MouseWheelEvent.Delta">
            <summary>Scroll amount</summary>
        </member>
        <member name="F:SFML.Window.MouseWheelEvent.X">
            <summary>X coordinate of the mouse cursor</summary>
        </member>
        <member name="F:SFML.Window.MouseWheelEvent.Y">
            <summary>Y coordinate of the mouse cursor</summary>
        </member>
        <member name="T:SFML.Window.MouseWheelScrollEvent">
            <summary>
            Mouse wheel scroll event parameters
            </summary>
        </member>
        <member name="F:SFML.Window.MouseWheelScrollEvent.Wheel">
            <summary>Mouse Wheel which triggered the event</summary>
        </member>
        <member name="F:SFML.Window.MouseWheelScrollEvent.Delta">
            <summary>Scroll amount</summary>
        </member>
        <member name="F:SFML.Window.MouseWheelScrollEvent.X">
            <summary>X coordinate of the mouse cursor</summary>
        </member>
        <member name="F:SFML.Window.MouseWheelScrollEvent.Y">
            <summary>Y coordinate of the mouse cursor</summary>
        </member>
        <member name="T:SFML.Window.JoystickMoveEvent">
            <summary>
            Joystick axis move event parameters
            </summary>
        </member>
        <member name="F:SFML.Window.JoystickMoveEvent.JoystickId">
            <summary>Index of the joystick which triggered the event</summary>
        </member>
        <member name="F:SFML.Window.JoystickMoveEvent.Axis">
            <summary>Joystick axis (see JoyAxis enum)</summary>
        </member>
        <member name="F:SFML.Window.JoystickMoveEvent.Position">
            <summary>Current position of the axis</summary>
        </member>
        <member name="T:SFML.Window.JoystickButtonEvent">
            <summary>
            Joystick buttons event parameters
            </summary>
        </member>
        <member name="F:SFML.Window.JoystickButtonEvent.JoystickId">
            <summary>Index of the joystick which triggered the event</summary>
        </member>
        <member name="F:SFML.Window.JoystickButtonEvent.Button">
            <summary>Index of the button</summary>
        </member>
        <member name="T:SFML.Window.JoystickConnectEvent">
            <summary>
            Joystick connect event parameters
            </summary>
        </member>
        <member name="F:SFML.Window.JoystickConnectEvent.JoystickId">
            <summary>Index of the joystick which triggered the event</summary>
        </member>
        <member name="T:SFML.Window.SizeEvent">
            <summary>
            Size event parameters
            </summary>
        </member>
        <member name="F:SFML.Window.SizeEvent.Width">
            <summary>New width of the window</summary>
        </member>
        <member name="F:SFML.Window.SizeEvent.Height">
            <summary>New height of the window</summary>
        </member>
        <member name="T:SFML.Window.TouchEvent">
            <summary>
            Touch event parameters
            </summary>
        </member>
        <member name="F:SFML.Window.TouchEvent.Finger">
            <summary>Index of the finger in case of multi-touch events</summary>
        </member>
        <member name="F:SFML.Window.TouchEvent.X">
            <summary>X position of the touch, relative to the left of the owner window</summary>
        </member>
        <member name="F:SFML.Window.TouchEvent.Y">
            <summary>Y position of the touch, relative to the top of the owner window</summary>
        </member>
        <member name="T:SFML.Window.SensorEvent">
            <summary>
            Sensor event parameters
            </summary>
        </member>
        <member name="F:SFML.Window.SensorEvent.Type">
            <summary>Type of the sensor</summary>
        </member>
        <member name="F:SFML.Window.SensorEvent.X">
            <summary>Current value of the sensor on X axis</summary>
        </member>
        <member name="F:SFML.Window.SensorEvent.Y">
            <summary>Current value of the sensor on Y axis</summary>
        </member>
        <member name="F:SFML.Window.SensorEvent.Z">
            <summary>Current value of the sensor on Z axis</summary>
        </member>
        <member name="T:SFML.Window.Event">
            <summary>
            Event defines a system event and its parameters
            </summary>
        </member>
        <member name="F:SFML.Window.Event.Type">
            <summary>Type of event (see EventType enum)</summary>
        </member>
        <member name="F:SFML.Window.Event.Size">
            <summary>Arguments for size events (Resized)</summary>
        </member>
        <member name="F:SFML.Window.Event.Key">
            <summary>Arguments for key events (KeyPressed, KeyReleased)</summary>
        </member>
        <member name="F:SFML.Window.Event.Text">
            <summary>Arguments for text events (TextEntered)</summary>
        </member>
        <member name="F:SFML.Window.Event.MouseMove">
            <summary>Arguments for mouse move events (MouseMoved)</summary>
        </member>
        <member name="F:SFML.Window.Event.MouseButton">
            <summary>Arguments for mouse button events (MouseButtonPressed, MouseButtonReleased)</summary>
        </member>
        <member name="F:SFML.Window.Event.MouseWheel">
            <summary>Arguments for mouse wheel events (MouseWheelMoved)</summary>
        </member>
        <member name="F:SFML.Window.Event.MouseWheelScroll">
            <summary>Arguments for mouse wheel scroll events (MouseWheelScrolled)</summary>
        </member>
        <member name="F:SFML.Window.Event.JoystickMove">
            <summary>Arguments for joystick axis events (JoystickMoved)</summary>
        </member>
        <member name="F:SFML.Window.Event.JoystickButton">
            <summary>Arguments for joystick button events (JoystickButtonPressed, JoystickButtonReleased)</summary>
        </member>
        <member name="F:SFML.Window.Event.JoystickConnect">
            <summary>Arguments for joystick connect events (JoystickConnected, JoystickDisconnected)</summary>
        </member>
        <member name="F:SFML.Window.Event.Touch">
            <summary>Arguments for touch events (TouchBegan, TouchMoved, TouchEnded)</summary>
        </member>
        <member name="F:SFML.Window.Event.Sensor">
            <summary>Arguments for sensor events (SensorChanged)</summary>
        </member>
        <member name="T:SFML.Window.KeyEventArgs">
            <summary>
            Keyboard event parameters
            </summary>
        </member>
        <member name="M:SFML.Window.KeyEventArgs.#ctor(SFML.Window.KeyEvent)">
            <summary>
            Construct the key arguments from a key event
            </summary>
            <param name="e">Key event</param>
        </member>
        <member name="M:SFML.Window.KeyEventArgs.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="F:SFML.Window.KeyEventArgs.Code">
            <summary>Code of the key (see KeyCode enum)</summary>
        </member>
        <member name="F:SFML.Window.KeyEventArgs.Alt">
            <summary>Is the Alt modifier pressed?</summary>
        </member>
        <member name="F:SFML.Window.KeyEventArgs.Control">
            <summary>Is the Control modifier pressed?</summary>
        </member>
        <member name="F:SFML.Window.KeyEventArgs.Shift">
            <summary>Is the Shift modifier pressed?</summary>
        </member>
        <member name="F:SFML.Window.KeyEventArgs.System">
            <summary>Is the System modifier pressed?</summary>
        </member>
        <member name="T:SFML.Window.TextEventArgs">
            <summary>
            Text event parameters
            </summary>
        </member>
        <member name="M:SFML.Window.TextEventArgs.#ctor(SFML.Window.TextEvent)">
            <summary>
            Construct the text arguments from a text event
            </summary>
            <param name="e">Text event</param>
        </member>
        <member name="M:SFML.Window.TextEventArgs.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="F:SFML.Window.TextEventArgs.Unicode">
            <summary>UTF-16 value of the character</summary>
        </member>
        <member name="T:SFML.Window.MouseMoveEventArgs">
            <summary>
            Mouse move event parameters
            </summary>
        </member>
        <member name="M:SFML.Window.MouseMoveEventArgs.#ctor(SFML.Window.MouseMoveEvent)">
            <summary>
            Construct the mouse move arguments from a mouse move event
            </summary>
            <param name="e">Mouse move event</param>
        </member>
        <member name="M:SFML.Window.MouseMoveEventArgs.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="F:SFML.Window.MouseMoveEventArgs.X">
            <summary>X coordinate of the mouse cursor</summary>
        </member>
        <member name="F:SFML.Window.MouseMoveEventArgs.Y">
            <summary>Y coordinate of the mouse cursor</summary>
        </member>
        <member name="T:SFML.Window.MouseButtonEventArgs">
            <summary>
            Mouse buttons event parameters
            </summary>
        </member>
        <member name="M:SFML.Window.MouseButtonEventArgs.#ctor(SFML.Window.MouseButtonEvent)">
            <summary>
            Construct the mouse button arguments from a mouse button event
            </summary>
            <param name="e">Mouse button event</param>
        </member>
        <member name="M:SFML.Window.MouseButtonEventArgs.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="F:SFML.Window.MouseButtonEventArgs.Button">
            <summary>Code of the button (see MouseButton enum)</summary>
        </member>
        <member name="F:SFML.Window.MouseButtonEventArgs.X">
            <summary>X coordinate of the mouse cursor</summary>
        </member>
        <member name="F:SFML.Window.MouseButtonEventArgs.Y">
            <summary>Y coordinate of the mouse cursor</summary>
        </member>
        <member name="T:SFML.Window.MouseWheelEventArgs">
            <summary>
            Mouse wheel event parameters
            </summary>
        </member>
        <member name="M:SFML.Window.MouseWheelEventArgs.#ctor(SFML.Window.MouseWheelEvent)">
            <summary>
            Construct the mouse wheel arguments from a mouse wheel event
            </summary>
            <param name="e">Mouse wheel event</param>
        </member>
        <member name="M:SFML.Window.MouseWheelEventArgs.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="F:SFML.Window.MouseWheelEventArgs.Delta">
            <summary>Scroll amount</summary>
        </member>
        <member name="F:SFML.Window.MouseWheelEventArgs.X">
            <summary>X coordinate of the mouse cursor</summary>
        </member>
        <member name="F:SFML.Window.MouseWheelEventArgs.Y">
            <summary>Y coordinate of the mouse cursor</summary>
        </member>
        <member name="T:SFML.Window.MouseWheelScrollEventArgs">
            <summary>
            Mouse wheel scroll event parameters
            </summary>
        </member>
        <member name="M:SFML.Window.MouseWheelScrollEventArgs.#ctor(SFML.Window.MouseWheelScrollEvent)">
            <summary>
            Construct the mouse wheel scroll arguments from a mouse wheel scroll event
            </summary>
            <param name="e">Mouse wheel scroll event</param>
        </member>
        <member name="M:SFML.Window.MouseWheelScrollEventArgs.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="F:SFML.Window.MouseWheelScrollEventArgs.Wheel">
            <summary>Mouse Wheel which triggered the event</summary>
        </member>
        <member name="F:SFML.Window.MouseWheelScrollEventArgs.Delta">
            <summary>Scroll amount</summary>
        </member>
        <member name="F:SFML.Window.MouseWheelScrollEventArgs.X">
            <summary>X coordinate of the mouse cursor</summary>
        </member>
        <member name="F:SFML.Window.MouseWheelScrollEventArgs.Y">
            <summary>Y coordinate of the mouse cursor</summary>
        </member>
        <member name="T:SFML.Window.JoystickMoveEventArgs">
            <summary>
            Joystick axis move event parameters
            </summary>
        </member>
        <member name="M:SFML.Window.JoystickMoveEventArgs.#ctor(SFML.Window.JoystickMoveEvent)">
            <summary>
            Construct the joystick move arguments from a joystick move event
            </summary>
            <param name="e">Joystick move event</param>
        </member>
        <member name="M:SFML.Window.JoystickMoveEventArgs.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="F:SFML.Window.JoystickMoveEventArgs.JoystickId">
            <summary>Index of the joystick which triggered the event</summary>
        </member>
        <member name="F:SFML.Window.JoystickMoveEventArgs.Axis">
            <summary>Joystick axis (see JoyAxis enum)</summary>
        </member>
        <member name="F:SFML.Window.JoystickMoveEventArgs.Position">
            <summary>Current position of the axis</summary>
        </member>
        <member name="T:SFML.Window.JoystickButtonEventArgs">
            <summary>
            Joystick buttons event parameters
            </summary>
        </member>
        <member name="M:SFML.Window.JoystickButtonEventArgs.#ctor(SFML.Window.JoystickButtonEvent)">
            <summary>
            Construct the joystick button arguments from a joystick button event
            </summary>
            <param name="e">Joystick button event</param>
        </member>
        <member name="M:SFML.Window.JoystickButtonEventArgs.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="F:SFML.Window.JoystickButtonEventArgs.JoystickId">
            <summary>Index of the joystick which triggered the event</summary>
        </member>
        <member name="F:SFML.Window.JoystickButtonEventArgs.Button">
            <summary>Index of the button</summary>
        </member>
        <member name="T:SFML.Window.JoystickConnectEventArgs">
            <summary>
            Joystick connection/disconnection event parameters
            </summary>
        </member>
        <member name="M:SFML.Window.JoystickConnectEventArgs.#ctor(SFML.Window.JoystickConnectEvent)">
            <summary>
            Construct the joystick connect arguments from a joystick connect event
            </summary>
            <param name="e">Joystick button event</param>
        </member>
        <member name="M:SFML.Window.JoystickConnectEventArgs.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="F:SFML.Window.JoystickConnectEventArgs.JoystickId">
            <summary>Index of the joystick which triggered the event</summary>
        </member>
        <member name="T:SFML.Window.SizeEventArgs">
            <summary>
            Size event parameters
            </summary>
        </member>
        <member name="M:SFML.Window.SizeEventArgs.#ctor(SFML.Window.SizeEvent)">
            <summary>
            Construct the size arguments from a size event
            </summary>
            <param name="e">Size event</param>
        </member>
        <member name="M:SFML.Window.SizeEventArgs.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="F:SFML.Window.SizeEventArgs.Width">
            <summary>New width of the window</summary>
        </member>
        <member name="F:SFML.Window.SizeEventArgs.Height">
            <summary>New height of the window</summary>
        </member>
        <member name="T:SFML.Window.TouchEventArgs">
            <summary>
            Touch event parameters
            </summary>
        </member>
        <member name="M:SFML.Window.TouchEventArgs.#ctor(SFML.Window.TouchEvent)">
            <summary>
            Construct the touch arguments from a touch event
            </summary>
            <param name="e">Touch event</param>
        </member>
        <member name="M:SFML.Window.TouchEventArgs.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="F:SFML.Window.TouchEventArgs.Finger">
            <summary>Index of the finger in case of multi-touch events</summary>
        </member>
        <member name="F:SFML.Window.TouchEventArgs.X">
            <summary>X position of the touch, relative to the left of the owner window</summary>
        </member>
        <member name="F:SFML.Window.TouchEventArgs.Y">
            <summary>Y position of the touch, relative to the top of the owner window</summary>
        </member>
        <member name="T:SFML.Window.SensorEventArgs">
            <summary>
            Sensor event parameters
            </summary>
        </member>
        <member name="M:SFML.Window.SensorEventArgs.#ctor(SFML.Window.SensorEvent)">
            <summary>
            Construct the sensor arguments from a sensor event
            </summary>
            <param name="e">Sensor event</param>
        </member>
        <member name="M:SFML.Window.SensorEventArgs.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="F:SFML.Window.SensorEventArgs.Type">
            <summary>Type of the sensor</summary>
        </member>
        <member name="F:SFML.Window.SensorEventArgs.X">
            <summary>Current value of the sensor on X axis</summary>
        </member>
        <member name="F:SFML.Window.SensorEventArgs.Y">
            <summary>Current value of the sensor on Y axis</summary>
        </member>
        <member name="F:SFML.Window.SensorEventArgs.Z">
            <summary>Current value of the sensor on Z axis</summary>
        </member>
        <member name="T:SFML.Window.Joystick">
            <summary>
            Give access to the real-time state of the joysticks
            </summary>
        </member>
        <member name="F:SFML.Window.Joystick.Count">
            <summary>Maximum number of supported joysticks</summary>
        </member>
        <member name="F:SFML.Window.Joystick.ButtonCount">
            <summary>Maximum number of supported buttons</summary>
        </member>
        <member name="F:SFML.Window.Joystick.AxisCount">
            <summary>Maximum number of supported axes</summary>
        </member>
        <member name="T:SFML.Window.Joystick.Axis">
            <summary>
            Axes supported by SFML joysticks
            </summary>
        </member>
        <member name="F:SFML.Window.Joystick.Axis.X">
            <summary>The X axis</summary>
        </member>
        <member name="F:SFML.Window.Joystick.Axis.Y">
            <summary>The Y axis</summary>
        </member>
        <member name="F:SFML.Window.Joystick.Axis.Z">
            <summary>The Z axis</summary>
        </member>
        <member name="F:SFML.Window.Joystick.Axis.R">
            <summary>The R axis</summary>
        </member>
        <member name="F:SFML.Window.Joystick.Axis.U">
            <summary>The U axis</summary>
        </member>
        <member name="F:SFML.Window.Joystick.Axis.V">
            <summary>The V axis</summary>
        </member>
        <member name="F:SFML.Window.Joystick.Axis.PovX">
            <summary>The X axis of the point-of-view hat</summary>
        </member>
        <member name="F:SFML.Window.Joystick.Axis.PovY">
            <summary>TheY axis of the point-of-view hat</summary>
        </member>
        <member name="M:SFML.Window.Joystick.IsConnected(System.UInt32)">
            <summary>
            Check if a joystick is connected
            </summary>
            <param name="joystick">Index of the joystick to check</param>
            <returns>True if the joystick is connected, false otherwise</returns>
        </member>
        <member name="M:SFML.Window.Joystick.GetButtonCount(System.UInt32)">
            <summary>
            Return the number of buttons supported by a joystick
            </summary>
            If the joystick is not connected, this function returns 0.
            <param name="joystick">Index of the joystick</param>
            <returns>Number of buttons supported by the joystick</returns>
        </member>
        <member name="M:SFML.Window.Joystick.HasAxis(System.UInt32,SFML.Window.Joystick.Axis)">
            <summary>
            Check if a joystick supports a given axis
            </summary>
            If the joystick is not connected, this function returns false.
            <param name="joystick">Index of the joystick</param>
            <param name="axis">Axis to check</param>
            <returns>True if the joystick supports the axis, false otherwise</returns>
        </member>
        <member name="M:SFML.Window.Joystick.IsButtonPressed(System.UInt32,System.UInt32)">
            <summary>
            Check if a joystick button is pressed
            </summary>
            If the joystick is not connected, this function returns false.
            <param name="joystick">Index of the joystick</param>
            <param name="button">Button to check</param>
            <returns>True if the button is pressed, false otherwise</returns>
        </member>
        <member name="M:SFML.Window.Joystick.GetAxisPosition(System.UInt32,SFML.Window.Joystick.Axis)">
            <summary>
            Get the current position of a joystick axis
            </summary>
            If the joystick is not connected, this function returns 0.
            <param name="joystick">Index of the joystick</param>
            <param name="axis">Axis to check</param>
            <returns>Current position of the axis, in range [-100 .. 100]</returns>
        </member>
        <member name="M:SFML.Window.Joystick.Update">
            <summary>
            Update the states of all joysticks
            </summary>
            This function is used internally by SFML, so you normally
            don't have to call it explicitly. However, you may need to
            call it if you have no window yet (or no window at all):
            in this case the joysticks states are not updated automatically.
        </member>
        <member name="M:SFML.Window.Joystick.GetIdentification(System.UInt32)">
            <summary>
            Get the joystick information
            </summary>
            <param name="joystick">Index of the joystick</param>
            <returns>Structure containing joystick information</returns>
        </member>
        <member name="T:SFML.Window.Joystick.Identification">
            <summary>
            Identification holds a joystick's identification
            </summary>
        </member>
        <member name="F:SFML.Window.Joystick.Identification.Name">
            <summary>Name of the joystick</summary>
        </member>
        <member name="F:SFML.Window.Joystick.Identification.VendorId">
            <summary>Manufacturer identifier</summary>
        </member>
        <member name="F:SFML.Window.Joystick.Identification.ProductId">
            <summary>Product identifier</summary>
        </member>
        <member name="T:SFML.Window.Joystick.IdentificationMarshalData">
            <summary>
            Internal struct used for marshaling the joystick
            identification struct from unmanaged code.
            </summary>
        </member>
        <member name="T:SFML.Window.Keyboard">
            <summary>
            Give access to the real-time state of the keyboard
            </summary>
        </member>
        <member name="T:SFML.Window.Keyboard.Key">
            <summary>
            Key codes
            </summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Unknown">
            <summary>Unhandled key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.A">
            <summary>The A key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.B">
            <summary>The B key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.C">
            <summary>The C key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.D">
            <summary>The D key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.E">
            <summary>The E key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F">
            <summary>The F key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.G">
            <summary>The G key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.H">
            <summary>The H key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.I">
            <summary>The I key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.J">
            <summary>The J key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.K">
            <summary>The K key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.L">
            <summary>The L key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.M">
            <summary>The M key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.N">
            <summary>The N key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.O">
            <summary>The O key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.P">
            <summary>The P key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Q">
            <summary>The Q key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.R">
            <summary>The R key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.S">
            <summary>The S key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.T">
            <summary>The T key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.U">
            <summary>The U key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.V">
            <summary>The V key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.W">
            <summary>The W key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.X">
            <summary>The X key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Y">
            <summary>The Y key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Z">
            <summary>The Z key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Num0">
            <summary>The 0 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Num1">
            <summary>The 1 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Num2">
            <summary>The 2 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Num3">
            <summary>The 3 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Num4">
            <summary>The 4 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Num5">
            <summary>The 5 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Num6">
            <summary>The 6 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Num7">
            <summary>The 7 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Num8">
            <summary>The 8 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Num9">
            <summary>The 9 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Escape">
            <summary>The Escape key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.LControl">
            <summary>The left Control key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.LShift">
            <summary>The left Shift key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.LAlt">
            <summary>The left Alt key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.LSystem">
            <summary>The left OS specific key: window (Windows and Linux), apple (MacOS X), ...</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.RControl">
            <summary>The right Control key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.RShift">
            <summary>The right Shift key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.RAlt">
            <summary>The right Alt key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.RSystem">
            <summary>The right OS specific key: window (Windows and Linux), apple (MacOS X), ...</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Menu">
            <summary>The Menu key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.LBracket">
            <summary>The [ key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.RBracket">
            <summary>The ] key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Semicolon">
            <summary>The ; key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Comma">
            <summary>The , key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Period">
            <summary>The . key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Quote">
            <summary>The ' key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Slash">
            <summary>The / key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Backslash">
            <summary>The \ key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Tilde">
            <summary>The ~ key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Equal">
            <summary>The = key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Hyphen">
            <summary>The - key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Space">
            <summary>The Space key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Enter">
            <summary>The Return key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Backspace">
            <summary>The Backspace key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Tab">
            <summary>The Tabulation key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.PageUp">
            <summary>The Page up key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.PageDown">
            <summary>The Page down key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.End">
            <summary>The End key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Home">
            <summary>The Home key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Insert">
            <summary>The Insert key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Delete">
            <summary>The Delete key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Add">
            <summary>The + key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Subtract">
            <summary>The - key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Multiply">
            <summary>The * key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Divide">
            <summary>The / key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Left">
            <summary>Left arrow</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Right">
            <summary>Right arrow</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Up">
            <summary>Up arrow</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Down">
            <summary>Down arrow</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Numpad0">
            <summary>The numpad 0 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Numpad1">
            <summary>The numpad 1 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Numpad2">
            <summary>The numpad 2 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Numpad3">
            <summary>The numpad 3 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Numpad4">
            <summary>The numpad 4 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Numpad5">
            <summary>The numpad 5 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Numpad6">
            <summary>The numpad 6 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Numpad7">
            <summary>The numpad 7 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Numpad8">
            <summary>The numpad 8 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Numpad9">
            <summary>The numpad 9 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F1">
            <summary>The F1 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F2">
            <summary>The F2 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F3">
            <summary>The F3 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F4">
            <summary>The F4 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F5">
            <summary>The F5 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F6">
            <summary>The F6 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F7">
            <summary>The F7 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F8">
            <summary>The F8 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F9">
            <summary>The F9 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F10">
            <summary>The F10 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F11">
            <summary>The F11 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F12">
            <summary>The F12 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F13">
            <summary>The F13 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F14">
            <summary>The F14 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.F15">
            <summary>The F15 key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Pause">
            <summary>The Pause key</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.KeyCount">
            <summary>The total number of keyboard keys</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Dash">
            <summary>The dash</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.BackSpace">
            <summary>The back space</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.Return">
            <summary>The return</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.BackSlash">
            <summary>The back slash</summary>
        </member>
        <member name="F:SFML.Window.Keyboard.Key.SemiColon">
            <summary>The semi colon</summary>
        </member>
        <member name="M:SFML.Window.Keyboard.IsKeyPressed(SFML.Window.Keyboard.Key)">
            <summary>
            Check if a key is pressed
            </summary>
            <param name="key">Key to check</param>
            <returns>True if the key is pressed, false otherwise</returns>
        </member>
        <member name="M:SFML.Window.Keyboard.SetVirtualKeyboardVisible(System.Boolean)">
            <summary>
            Enable/Disable visibility of the virtual keyboard
            </summary>
            <remarks>Applicable only on Android and iOS</remarks>
            <param name="visible">Whether to make the virtual keyboard visible (true) or not (false)</param>
        </member>
        <member name="T:SFML.Window.Mouse">
            <summary>
            Give access to the real-time state of the mouse
            </summary>
        </member>
        <member name="T:SFML.Window.Mouse.Button">
            <summary>
            Mouse buttons
            </summary>
        </member>
        <member name="F:SFML.Window.Mouse.Button.Left">
            <summary>The left mouse button</summary>
        </member>
        <member name="F:SFML.Window.Mouse.Button.Right">
            <summary>The right mouse button</summary>
        </member>
        <member name="F:SFML.Window.Mouse.Button.Middle">
            <summary>The middle (wheel) mouse button</summary>
        </member>
        <member name="F:SFML.Window.Mouse.Button.XButton1">
            <summary>The first extra mouse button</summary>
        </member>
        <member name="F:SFML.Window.Mouse.Button.XButton2">
            <summary>The second extra mouse button</summary>
        </member>
        <member name="F:SFML.Window.Mouse.Button.ButtonCount">
            <summary>Keep last -- the total number of mouse buttons</summary>
        </member>
        <member name="T:SFML.Window.Mouse.Wheel">
            <summary>
            Mouse wheels
            </summary>
        </member>
        <member name="F:SFML.Window.Mouse.Wheel.VerticalWheel">
            <summary>The vertical mouse wheel</summary>
        </member>
        <member name="F:SFML.Window.Mouse.Wheel.HorizontalWheel">
            <summary>The horizontal mouse wheel</summary>
        </member>
        <member name="M:SFML.Window.Mouse.IsButtonPressed(SFML.Window.Mouse.Button)">
            <summary>
            Check if a mouse button is pressed
            </summary>
            <param name="button">Button to check</param>
            <returns>True if the button is pressed, false otherwise</returns>
        </member>
        <member name="M:SFML.Window.Mouse.GetPosition">
            <summary>
            Get the current position of the mouse
            </summary>
            This function returns the current position of the mouse
            cursor in desktop coordinates.
            <returns>Current position of the mouse</returns>
        </member>
        <member name="M:SFML.Window.Mouse.GetPosition(SFML.Window.Window)">
            <summary>
            Get the current position of the mouse
            </summary>
            This function returns the current position of the mouse
            cursor relative to a window.
            <param name="relativeTo">Reference window</param>
            <returns>Current position of the mouse</returns>
        </member>
        <member name="M:SFML.Window.Mouse.SetPosition(SFML.System.Vector2i)">
            <summary>
            Set the current position of the mouse
            </summary>
            This function sets the current position of the mouse
            cursor in desktop coordinates.
            <param name="position">New position of the mouse</param>
        </member>
        <member name="M:SFML.Window.Mouse.SetPosition(SFML.System.Vector2i,SFML.Window.Window)">
            <summary>
            Set the current position of the mouse
            </summary>
            This function sets the current position of the mouse
            cursor relative to a window.
            <param name="position">New position of the mouse</param>
            <param name="relativeTo">Reference window</param>
        </member>
        <member name="T:SFML.Window.Sensor">
            <summary>
            Give access to the real-time state of sensors
            </summary>
        </member>
        <member name="T:SFML.Window.Sensor.Type">
            <summary>
            Sensor types
            </summary>
        </member>
        <member name="F:SFML.Window.Sensor.Type.Accelerometer">
            <summary>Measures the raw acceleration (m/s^2)</summary>
        </member>
        <member name="F:SFML.Window.Sensor.Type.Gyroscope">
            <summary>Measures the raw rotation rates (degrees/s)</summary>
        </member>
        <member name="F:SFML.Window.Sensor.Type.Magnetometer">
            <summary>Measures the ambient magnetic field (micro-teslas)</summary>
        </member>
        <member name="F:SFML.Window.Sensor.Type.Gravity">
            <summary>Measures the direction and intensity of gravity, independent of device acceleration (m/s^2)</summary>
        </member>
        <member name="F:SFML.Window.Sensor.Type.UserAcceleration">
            <summary>Measures the direction and intensity of device acceleration, independent of the gravity (m/s^2)</summary>
        </member>
        <member name="F:SFML.Window.Sensor.Type.Orientation">
            <summary>Measures the absolute 3D orientation (degrees)</summary>
        </member>
        <member name="F:SFML.Window.Sensor.Type.TypeCount">
            <summary>Keep last -- the total number of sensor types</summary>
        </member>
        <member name="M:SFML.Window.Sensor.IsAvailable(SFML.Window.Sensor.Type)">
            <summary>
            Check if a sensor is available on the underlying platform
            </summary>
            <param name="Sensor">Sensor to check</param>
            <returns>True if the sensor is available, false otherwise</returns>
        </member>
        <member name="M:SFML.Window.Sensor.SetEnabled(SFML.Window.Sensor.Type,System.Boolean)">
            <summary>
            Enable or disable a sensor
            </summary>
            <param name="Sensor">Sensor to check</param>
            <param name="Enabled">True to enable, false to disable</param>
        </member>
        <member name="M:SFML.Window.Sensor.GetValue(SFML.Window.Sensor.Type)">
            <summary>
            Get the current sensor value
            </summary>
            <param name="Sensor">Sensor to check</param>
            <returns>The current sensor value</returns>
        </member>
        <member name="T:SFML.Window.Touch">
            <summary>
            Give access to the real-time state of the touches
            </summary>
        </member>
        <member name="M:SFML.Window.Touch.IsDown(System.UInt32)">
            <summary>
            Check if a touch event is currently down
            </summary>
            <param name="Finger">Finger index</param>
            <returns>True if the finger is currently touching the screen, false otherwise</returns>
        </member>
        <member name="M:SFML.Window.Touch.GetPosition(System.UInt32)">
            <summary>
            This function returns the current touch position
            </summary>
            <param name="Finger">Finger index</param>
            <returns>Current position of the finger</returns>
        </member>
        <member name="M:SFML.Window.Touch.GetPosition(System.UInt32,SFML.Window.Window)">
            <summary>
            This function returns the current touch position
            relative to the given window
            </summary>
            <param name="Finger">Finger index</param>
            <param name="RelativeTo">Reference window</param>
            <returns>Current position of the finger</returns>
        </member>
        <member name="T:SFML.Window.VideoMode">
            <summary>
            VideoMode defines a video mode (width, height, bpp, frequency)
            and provides static functions for getting modes supported
            by the display device
            </summary>
        </member>
        <member name="M:SFML.Window.VideoMode.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Construct the video mode with its width and height
            </summary>
            <param name="width">Video mode width</param>
            <param name="height">Video mode height</param>
        </member>
        <member name="M:SFML.Window.VideoMode.#ctor(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Construct the video mode with its width, height and depth
            </summary>
            <param name="width">Video mode width</param>
            <param name="height">Video mode height</param>
            <param name="bpp">Video mode depth (bits per pixel)</param>
        </member>
        <member name="M:SFML.Window.VideoMode.IsValid">
            <summary>
            Tell whether or not the video mode is supported
            </summary>
            <returns>True if the video mode is valid, false otherwise</returns>
        </member>
        <member name="P:SFML.Window.VideoMode.FullscreenModes">
            <summary>
            Get the list of all the supported fullscreen video modes
            </summary>
        </member>
        <member name="P:SFML.Window.VideoMode.DesktopMode">
            <summary>
            Get the current desktop video mode
            </summary>
        </member>
        <member name="M:SFML.Window.VideoMode.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="F:SFML.Window.VideoMode.Width">
            <summary>Video mode width, in pixels</summary>
        </member>
        <member name="F:SFML.Window.VideoMode.Height">
            <summary>Video mode height, in pixels</summary>
        </member>
        <member name="F:SFML.Window.VideoMode.BitsPerPixel">
            <summary>Video mode depth, in bits per pixel</summary>
        </member>
        <member name="T:SFML.Window.Styles">
            <summary>
            Enumeration of window creation styles
            </summary>
        </member>
        <member name="F:SFML.Window.Styles.None">
            <summary>No border / title bar (this flag and all others are mutually exclusive)</summary>
        </member>
        <member name="F:SFML.Window.Styles.Titlebar">
            <summary>Title bar + fixed border</summary>
        </member>
        <member name="F:SFML.Window.Styles.Resize">
            <summary>Titlebar + resizable border + maximize button</summary>
        </member>
        <member name="F:SFML.Window.Styles.Close">
            <summary>Titlebar + close button</summary>
        </member>
        <member name="F:SFML.Window.Styles.Fullscreen">
            <summary>Fullscreen mode (this flag and all others are mutually exclusive))</summary>
        </member>
        <member name="F:SFML.Window.Styles.Default">
            <summary>Default window style (titlebar + resize + close)</summary>
        </member>
        <member name="T:SFML.Window.Window">
            <summary>
            Window is a rendering window ; it can create a new window
            or connect to an existing one
            </summary>
        </member>
        <member name="M:SFML.Window.Window.#ctor(SFML.Window.VideoMode,System.String)">
            <summary>
            Create the window with default style and creation settings
            </summary>
            <param name="mode">Video mode to use</param>
            <param name="title">Title of the window</param>
        </member>
        <member name="M:SFML.Window.Window.#ctor(SFML.Window.VideoMode,System.String,SFML.Window.Styles)">
            <summary>
            Create the window with default creation settings
            </summary>
            <param name="mode">Video mode to use</param>
            <param name="title">Title of the window</param>
            <param name="style">Window style (Resize | Close by default)</param>
        </member>
        <member name="M:SFML.Window.Window.#ctor(SFML.Window.VideoMode,System.String,SFML.Window.Styles,SFML.Window.ContextSettings)">
            <summary>
            Create the window
            </summary>
            <param name="mode">Video mode to use</param>
            <param name="title">Title of the window</param>
            <param name="style">Window style (Resize | Close by default)</param>
            <param name="settings">Creation parameters</param>
        </member>
        <member name="M:SFML.Window.Window.#ctor(System.IntPtr)">
            <summary>
            Create the window from an existing control with default creation settings
            </summary>
            <param name="handle">Platform-specific handle of the control</param>
        </member>
        <member name="M:SFML.Window.Window.#ctor(System.IntPtr,SFML.Window.ContextSettings)">
            <summary>
            Create the window from an existing control
            </summary>
            <param name="Handle">Platform-specific handle of the control</param>
            <param name="settings">Creation parameters</param>
        </member>
        <member name="P:SFML.Window.Window.IsOpen">
            <summary>
            Tell whether or not the window is opened (ie. has been created).
            Note that a hidden window (Show(false))
            will still return true
            </summary>
            <returns>True if the window is opened</returns>
        </member>
        <member name="M:SFML.Window.Window.Close">
            <summary>
            Close (destroy) the window.
            The Window instance remains valid and you can call
            Create to recreate the window
            </summary>
        </member>
        <member name="M:SFML.Window.Window.Display">
            <summary>
            Display the window on screen
            </summary>
        </member>
        <member name="P:SFML.Window.Window.Settings">
            <summary>
            Creation settings of the window
            </summary>
        </member>
        <member name="P:SFML.Window.Window.Position">
            <summary>
            Position of the window
            </summary>
        </member>
        <member name="P:SFML.Window.Window.Size">
            <summary>
            Size of the rendering region of the window
            </summary>
        </member>
        <member name="M:SFML.Window.Window.SetTitle(System.String)">
            <summary>
            Change the title of the window
            </summary>
            <param name="title">New title</param>
        </member>
        <member name="M:SFML.Window.Window.SetIcon(System.UInt32,System.UInt32,System.Byte[])">
            <summary>
            Change the window's icon
            </summary>
            <param name="width">Icon's width, in pixels</param>
            <param name="height">Icon's height, in pixels</param>
            <param name="pixels">Array of pixels, format must be RGBA 32 bits</param>
        </member>
        <member name="M:SFML.Window.Window.SetVisible(System.Boolean)">
            <summary>
            Show or hide the window
            </summary>
            <param name="visible">True to show the window, false to hide it</param>
        </member>
        <member name="M:SFML.Window.Window.SetMouseCursorVisible(System.Boolean)">
            <summary>
            Show or hide the mouse cursor
            </summary>
            <param name="show">True to show, false to hide</param>
        </member>
        <member name="M:SFML.Window.Window.SetMouseCursorGrabbed(System.Boolean)">
            <summary>
            Grab or release the mouse cursor
            </summary>
            <param name="grabbed">True to grab, false to release</param>
            
            <remarks>
            If set, grabs the mouse cursor inside this window's client
            area so it may no longer be moved outside its bounds.
            Note that grabbing is only active while the window has
            focus and calling this function for fullscreen windows
            won't have any effect (fullscreen windows always grab the
            cursor).
            </remarks>
        </member>
        <member name="M:SFML.Window.Window.SetMouseCursor(SFML.Window.Cursor)">
            <summary>Set the displayed cursor to a native system cursor</summary>
            <param name="cursor"></param>
        </member>
        <member name="M:SFML.Window.Window.SetVerticalSyncEnabled(System.Boolean)">
            <summary>
            Enable / disable vertical synchronization
            </summary>
            <param name="enable">True to enable v-sync, false to deactivate</param>
        </member>
        <member name="M:SFML.Window.Window.SetKeyRepeatEnabled(System.Boolean)">
            <summary>
            Enable or disable automatic key-repeat.
            Automatic key-repeat is enabled by default
            </summary>
            <param name="enable">True to enable, false to disable</param>
        </member>
        <member name="M:SFML.Window.Window.SetActive">
            <summary>
            Activate the window as the current target
            for rendering
            </summary>
            <returns>True if operation was successful, false otherwise</returns>
        </member>
        <member name="M:SFML.Window.Window.SetActive(System.Boolean)">
            <summary>
            Activate of deactivate the window as the current target
            for rendering
            </summary>
            <param name="active">True to activate, false to deactivate (true by default)</param>
            <returns>True if operation was successful, false otherwise</returns>
        </member>
        <member name="M:SFML.Window.Window.SetFramerateLimit(System.UInt32)">
            <summary>
            Limit the framerate to a maximum fixed frequency
            </summary>
            <param name="limit">Framerate limit, in frames per seconds (use 0 to disable limit)</param>
        </member>
        <member name="M:SFML.Window.Window.SetJoystickThreshold(System.Single)">
            <summary>
            Change the joystick threshold, ie. the value below which
            no move event will be generated
            </summary>
            <param name="threshold">New threshold, in range [0, 100]</param>
        </member>
        <member name="P:SFML.Window.Window.SystemHandle">
            <summary>
            OS-specific handle of the window
            </summary>
        </member>
        <member name="M:SFML.Window.Window.WaitAndDispatchEvents">
            <summary>
            Wait for a new event and dispatch it to the corresponding
            event handler
            </summary>
        </member>
        <member name="M:SFML.Window.Window.DispatchEvents">
            <summary>
            Call the event handlers for each pending event
            </summary>
        </member>
        <member name="M:SFML.Window.Window.RequestFocus">
            <summary>
            Request the current window to be made the active
            foreground window
            </summary>
        </member>
        <member name="M:SFML.Window.Window.HasFocus">
            <summary>
            Check whether the window has the input focus
            </summary>
            <returns>True if the window has focus, false otherwise</returns>
        </member>
        <member name="M:SFML.Window.Window.ToString">
            <summary>
            Provide a string describing the object
            </summary>
            <returns>String description of the object</returns>
        </member>
        <member name="M:SFML.Window.Window.#ctor(System.IntPtr,System.Int32)">
            <summary>
            Constructor for derived classes
            </summary>
            <param name="cPointer">Pointer to the internal object in the C API</param>
            <param name="dummy">Internal hack :)</param>
        </member>
        <member name="M:SFML.Window.Window.PollEvent(SFML.Window.Event@)">
            <summary>
            Internal function to get the next event (non-blocking)
            </summary>
            <param name="eventToFill">Variable to fill with the raw pointer to the event structure</param>
            <returns>True if there was an event, false otherwise</returns>
        </member>
        <member name="M:SFML.Window.Window.WaitEvent(SFML.Window.Event@)">
            <summary>
            Internal function to get the next event (blocking)
            </summary>
            <param name="eventToFill">Variable to fill with the raw pointer to the event structure</param>
            <returns>False if any error occured</returns>
        </member>
        <member name="M:SFML.Window.Window.InternalGetMousePosition">
            <summary>
            Internal function to get the mouse position relative to the window.
            This function is protected because it is called by another class of
            another module, it is not meant to be called by users.
            </summary>
            <returns>Relative mouse position</returns>
        </member>
        <member name="M:SFML.Window.Window.InternalSetMousePosition(SFML.System.Vector2i)">
            <summary>
            Internal function to set the mouse position relative to the window.
            This function is protected because it is called by another class of
            another module, it is not meant to be called by users.
            </summary>
            <param name="position">Relative mouse position</param>
        </member>
        <member name="M:SFML.Window.Window.InternalGetTouchPosition(System.UInt32)">
            <summary>
            Internal function to get the touch position relative to the window.
            This function is protected because it is called by another class of
            another module, it is not meant to be called by users.
            </summary>
            <param name="Finger">Finger index</param>
            <returns>Relative touch position</returns>
        </member>
        <member name="M:SFML.Window.Window.Destroy(System.Boolean)">
            <summary>
            Handle the destruction of the object
            </summary>
            <param name="disposing">Is the GC disposing the object, or is it an explicit call ?</param>
        </member>
        <member name="M:SFML.Window.Window.CallEventHandler(SFML.Window.Event)">
            <summary>
            Call the event handler for the given event
            </summary>
            <param name="e">Event to dispatch</param>
        </member>
        <member name="E:SFML.Window.Window.Closed">
            <summary>Event handler for the Closed event</summary>
        </member>
        <member name="E:SFML.Window.Window.Resized">
            <summary>Event handler for the Resized event</summary>
        </member>
        <member name="E:SFML.Window.Window.LostFocus">
            <summary>Event handler for the LostFocus event</summary>
        </member>
        <member name="E:SFML.Window.Window.GainedFocus">
            <summary>Event handler for the GainedFocus event</summary>
        </member>
        <member name="E:SFML.Window.Window.TextEntered">
            <summary>Event handler for the TextEntered event</summary>
        </member>
        <member name="E:SFML.Window.Window.KeyPressed">
            <summary>Event handler for the KeyPressed event</summary>
        </member>
        <member name="E:SFML.Window.Window.KeyReleased">
            <summary>Event handler for the KeyReleased event</summary>
        </member>
        <member name="E:SFML.Window.Window.MouseWheelMoved">
            <summary>Event handler for the MouseWheelMoved event</summary>
        </member>
        <member name="E:SFML.Window.Window.MouseWheelScrolled">
            <summary>Event handler for the MouseWheelScrolled event</summary>
        </member>
        <member name="E:SFML.Window.Window.MouseButtonPressed">
            <summary>Event handler for the MouseButtonPressed event</summary>
        </member>
        <member name="E:SFML.Window.Window.MouseButtonReleased">
            <summary>Event handler for the MouseButtonReleased event</summary>
        </member>
        <member name="E:SFML.Window.Window.MouseMoved">
            <summary>Event handler for the MouseMoved event</summary>
        </member>
        <member name="E:SFML.Window.Window.MouseEntered">
            <summary>Event handler for the MouseEntered event</summary>
        </member>
        <member name="E:SFML.Window.Window.MouseLeft">
            <summary>Event handler for the MouseLeft event</summary>
        </member>
        <member name="E:SFML.Window.Window.JoystickButtonPressed">
            <summary>Event handler for the JoystickButtonPressed event</summary>
        </member>
        <member name="E:SFML.Window.Window.JoystickButtonReleased">
            <summary>Event handler for the JoystickButtonReleased event</summary>
        </member>
        <member name="E:SFML.Window.Window.JoystickMoved">
            <summary>Event handler for the JoystickMoved event</summary>
        </member>
        <member name="E:SFML.Window.Window.JoystickConnected">
            <summary>Event handler for the JoystickConnected event</summary>
        </member>
        <member name="E:SFML.Window.Window.JoystickDisconnected">
            <summary>Event handler for the JoystickDisconnected event</summary>
        </member>
        <member name="E:SFML.Window.Window.TouchBegan">
            <summary>Event handler for the TouchBegan event</summary>
        </member>
        <member name="E:SFML.Window.Window.TouchMoved">
            <summary>Event handler for the TouchMoved event</summary>
        </member>
        <member name="E:SFML.Window.Window.TouchEnded">
            <summary>Event handler for the TouchEnded event</summary>
        </member>
        <member name="E:SFML.Window.Window.SensorChanged">
            <summary>Event handler for the SensorChanged event</summary>
        </member>
        <member name="T:SFML.LoadingFailedException">
            <summary>
            Exception thrown by SFML whenever loading a resource fails
            </summary>
        </member>
        <member name="M:SFML.LoadingFailedException.#ctor">
            <summary>
            Default constructor (unknown error)
            </summary>
        </member>
        <member name="M:SFML.LoadingFailedException.#ctor(System.String)">
            <summary>
            Failure to load a resource from memory
            </summary>
            <param name="resourceName">Name of the resource</param>
        </member>
        <member name="M:SFML.LoadingFailedException.#ctor(System.String,System.Exception)">
            <summary>
            Failure to load a resource from memory
            </summary>
            <param name="resourceName">Name of the resource</param>
            <param name="innerException">Exception which is the cause ofthe current exception</param>
        </member>
        <member name="M:SFML.LoadingFailedException.#ctor(System.String,System.String)">
            <summary>
            Failure to load a resource from a file
            </summary>
            <param name="resourceName">Name of the resource</param>
            <param name="filename">Path of the file</param>
        </member>
        <member name="M:SFML.LoadingFailedException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Failure to load a resource from a file
            </summary>
            <param name="resourceName">Name of the resource</param>
            <param name="filename">Path of the file</param>
            <param name="innerException">Exception which is the cause ofthe current exception</param>
        </member>
        <member name="M:SFML.LoadingFailedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initialize an instance of the exception with serialized data
            </summary>
            <param name="info">Serialized data</param>
            <param name="context">Contextual informations</param>
        </member>
    </members>
</doc>
