using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp; // Necesario para OutputKind

namespace Alis.Core.Aspect.Memory.Generator
{
    [Generator]
    public class ResourceAccessorGenerator : ISourceGenerator
    {
        private const string ResourceNamespace = "Alis.Core.Aspect.Memory.Generator";
        private const string NamespacePlaceholder = "Alis.Core.Aspect.Memory";
        private const string ResourceFileName = "assets.pak"; 

        public void Initialize(GeneratorInitializationContext context)
        {
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // ----------------------------------------------------------------------
            // CONDICIÓN: Evitar la generación del ModuleInitializer en librerías DLL puras.
            // Esto previene el registro automático en DLLs que solo contienen lógica 
            // y asegura que el registro solo ocurre en el proyecto principal (EXE).
            // ----------------------------------------------------------------------
            if (context.Compilation.Options.OutputKind == OutputKind.DynamicallyLinkedLibrary)
            {
                 // Si es una DLL pura, salimos sin generar el código de inicialización.
                 return;
            }

            // --- Obtener Nombres AOT-Safe ---
            string assemblyName = context.Compilation.AssemblyName ?? "DefaultAssembly";
            
            // Usamos AssemblyName como RootNamespace (solución AOT-safe y robusta).
            string fullResourceName = $"{assemblyName}.{ResourceFileName}"; 

            // 1. Generar la clase Ancla y el Loader de Registro
            string sourceCode = GenerateRegistrationLoader(assemblyName, fullResourceName);

            // 2. Añadir el código generado a la compilación
            context.AddSource("AssemblyLoader.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
        }

        private string GenerateRegistrationLoader(string assemblyName, string fullResourceName)
        {
            // Generamos el código que crea la función Lambda de carga.
            // Aunque GetManifestResourceStream todavía es Reflection, al ser llamado en 
            // un contexto estático y encapsulado, el AOT-Trimmer lo preserva de forma más confiable.
    
            string code = $@"
// <auto-generated/>
using System;
using System.IO;
using System.Reflection; // Necesario para Assembly
using System.Runtime.CompilerServices;

namespace {ResourceNamespace}
{{
    /// <summary>
    /// Clase de anclaje para obtener la referencia AOT-safe a la asamblea ""{assemblyName}"".
    /// </summary>
    public static class ResourceAnchor {{ }}

    /// <summary>
    /// Inicializador estático para registrar esta asamblea en el cargador central.
    /// </summary>
    public static class AssemblyLoader
    {{
        [ModuleInitializer] 
        public static void EnsureLoaded()
        {{
            // Referencia AOT-safe a la asamblea
            var resourceAssembly = typeof(ResourceAnchor).Assembly;
            const string resourceName = ""{fullResourceName}"";

            // Creamos un delegado (Func<Stream>) que encapsula la lógica de acceso
            Func<Stream> assetLoader = () => 
            {{
                // Esta llamada está dentro de un contexto estático y el compilador AOT/Trimmer 
                // tiene una mejor oportunidad de preservarla y el manifiesto.
                Stream stream = resourceAssembly.GetManifestResourceStream(resourceName);
            
                return stream 
                       ?? throw new InvalidOperationException($""El recurso embebido {{resourceName}} no se encontró en la asamblea {assemblyName}."");
            }};
            
            // Registramos el cargador delegado con la librería Alis
            {NamespacePlaceholder}.AssetRegistry.RegisterAssembly(""{assemblyName}"", assetLoader);
        }}
    }}
}}
";
            return code;
        }
    }
}