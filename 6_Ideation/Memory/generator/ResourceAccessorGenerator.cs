using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp; 

namespace Alis.Core.Aspect.Memory.Generator
{
    [Generator]
    public class ResourceAccessorGenerator : ISourceGenerator
    {
        private const string ResourceNamespace = "Alis.Core.Aspect.Memory.Generator";
        private const string NamespacePlaceholder = "Alis.Core.Aspect.Memory";
        private const string ResourceFileName = "assets.pak";

        public void Initialize(GeneratorInitializationContext context)
        {
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // ----------------------------------------------------------------------
            // CONDICIÓN: Evitar la generación del ModuleInitializer en librerías DLL puras.
            // Esto previene el registro automático en DLLs que solo contienen lógica 
            // y asegura que el registro solo ocurre en el proyecto principal (EXE).
            // ----------------------------------------------------------------------
            if (context.Compilation.Options.OutputKind == OutputKind.DynamicallyLinkedLibrary)
            {
                // Si es una DLL pura, salimos sin generar el código de inicialización.
                return;
            }

            // --- Obtener Nombres AOT-Safe ---
            string assemblyName = context.Compilation.AssemblyName ?? "DefaultAssembly";

            // Usamos AssemblyName como RootNamespace (solución AOT-safe y robusta).
            string fullResourceName = $"{assemblyName}.{ResourceFileName}";

            // 1. Generar la clase Ancla y el Loader de Registro
            string sourceCode = GenerateRegistrationLoader(assemblyName, fullResourceName);

            // 2. Añadir el código generado a la compilación
            context.AddSource("AssemblyLoader.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
        }

        private string GenerateRegistrationLoader(string assemblyName, string fullResourceName)
        {
            // Aseguramos que el nombre de la asamblea se utiliza de forma literal.
            // Usamos el namespace completo del AssetRegistry para evitar ambigüedades.
            const string registryNamespace = "Alis.Core.Aspect.Memory.AssetRegistry";

            string code = $@"
// <auto-generated/>
using System;
using System.IO;
using System.Reflection; 
using System.Runtime.CompilerServices;
using System.Diagnostics.CodeAnalysis; // Necesario para [DynamicDependency]

namespace Alis.Core.Aspect.Memory.Generator
{{
    /// <summary>
    /// Clase de anclaje AOT-safe que contiene el método de carga estático.
    /// </summary>
    internal static class ResourceAnchor 
    {{ 
        // ------------------------------------------------------------------------------------
        // CORRECCIÓN AOT: Aplicar DynamicDependency para PRESERVAR el manifiesto de recursos.
        // El valor ""assembly"" indica al trimmer que preserve todos los ManifestResourceNames.
        // ------------------------------------------------------------------------------------
        [DynamicDependency(""assembly"", typeof(ResourceAnchor))]
        public static Stream LoadAsset()
        {{
            // Usamos typeof(ResourceAnchor).Assembly de forma estática.
            var assembly = typeof(ResourceAnchor).Assembly;
            const string resourceName = ""{fullResourceName}"";
            
            // Esta llamada ahora debería funcionar en AOT gracias al atributo de preservación.
            Stream stream = assembly.GetManifestResourceStream(resourceName);
            
            return stream 
                   ?? throw new InvalidOperationException($""El recurso embebido {{resourceName}} no se encontró en la asamblea {assemblyName}."");
        }}
    }}

    /// <summary>
    /// Inicializador estático para registrar esta asamblea en el cargador central.
    /// </summary>
    public static class AssemblyLoader
    {{
        [ModuleInitializer] 
        public static void EnsureLoaded()
        {{
            // Aquí, pasamos un delegado (Func<Stream>) que llama al método estático generado.
            Func<Stream> assetLoader = ResourceAnchor.LoadAsset;
            
            // Registramos el cargador delegado con la librería Alis.
            {registryNamespace}.RegisterAssembly(""{assemblyName}"", assetLoader);
        }}
    }}
}}
";
            return code;
        }
    }
}